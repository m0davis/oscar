{- Revision with emphasis on proofs -}

------------------------------------------------------------------------
-- The Agda standard library
--
-- AVL trees
------------------------------------------------------------------------

-- AVL trees are balanced binary search trees.

-- The search tree invariant is specified using the technique
-- described by Conor McBride in his talk "Pivotal pragmatism".

open import Relation.Binary
open import Relation.Binary.PropositionalEquality as P using (_‚â°_)

module Data.AVL2
  {ùëº‚ü®Key‚ü© ùëº‚ü®Value‚ü© ùëº‚ü®<‚ü©}
  {Key : Set ùëº‚ü®Key‚ü©} (Value : Key ‚Üí Set ùëº‚ü®Value‚ü©)
  {_<_ : Rel Key ùëº‚ü®<‚ü©}
  (isStrictTotalOrder : IsStrictTotalOrder _‚â°_ _<_)
  where

open import Data.Bool.Base using (Bool)
import Data.DifferenceList as DiffList
open import Data.Empty
open import Data.List.Base as List using (List)
open import Data.Maybe.Base hiding (map)
open import Data.Nat.Base hiding (_<_; _‚äî_)
open import Data.Product hiding (map)
open import Data.Unit
open import Function
open import Level using (_‚äî_; Lift; lift)

open IsStrictTotalOrder isStrictTotalOrder

------------------------------------------------------------------------
-- Extended keys

module Extended-key where

  -- The key type extended with a new minimum and maximum.

  data Key‚Å∫ : Set ùëº‚ü®Key‚ü© where
    ‚ä•‚Å∫ ‚ä§‚Å∫ : Key‚Å∫
    [_]   : (k : Key) ‚Üí Key‚Å∫

  -- An extended strict ordering relation.

  infix 4 _<‚Å∫_

  _<‚Å∫_ : Key‚Å∫ ‚Üí Key‚Å∫ ‚Üí Set ùëº‚ü®<‚ü©
  ‚ä•‚Å∫    <‚Å∫ [ _ ] = Lift ‚ä§
  ‚ä•‚Å∫    <‚Å∫ ‚ä§‚Å∫    = Lift ‚ä§
  [ x ] <‚Å∫ [ y ] = x < y
  [ _ ] <‚Å∫ ‚ä§‚Å∫    = Lift ‚ä§
  _     <‚Å∫ _     = Lift ‚ä•

  -- A pair of ordering constraints.

  infix 4 _<_<_

  _<_<_ : Key‚Å∫ ‚Üí Key ‚Üí Key‚Å∫ ‚Üí Set ùëº‚ü®<‚ü©
  l < x < u = l <‚Å∫ [ x ] √ó [ x ] <‚Å∫ u

  -- _<‚Å∫_ is transitive.

  trans‚Å∫ : ‚àÄ l {m u} ‚Üí l <‚Å∫ m ‚Üí m <‚Å∫ u ‚Üí l <‚Å∫ u

  trans‚Å∫ [ l ] {m = [ m ]} {u = [ u ]} l<m m<u = trans l<m m<u

  trans‚Å∫ ‚ä•‚Å∫    {u = [ _ ]} _ _ = _
  trans‚Å∫ ‚ä•‚Å∫    {u = ‚ä§‚Å∫}    _ _ = _
  trans‚Å∫ [ _ ] {u = ‚ä§‚Å∫}    _ _ = _

  trans‚Å∫ _     {m = ‚ä•‚Å∫}    {u = ‚ä•‚Å∫}    _ (lift ())
  trans‚Å∫ _     {m = [ _ ]} {u = ‚ä•‚Å∫}    _ (lift ())
  trans‚Å∫ _     {m = ‚ä§‚Å∫}    {u = ‚ä•‚Å∫}    _ (lift ())
  trans‚Å∫ [ _ ] {m = ‚ä•‚Å∫}    {u = [ _ ]} (lift ()) _
  trans‚Å∫ [ _ ] {m = ‚ä§‚Å∫}    {u = [ _ ]} _ (lift ())
  trans‚Å∫ ‚ä§‚Å∫    {m = ‚ä•‚Å∫}                (lift ()) _
  trans‚Å∫ ‚ä§‚Å∫    {m = [ _ ]}             (lift ()) _
  trans‚Å∫ ‚ä§‚Å∫    {m = ‚ä§‚Å∫}                (lift ()) _

------------------------------------------------------------------------
-- Types and functions which are used to keep track of height
-- invariants

module Height-invariants where

  -- Bits. (I would use Fin 2 instead if Agda had "defined patterns",
  -- so that I could pattern match on 1# instead of suc zero; the text
  -- "suc zero" takes up a lot more space.)

  data ‚Ñï‚ÇÇ : Set where
    0# : ‚Ñï‚ÇÇ
    1# : ‚Ñï‚ÇÇ

  -- Addition.

  infixl 6 _‚äï_

  _‚äï_ : ‚Ñï‚ÇÇ ‚Üí ‚Ñï ‚Üí ‚Ñï
  0# ‚äï n = n
  1# ‚äï n = 1 + n

  -- i ‚äï n -1 = pred (i ‚äï n).

  _‚äï_-1 : ‚Ñï‚ÇÇ ‚Üí ‚Ñï ‚Üí ‚Ñï
  i ‚äï zero  -1 = 0
  i ‚äï suc n -1 = i ‚äï n

  infix 4 _‚àº_‚äî_

  -- If i ‚àº j ‚äî m, then the difference between i and j is at most 1,
  -- and the maximum of i and j is m. _‚àº_‚äî_ is used to record the
  -- balance factor of the AVL trees, and also to ensure that the
  -- absolute value of the balance factor is never more than 1.

  data _‚àº_‚äî_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Set where
    ‚àº+ : ‚àÄ {n} ‚Üí     n ‚àº 1 + n ‚äî 1 + n
    ‚àº0 : ‚àÄ {n} ‚Üí     n ‚àº n     ‚äî n
    ‚àº- : ‚àÄ {n} ‚Üí 1 + n ‚àº n     ‚äî 1 + n

  -- Some lemmas.

  max‚àº : ‚àÄ {i j m} ‚Üí i ‚àº j ‚äî m ‚Üí m ‚àº i ‚äî m
  max‚àº ‚àº+ = ‚àº-
  max‚àº ‚àº0 = ‚àº0
  max‚àº ‚àº- = ‚àº0

  ‚àºmax : ‚àÄ {i j m} ‚Üí i ‚àº j ‚äî m ‚Üí j ‚àº m ‚äî m
  ‚àºmax ‚àº+ = ‚àº0
  ‚àºmax ‚àº0 = ‚àº0
  ‚àºmax ‚àº- = ‚àº+

------------------------------------------------------------------------
-- AVL trees

-- Key/value pairs.

KV : Set (ùëº‚ü®Key‚ü© ‚äî ùëº‚ü®Value‚ü©)
KV = Œ£ Key Value

module Indexed where

  open Extended-key
  open Height-invariants

  -- The trees have three parameters/indices: a lower bound on the
  -- keys, an upper bound, and a height.
  --
  -- (The bal argument is the balance factor.)

  data Tree (l u : Key‚Å∫) : ‚Ñï ‚Üí Set (ùëº‚ü®Key‚ü© ‚äî ùëº‚ü®Value‚ü© ‚äî ùëº‚ü®<‚ü©) where
    leaf : (l<u : l <‚Å∫ u) ‚Üí Tree l u 0
    node : ‚àÄ {hÀ° h ≥ h}
           (k : KV)
           (lk : Tree l [ proj‚ÇÅ k ] hÀ°)
           (ku : Tree [ proj‚ÇÅ k ] u h ≥)
           (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
           Tree l u (suc h)

  -- Cast operations. Logarithmic in the size of the tree, if we don't
  -- count the time needed to construct the new proofs in the leaf
  -- cases. (The same kind of caveat applies to other operations
  -- below.)
  --
  -- Perhaps it would be worthwhile changing the data structure so
  -- that the casts could be implemented in constant time (excluding
  -- proof manipulation). However, note that this would not change the
  -- worst-case time complexity of the operations below (up to¬†Œò).

  castÀ° : ‚àÄ {l m u h} ‚Üí l <‚Å∫ m ‚Üí Tree m u h ‚Üí Tree l u h
  castÀ° {l} l<m (leaf m<u)         = leaf (trans‚Å∫ l l<m m<u)
  castÀ°     l<m (node k mk ku bal) = node k (castÀ° l<m mk) ku bal

  cast ≥ : ‚àÄ {l m u h} ‚Üí Tree l m h ‚Üí m <‚Å∫ u ‚Üí Tree l u h
  cast ≥ {l} (leaf l<m)         m<u = leaf (trans‚Å∫ l l<m m<u)
  cast ≥     (node k lk km bal) m<u = node k lk (cast ≥ km m<u) bal

  -- Various constant-time functions which construct trees out of
  -- smaller pieces, sometimes using rotation.

  joinÀ°‚Å∫ : ‚àÄ {l u hÀ° h ≥ h} ‚Üí
           (k : KV) ‚Üí
           (‚àÉ Œª i ‚Üí Tree l [ proj‚ÇÅ k ] (i ‚äï hÀ°)) ‚Üí
           Tree [ proj‚ÇÅ k ] u h ≥ ‚Üí
           (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
           ‚àÉ Œª i ‚Üí Tree l u (i ‚äï (1 + h))
  joinÀ°‚Å∫ k‚ÇÜ (1# , node k‚ÇÇ t‚ÇÅ
                    (node k‚ÇÑ t‚ÇÉ t‚ÇÖ bal)
                                ‚àº+) t‚Çá ‚àº-  = (0# , node k‚ÇÑ
                                                        (node k‚ÇÇ t‚ÇÅ t‚ÇÉ (max‚àº bal))
                                                        (node k‚ÇÜ t‚ÇÖ t‚Çá (‚àºmax bal))
                                                        ‚àº0)
  joinÀ°‚Å∫ k‚ÇÑ (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº-) t‚ÇÖ ‚àº-  = (0# , node k‚ÇÇ t‚ÇÅ (node k‚ÇÑ t‚ÇÉ t‚ÇÖ ‚àº0) ‚àº0)
  joinÀ°‚Å∫ k‚ÇÑ (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0) t‚ÇÖ ‚àº-  = (1# , node k‚ÇÇ t‚ÇÅ (node k‚ÇÑ t‚ÇÉ t‚ÇÖ ‚àº-) ‚àº+)
  joinÀ°‚Å∫ k‚ÇÇ (1# , t‚ÇÅ)               t‚ÇÉ ‚àº0  = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº-)
  joinÀ°‚Å∫ k‚ÇÇ (1# , t‚ÇÅ)               t‚ÇÉ ‚àº+  = (0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0)
  joinÀ°‚Å∫ k‚ÇÇ (0# , t‚ÇÅ)               t‚ÇÉ bal = (0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)

  join ≥‚Å∫ : ‚àÄ {l u hÀ° h ≥ h} ‚Üí
           (k : KV) ‚Üí
           Tree l [ proj‚ÇÅ k ] hÀ° ‚Üí
           (‚àÉ Œª i ‚Üí Tree [ proj‚ÇÅ k ] u (i ‚äï h ≥)) ‚Üí
           (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
           ‚àÉ Œª i ‚Üí Tree l u (i ‚äï (1 + h))
  join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (1# , node k‚ÇÜ
                       (node k‚ÇÑ t‚ÇÉ t‚ÇÖ bal)
                                t‚Çá ‚àº-) ‚àº+  = (0# , node k‚ÇÑ
                                                        (node k‚ÇÇ t‚ÇÅ t‚ÇÉ (max‚àº bal))
                                                        (node k‚ÇÜ t‚ÇÖ t‚Çá (‚àºmax bal))
                                                        ‚àº0)
  join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (1# , node k‚ÇÑ t‚ÇÉ t‚ÇÖ ‚àº+) ‚àº+  = (0# , node k‚ÇÑ (node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0) t‚ÇÖ ‚àº0)
  join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (1# , node k‚ÇÑ t‚ÇÉ t‚ÇÖ ‚àº0) ‚àº+  = (1# , node k‚ÇÑ (node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº+) t‚ÇÖ ‚àº-)
  join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (1# , t‚ÇÉ)               ‚àº0  = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº+)
  join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (1# , t‚ÇÉ)               ‚àº-  = (0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0)
  join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (0# , t‚ÇÉ)               bal = (0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)

  joinÀ°‚Åª : ‚àÄ {l u} hÀ° {h ≥ h} ‚Üí
           (k : KV) ‚Üí
           (‚àÉ Œª i ‚Üí Tree l [ proj‚ÇÅ k ] (i ‚äï hÀ° -1)) ‚Üí
           Tree [ proj‚ÇÅ k ] u h ≥ ‚Üí
           (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
           ‚àÉ Œª i ‚Üí Tree l u (i ‚äï h)
  joinÀ°‚Åª zero    k‚ÇÇ (0# , t‚ÇÅ) t‚ÇÉ bal = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)
  joinÀ°‚Åª zero    k‚ÇÇ (1# , t‚ÇÅ) t‚ÇÉ bal = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)
  joinÀ°‚Åª (suc _) k‚ÇÇ (0# , t‚ÇÅ) t‚ÇÉ ‚àº+  = join ≥‚Å∫ k‚ÇÇ t‚ÇÅ (1# , t‚ÇÉ) ‚àº+
  joinÀ°‚Åª (suc _) k‚ÇÇ (0# , t‚ÇÅ) t‚ÇÉ ‚àº0  = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº+)
  joinÀ°‚Åª (suc _) k‚ÇÇ (0# , t‚ÇÅ) t‚ÇÉ ‚àº-  = (0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0)
  joinÀ°‚Åª (suc _) k‚ÇÇ (1# , t‚ÇÅ) t‚ÇÉ bal = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)

  join ≥‚Åª : ‚àÄ {l u hÀ°} h ≥ {h} ‚Üí
           (k : KV) ‚Üí
           Tree l [ proj‚ÇÅ k ] hÀ° ‚Üí
           (‚àÉ Œª i ‚Üí Tree [ proj‚ÇÅ k ] u (i ‚äï h ≥ -1)) ‚Üí
           (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
           ‚àÉ Œª i ‚Üí Tree l u (i ‚äï h)
  join ≥‚Åª zero    k‚ÇÇ t‚ÇÅ (0# , t‚ÇÉ) bal = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)
  join ≥‚Åª zero    k‚ÇÇ t‚ÇÅ (1# , t‚ÇÉ) bal = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)
  join ≥‚Åª (suc _) k‚ÇÇ t‚ÇÅ (0# , t‚ÇÉ) ‚àº-  = joinÀ°‚Å∫ k‚ÇÇ (1# , t‚ÇÅ) t‚ÇÉ ‚àº-
  join ≥‚Åª (suc _) k‚ÇÇ t‚ÇÅ (0# , t‚ÇÉ) ‚àº0  = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº-)
  join ≥‚Åª (suc _) k‚ÇÇ t‚ÇÅ (0# , t‚ÇÉ) ‚àº+  = (0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0)
  join ≥‚Åª (suc _) k‚ÇÇ t‚ÇÅ (1# , t‚ÇÉ) bal = (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)

  -- Extracts the smallest element from the tree, plus the rest.
  -- Logarithmic in the size of the tree.

  headTail : ‚àÄ {l u h} ‚Üí Tree l u (1 + h) ‚Üí
             ‚àÉ Œª (k : KV) ‚Üí l <‚Å∫ [ proj‚ÇÅ k ] √ó
                            ‚àÉ Œª i ‚Üí Tree [ proj‚ÇÅ k ] u (i ‚äï h)
  headTail (node k‚ÇÅ (leaf l<k‚ÇÅ) t‚ÇÇ ‚àº+) = (k‚ÇÅ , l<k‚ÇÅ , 0# , t‚ÇÇ)
  headTail (node k‚ÇÅ (leaf l<k‚ÇÅ) t‚ÇÇ ‚àº0) = (k‚ÇÅ , l<k‚ÇÅ , 0# , t‚ÇÇ)
  headTail (node {hÀ° = suc _} k‚ÇÉ t‚ÇÅ‚ÇÇ t‚ÇÑ bal) with headTail t‚ÇÅ‚ÇÇ
  ... | (k‚ÇÅ , l<k‚ÇÅ , t‚ÇÇ) = (k‚ÇÅ , l<k‚ÇÅ , joinÀ°‚Åª _ k‚ÇÉ t‚ÇÇ t‚ÇÑ bal)

  -- Extracts the largest element from the tree, plus the rest.
  -- Logarithmic in the size of the tree.

  initLast : ‚àÄ {l u h} ‚Üí Tree l u (1 + h) ‚Üí
             ‚àÉ Œª (k : KV) ‚Üí [ proj‚ÇÅ k ] <‚Å∫ u √ó
                            ‚àÉ Œª i ‚Üí Tree l [ proj‚ÇÅ k ] (i ‚äï h)
  initLast (node k‚ÇÇ t‚ÇÅ (leaf k‚ÇÇ<u) ‚àº-) = (k‚ÇÇ , k‚ÇÇ<u , (0# , t‚ÇÅ))
  initLast (node k‚ÇÇ t‚ÇÅ (leaf k‚ÇÇ<u) ‚àº0) = (k‚ÇÇ , k‚ÇÇ<u , (0# , t‚ÇÅ))
  initLast (node {h ≥ = suc _} k‚ÇÇ t‚ÇÅ t‚ÇÉ‚ÇÑ bal) with initLast t‚ÇÉ‚ÇÑ
  ... | (k‚ÇÑ , k‚ÇÑ<u , t‚ÇÉ) = (k‚ÇÑ , k‚ÇÑ<u , join ≥‚Åª _ k‚ÇÇ t‚ÇÅ t‚ÇÉ bal)

  -- Another joining function. Logarithmic in the size of either of
  -- the input trees (which need to have almost equal heights).

  join : ‚àÄ {l m u hÀ° h ≥ h} ‚Üí
         Tree l m hÀ° ‚Üí Tree m u h ≥ ‚Üí (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
         ‚àÉ Œª i ‚Üí Tree l u (i ‚äï h)
  join t‚ÇÅ (leaf m<u) ‚àº0 = (0# , cast ≥ t‚ÇÅ m<u)
  join t‚ÇÅ (leaf m<u) ‚àº- = (0# , cast ≥ t‚ÇÅ m<u)
  join {h ≥ = suc _} t‚ÇÅ t‚ÇÇ‚ÇÉ bal with headTail t‚ÇÇ‚ÇÉ
  ... | (k‚ÇÇ , m<k‚ÇÇ , t‚ÇÉ) = join ≥‚Åª _ k‚ÇÇ (cast ≥ t‚ÇÅ m<k‚ÇÇ) t‚ÇÉ bal

  -- An empty tree.

  empty : ‚àÄ {l u} ‚Üí l <‚Å∫ u ‚Üí Tree l u 0
  empty = leaf

  -- A singleton tree.

  singleton : ‚àÄ {l u} (k : Key) ‚Üí Value k ‚Üí l < k < u ‚Üí Tree l u 1
  singleton k v (l<k , k<u) = node (k , v) (leaf l<k) (leaf k<u) ‚àº0

  -- Inserts a key into the tree, using a function to combine any
  -- existing value with the new value. Logarithmic in the size of the
  -- tree (assuming constant-time comparisons and a constant-time
  -- combining function).

  insertWith : ‚àÄ {l u h} ‚Üí (k : Key) ‚Üí Value k ‚Üí
               (Value k ‚Üí Value k ‚Üí Value k) ‚Üí  -- New ‚Üí old ‚Üí result.
               Tree l u h ‚Üí l < k < u ‚Üí
               ‚àÉ Œª i ‚Üí Tree l u (i ‚äï h)
  insertWith k v f (leaf l<u) l<k<u = (1# , singleton k v l<k<u)
  insertWith k v f (node (k‚Ä≤ , v‚Ä≤) lp pu bal) (l<k , k<u) with compare k k‚Ä≤
  ... | tri< k<k‚Ä≤ _ _ = joinÀ°‚Å∫ (k‚Ä≤ , v‚Ä≤) (insertWith k v f lp (l<k , k<k‚Ä≤)) pu bal
  ... | tri> _ _ k‚Ä≤<k = join ≥‚Å∫ (k‚Ä≤ , v‚Ä≤) lp (insertWith k v f pu (k‚Ä≤<k , k<u)) bal
  ... | tri‚âà _ k‚â°k‚Ä≤ _ rewrite P.sym k‚â°k‚Ä≤ = (0# , node (k , f v v‚Ä≤) lp pu bal)

  -- Inserts a key into the tree. If the key already exists, then it
  -- is replaced. Logarithmic in the size of the tree (assuming
  -- constant-time comparisons).

  insert : ‚àÄ {l u h} ‚Üí (k : Key) ‚Üí Value k ‚Üí Tree l u h ‚Üí l < k < u ‚Üí
           ‚àÉ Œª i ‚Üí Tree l u (i ‚äï h)
  insert k v = insertWith k v const

  -- Deletes the key/value pair containing the given key, if any.
  -- Logarithmic in the size of the tree (assuming constant-time
  -- comparisons).

  delete : ‚àÄ {l u h} ‚Üí Key ‚Üí Tree l u h ‚Üí
           ‚àÉ Œª i ‚Üí Tree l u (i ‚äï h -1)
  delete k (leaf l<u)         = (0# , leaf l<u)
  delete k (node p lp pu bal) with compare k (proj‚ÇÅ p)
  ... | tri< _ _ _ = joinÀ°‚Åª _ p (delete k lp) pu bal
  ... | tri> _ _ _ = join ≥‚Åª _ p lp (delete k pu) bal
  ... | tri‚âà _ _ _ = join lp pu bal

  -- Looks up a key. Logarithmic in the size of the tree (assuming
  -- constant-time comparisons).

  lookup : ‚àÄ {l u h} ‚Üí (k : Key) ‚Üí Tree l u h ‚Üí Maybe (Value k)
  lookup k (leaf _)                  = nothing
  lookup k (node (k‚Ä≤ , v) lk‚Ä≤ k‚Ä≤u _) with compare k k‚Ä≤
  ... | tri< _ _  _ = lookup k lk‚Ä≤
  ... | tri> _ _  _ = lookup k k‚Ä≤u
  ... | tri‚âà _ eq _ rewrite eq = just v

  -- Maps a function over all values in the tree.

  map : (‚àÄ {k} ‚Üí Value k ‚Üí Value k) ‚Üí
        ‚àÄ {l u h} ‚Üí Tree l u h ‚Üí Tree l u h
  map f (leaf l<u)             = leaf l<u
  map f (node (k , v) l r bal) = node (k , f v) (map f l) (map f r) bal

  -- Converts the tree to an ordered list. Linear in the size of the
  -- tree.

  open DiffList

  toDiffList : ‚àÄ {l u h} ‚Üí Tree l u h ‚Üí DiffList KV
  toDiffList (leaf _)       = []
  toDiffList (node k l r _) = toDiffList l ++ k ‚à∑ toDiffList r

module MSD where

  open Indexed

  open Extended-key
  open Height-invariants
  
  open import Relation.Binary.HeterogeneousEquality as H using ( _‚âÖ_ )
  open import Relation.Nullary.Negation
  import Data.List as L

  Tree‚ü∂<‚Å∫ : ‚àÄ { k‚Éñ k‚Éó h } ‚Üí Tree k‚Éñ k‚Éó h ‚Üí k‚Éñ <‚Å∫ k‚Éó
  Tree‚ü∂<‚Å∫ ( leaf k‚Éñ<k‚Éó ) = k‚Éñ<k‚Éó
  Tree‚ü∂<‚Å∫ { k‚Éñ = k‚Éñ } ( node _ t‚Éñ t‚Éó _ ) = trans‚Å∫ k‚Éñ ( Tree‚ü∂<‚Å∫ t‚Éñ ) ( Tree‚ü∂<‚Å∫ t‚Éó )

  data _‚àà_ { k‚Éñ k‚Éó } ( k : Key ) : ‚àÄ { h } ‚Üí Tree k‚Éñ k‚Éó h ‚Üí Set ( ùëº‚ü®Key‚ü© ‚äî ùëº‚ü®Value‚ü© ‚äî ùëº‚ü®<‚ü© ) where
    here : ‚àÄ
           { h‚Éñ h‚Éó h v }
           { t‚Éñ : Tree k‚Éñ [ k ] h‚Éñ }
           { t‚Éó : Tree [ k ]  k‚Éó h‚Éó }
           { bal : h‚Éñ ‚àº h‚Éó ‚äî h }
           ‚Üí k ‚àà node ( k , v ) t‚Éñ t‚Éó bal
    left : ‚àÄ
           { h‚Éñ h‚Éó h k‚Ä≤ } { v‚Ä≤ : Value k‚Ä≤ }
           { t‚Éñ : Tree k‚Éñ [ k‚Ä≤ ] h‚Éñ }
           { t‚Éó : Tree [ k‚Ä≤ ]  k‚Éó h‚Éó }
           { bal : h‚Éñ ‚àº h‚Éó ‚äî h }
           ‚Üí k ‚àà t‚Éñ
           ‚Üí k ‚àà node ( k‚Ä≤ , v‚Ä≤ ) t‚Éñ t‚Éó bal
    right : ‚àÄ
            { h‚Éñ h‚Éó h k‚Ä≤ } { v‚Ä≤ : Value k‚Ä≤ }
            { t‚Éñ : Tree k‚Éñ [ k‚Ä≤ ] h‚Éñ }
            { t‚Éó : Tree [ k‚Ä≤ ] k‚Éó h‚Éó }
            { bal : h‚Éñ ‚àº h‚Éó ‚äî h }
            ‚Üí k ‚àà t‚Éó
            ‚Üí k ‚àà node ( k‚Ä≤ , v‚Ä≤ ) t‚Éñ t‚Éó bal

  ‚àà‚ü∂Tree : ‚àÄ { l u h } { t : Tree l u h } { k : Key } ‚Üí k ‚àà t ‚Üí Tree l u h
  ‚àà‚ü∂Tree { t = t } _ = t

  ‚àà‚ü∂<< : ‚àÄ { l u h } { t : Tree l u h } { k : Key } ‚Üí k ‚àà t ‚Üí l < k < u
  ‚àà‚ü∂<< ( here { t‚Éñ = t‚Éñ } { t‚Éó = t‚Éó } ) = Tree‚ü∂<‚Å∫ t‚Éñ , Tree‚ü∂<‚Å∫ t‚Éó
  ‚àà‚ü∂<< { l = l } { u = u } { k = k } ( left { k‚Ä≤ = k‚Ä≤ } { t‚Éó = t‚Éó } k‚ààtÀ° ) = l<k , k<u where
    l<k<k‚Ä≤ : l < k < [ k‚Ä≤ ]
    l<k<k‚Ä≤ = ‚àà‚ü∂<< k‚ààtÀ°
   
    l<k : l <‚Å∫ [ k ]
    l<k = proj‚ÇÅ l<k<k‚Ä≤
   
    k<k‚Ä≤ : [ k ] <‚Å∫ [ k‚Ä≤ ]
    k<k‚Ä≤ = proj‚ÇÇ l<k<k‚Ä≤
   
    k‚Ä≤<u : [ k‚Ä≤ ] <‚Å∫ u
    k‚Ä≤<u = Tree‚ü∂<‚Å∫ t‚Éó
   
    k<u : [ k ] <‚Å∫ u
    k<u = trans‚Å∫ [ k ] { m = [ k‚Ä≤ ] } { u = u } k<k‚Ä≤ k‚Ä≤<u
  ‚àà‚ü∂<< { l = l } { u = u } { k = k } ( right { k‚Ä≤ = k‚Ä≤ } { t‚Éñ = lk‚Ä≤ } k‚ààt ≥ ) = l<k , k<u where
    k‚Ä≤<k<u : [ k‚Ä≤ ] < k < u
    k‚Ä≤<k<u = ‚àà‚ü∂<< k‚ààt ≥
   
    k<u : [ k ] <‚Å∫ u
    k<u = proj‚ÇÇ k‚Ä≤<k<u
   
    k‚Ä≤<k : [ k‚Ä≤ ] <‚Å∫ [ k ] 
    k‚Ä≤<k = proj‚ÇÅ k‚Ä≤<k<u
   
    l<k‚Ä≤ : l <‚Å∫ [ k‚Ä≤ ]
    l<k‚Ä≤ = Tree‚ü∂<‚Å∫ lk‚Ä≤
   
    l<k : l <‚Å∫ [ k ]
    l<k = trans‚Å∫ l { m = [ k‚Ä≤ ] } { u = [ k ] } l<k‚Ä≤ k‚Ä≤<k
   
  data _‚àº_‚ààÃÉ_ { k‚Éñ k‚Éó : Key‚Å∫ } ( k : Key ) ( v : Value k ) {- ( k' : Key ) ‚¶É _ : k ‚â° k' ‚¶Ñ -} : ‚àÄ { h : ‚Ñï } ‚Üí Tree k‚Éñ k‚Éó h ‚Üí Set ( ùëº‚ü®Key‚ü© ‚äî ùëº‚ü®Value‚ü© ‚äî ùëº‚ü®<‚ü© ) where
    here : ‚àÄ
           { h‚Éñ h‚Éó h }
           { t‚Éñ : Tree k‚Éñ [ k ] h‚Éñ }
           { t‚Éó : Tree [ k ]  k‚Éó h‚Éó }
           { bal : h‚Éñ ‚àº h‚Éó ‚äî h }
           ‚Üí k ‚àº v ‚ààÃÉ node ( k , v ) t‚Éñ t‚Éó bal
    left : ‚àÄ
           { h‚Éñ h‚Éó h k‚Ä≤ } { v‚Ä≤ : Value k‚Ä≤ }
           { t‚Éñ : Tree k‚Éñ [ k‚Ä≤ ] h‚Éñ }
           { t‚Éó : Tree [ k‚Ä≤ ]  k‚Éó h‚Éó }
           { bal : h‚Éñ ‚àº h‚Éó ‚äî h }
           ‚Üí k ‚àº v ‚ààÃÉ t‚Éñ
           ‚Üí k ‚àº v ‚ààÃÉ node ( k‚Ä≤ , v‚Ä≤ ) t‚Éñ t‚Éó bal
    right : ‚àÄ
            { h‚Éñ h‚Éó h k‚Ä≤ } { v‚Ä≤ : Value k‚Ä≤ }
            { t‚Éñ : Tree k‚Éñ [ k‚Ä≤ ] h‚Éñ }
            { t‚Éó : Tree [ k‚Ä≤ ] k‚Éó h‚Éó }
            { bal : h‚Éñ ‚àº h‚Éó ‚äî h }
            ‚Üí k ‚àº v ‚ààÃÉ t‚Éó
            ‚Üí k ‚àº v ‚ààÃÉ node ( k‚Ä≤ , v‚Ä≤ ) t‚Éñ t‚Éó bal

  _‚ààÃå_ : ‚àÄ { k‚Éñ k‚Éó : Key‚Å∫ } { h } ( kv : KV ) ‚Üí ( t : Tree k‚Éñ k‚Éó h )  ‚Üí Set ( ùëº‚ü®Key‚ü© ‚äî ùëº‚ü®Value‚ü© ‚äî ùëº‚ü®<‚ü© )
  (k , v) ‚ààÃå t = k ‚àº v ‚ààÃÉ t

  ‚ààÃÉ‚Üí‚àà : ‚àÄ { k l u h } { v : Value k } { t : Tree l u h } ‚Üí k ‚àº v ‚ààÃÉ t ‚Üí k ‚àà t
  ‚ààÃÉ‚Üí‚àà here = here
  ‚ààÃÉ‚Üí‚àà (left x) = left (‚ààÃÉ‚Üí‚àà x)
  ‚ààÃÉ‚Üí‚àà (right x) = right (‚ààÃÉ‚Üí‚àà x)

  ‚ààÃå‚ü∂l<‚Å∫k : ‚àÄ { k l u h } { v : Value k } { t : Tree l u h } ‚Üí k ‚àº v ‚ààÃÉ t ‚Üí l <‚Å∫ [ k ]
  ‚ààÃå‚ü∂l<‚Å∫k x = proj‚ÇÅ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà x))

  ‚ààÃå‚ü∂k<‚Å∫u : ‚àÄ { k l u h } { v : Value k } { t : Tree l u h } ‚Üí k ‚àº v ‚ààÃÉ t ‚Üí [ k ] <‚Å∫ u
  ‚ààÃå‚ü∂k<‚Å∫u x = proj‚ÇÇ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà x))

  open import Data.Sum using (_‚äé_ ; inj‚ÇÅ ; inj‚ÇÇ)

  a‚âÆa : ‚àÄ { k } ‚Üí k < k ‚Üí ‚ä•
  a‚âÆa = irrefl P.refl
  
  lemL : ‚àÄ { k l h } { v : Value k } { t : Tree l [ k ] h } ‚Üí k ‚àº v ‚ààÃÉ t ‚Üí ‚ä•
  lemL x = contradiction ( proj‚ÇÇ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà x))) ( a‚âÆa) where
    
  lemR : ‚àÄ { k u h } { v : Value k } { t : Tree [ k ] u h } ‚Üí k ‚àº v ‚ààÃÉ t ‚Üí ‚ä•
  lemR x = contradiction ( proj‚ÇÅ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà x))) ( a‚âÆa) where

  open import Relation.Binary.Consequences
    
  k‚Üív : ‚àÄ {kv1 kv2 : KV} {l u h} {t : Tree l u h} ‚Üí kv1 ‚ààÃå t ‚Üí kv2 ‚ààÃå t ‚Üí proj‚ÇÅ kv1 ‚â° proj‚ÇÅ kv2 ‚Üí kv1 ‚âÖ kv2
  k‚Üív here here P.refl = H.refl
  k‚Üív (here { t‚Éñ = t‚Éñ })  (left kv2‚ààÃåt) P.refl = ‚ä•-elim (lemL kv2‚ààÃåt)
  k‚Üív here (right kv2‚ààÃåt) P.refl = ‚ä•-elim (lemR kv2‚ààÃåt)
  k‚Üív (left kv1‚ààÃåtÀ°) here P.refl = ‚ä•-elim (lemL kv1‚ààÃåtÀ°)
  k‚Üív (left kv1‚ààÃåtÀ°) (left kv2‚ààÃåt) P.refl = k‚Üív kv1‚ààÃåtÀ° kv2‚ààÃåt P.refl
  k‚Üív (left kv1‚ààÃåtÀ°) (right kv2‚ààÃåt) P.refl = contradiction (proj‚ÇÇ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv1‚ààÃåtÀ°))) (tri‚ü∂asym compare (proj‚ÇÅ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv2‚ààÃåt))))
  k‚Üív (right kv1‚ààÃåt ≥) here P.refl = ‚ä•-elim (lemR kv1‚ààÃåt ≥)
  k‚Üív (right kv1‚ààÃåt ≥) (left kv2‚ààÃåt) P.refl = contradiction (proj‚ÇÇ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv2‚ààÃåt))) (tri‚ü∂asym compare (proj‚ÇÅ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv1‚ààÃåt ≥))))
  k‚Üív (right kv1‚ààÃåt ≥) (right kv2‚ààÃåt) P.refl = k‚Üív kv1‚ààÃåt ≥ kv2‚ààÃåt P.refl

  k‚Üív' : ‚àÄ { k : Key } { v‚ÇÅ v‚ÇÇ : Value k } { l u h } { t : Tree l u h } ‚Üí k ‚àº v‚ÇÅ ‚ààÃÉ t ‚Üí k ‚àº v‚ÇÇ ‚ààÃÉ t ‚Üí v‚ÇÅ ‚â° v‚ÇÇ
  k‚Üív' here here = P.refl
  k‚Üív' here (left kv2‚ààÃåt) = ‚ä•-elim (lemL kv2‚ààÃåt)
  k‚Üív' here (right kv2‚ààÃåt) = ‚ä•-elim (lemR kv2‚ààÃåt)
  k‚Üív' (left kv1‚ààÃåtÀ°) here = ‚ä•-elim (lemL kv1‚ààÃåtÀ°)
  k‚Üív' (left kv1‚ààÃåtÀ°) (left kv2‚ààÃåt) = k‚Üív' kv1‚ààÃåtÀ° kv2‚ààÃåt
  k‚Üív' (left kv1‚ààÃåtÀ°) (right kv2‚ààÃåt) = contradiction (proj‚ÇÇ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv1‚ààÃåtÀ°))) (tri‚ü∂asym compare (proj‚ÇÅ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv2‚ààÃåt))))
  k‚Üív' (right kv1‚ààÃåt ≥) here = ‚ä•-elim (lemR kv1‚ààÃåt ≥)
  k‚Üív' (right kv1‚ààÃåt ≥) (left kv2‚ààÃåt) = contradiction (proj‚ÇÇ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv2‚ààÃåt))) (tri‚ü∂asym compare (proj‚ÇÅ (‚àà‚ü∂<< (‚ààÃÉ‚Üí‚àà kv1‚ààÃåt ≥))))
  k‚Üív' (right kv1‚ààÃåt ≥) (right kv2‚ààÃåt) = k‚Üív' kv1‚ààÃåt ≥ kv2‚ààÃåt

  <‚Å∫‚ü∂< : ‚àÄ {l u} ‚Üí [ l ] <‚Å∫ [ u ] ‚Üí l < u
  <‚Å∫‚ü∂< [l]<‚Å∫[u] = [l]<‚Å∫[u]

  kv<k‚Üíkv‚ààt1 : ‚àÄ {l1 u1 k kv h1 h2 H1} ‚Üí
            {v : Value k}
            {t1 : Tree l1 [ k ] h1} ‚Üí
            {t2 : Tree [ k ] u1 h2} ‚Üí
            {bal1 : h1 ‚àº h2 ‚äî H1} ‚Üí
            proj‚ÇÅ kv < k ‚Üí
            kv ‚ààÃå node (k , v) t1 t2 bal1 ‚Üí 
            kv ‚ààÃå t1
  kv<k‚Üíkv‚ààt1 kv<k here = ‚ä•-elim (irrefl P.refl kv<k)
  kv<k‚Üíkv‚ààt1 kv<k (left kv‚ààÃånode) = kv‚ààÃånode
  kv<k‚Üíkv‚ààt1 {kv = (k , v)} kv<k (right kv‚ààÃånode) = contradiction (<‚Å∫‚ü∂< (‚ààÃå‚ü∂l<‚Å∫k kv‚ààÃånode)) (tri‚ü∂asym compare kv<k)

  k<kv‚Üíkv‚ààt2 : ‚àÄ {l1 u1 k kv h1 h2 H1} ‚Üí
            {v : Value k}
            {t1 : Tree l1 [ k ] h1} ‚Üí
            {t2 : Tree [ k ] u1 h2} ‚Üí
            {bal1 : h1 ‚àº h2 ‚äî H1} ‚Üí
            k < proj‚ÇÅ kv ‚Üí
            kv ‚ààÃå node (k , v) t1 t2 bal1 ‚Üí 
            kv ‚ààÃå t2
  k<kv‚Üíkv‚ààt2 k<kv here = ‚ä•-elim (irrefl P.refl k<kv)
  k<kv‚Üíkv‚ààt2 k<kv (right kv‚ààÃånode) = kv‚ààÃånode
  k<kv‚Üíkv‚ààt2 {kv = (k , v)} k<kv (left kv‚ààÃånode) = contradiction (<‚Å∫‚ü∂< (‚ààÃå‚ü∂k<‚Å∫u kv‚ààÃånode)) (tri‚ü∂asym compare k<kv)

  t1‚Üít3 : ‚àÄ {l1 l2 u1 u2 k kv h1 h2 h3 h4 H1 H2} ‚Üí
            {v : Value k}
            {t1 : Tree l1 [ k ] h1} ‚Üí
            {t2 : Tree [ k ] u1 h2} ‚Üí
            {t3 : Tree l2 [ k ] h3} ‚Üí
            {t4 : Tree [ k ] u2 h4} ‚Üí
            {bal1 : h1 ‚àº h2 ‚äî H1}
            {bal2 : h3 ‚àº h4 ‚äî H2} ‚Üí
            (kv ‚ààÃå node (k , v) t1 t2 bal1 ‚Üí kv ‚ààÃå node (k , v) t3 t4 bal2) ‚Üí
            kv ‚ààÃå t1 ‚Üí kv ‚ààÃå t3
  t1‚Üít3 ‚ààÃå‚Üí‚ààÃå kv‚ààÃåt1 = let kv‚ààÃånode12 = left kv‚ààÃåt1 in kv<k‚Üíkv‚ààt1 (<‚Å∫‚ü∂< (‚ààÃå‚ü∂k<‚Å∫u kv‚ààÃåt1)) (‚ààÃå‚Üí‚ààÃå kv‚ààÃånode12)

  t2‚Üít4 : ‚àÄ {l1 l2 u1 u2 k kv h1 h2 h3 h4 H1 H2} ‚Üí
            {v : Value k}
            {t1 : Tree l1 [ k ] h1} ‚Üí
            {t2 : Tree [ k ] u1 h2} ‚Üí
            {t3 : Tree l2 [ k ] h3} ‚Üí
            {t4 : Tree [ k ] u2 h4} ‚Üí
            {bal1 : h1 ‚àº h2 ‚äî H1}
            {bal2 : h3 ‚àº h4 ‚äî H2} ‚Üí
            (kv ‚ààÃå node (k , v) t1 t2 bal1 ‚Üí kv ‚ààÃå node (k , v) t3 t4 bal2) ‚Üí
            kv ‚ààÃå t2 ‚Üí kv ‚ààÃå t4
  t2‚Üít4 ‚ààÃå‚Üí‚ààÃå kv‚ààÃåt2 = let kv‚ààÃånode12 = right kv‚ààÃåt2 in k<kv‚Üíkv‚ààt2 (<‚Å∫‚ü∂< (‚ààÃå‚ü∂l<‚Å∫k kv‚ààÃåt2)) (‚ààÃå‚Üí‚ààÃå kv‚ààÃånode12)

  open import Relation.Binary.PropositionalEquality.Core
  open import Relation.Binary.PropositionalEquality

  ‚ààÃÉ‚Üív1‚â°v2 : ‚àÄ { k l u h1 h2 h } ‚Üí { v1 v2 : Value k } { t‚ÇÅ : Tree l [ k ] h1 } { t‚ÇÇ : Tree [ k ] u h2 } { bal : h1 ‚àº h2 ‚äî h } ‚Üí k ‚àº v1 ‚ààÃÉ node (k , v2) t‚ÇÅ t‚ÇÇ bal ‚Üí v1 ‚â° v2
  ‚ààÃÉ‚Üív1‚â°v2 here = refl
  ‚ààÃÉ‚Üív1‚â°v2 (left x) = ‚ä•-elim (lemL x)
  ‚ààÃÉ‚Üív1‚â°v2 (right x) = ‚ä•-elim (lemR x)
    
  ‚ààÃÉ‚Üív2‚â°v1 : ‚àÄ { k l u h1 h2 h } ‚Üí { v1 v2 : Value k } { t‚ÇÅ : Tree l [ k ] h1 } { t‚ÇÇ : Tree [ k ] u h2 } { bal : h1 ‚àº h2 ‚äî h } ‚Üí k ‚àº v1 ‚ààÃÉ node (k , v2) t‚ÇÅ t‚ÇÇ bal ‚Üí v2 ‚â° v1
  ‚ààÃÉ‚Üív2‚â°v1 here = refl
  ‚ààÃÉ‚Üív2‚â°v1 (left x) = ‚ä•-elim (lemL x)
  ‚ààÃÉ‚Üív2‚â°v1 (right x) = ‚ä•-elim (lemR x)


  lemjl- : ‚àÄ { k‚Éñ‚ÇÅ k‚Éó‚ÇÅ h‚ÇÅ k‚Éñ‚ÇÇ k‚Éó‚ÇÇ h‚ÇÇ } ‚Üí
           ( t‚ÇÅ : Tree k‚Éñ‚ÇÅ k‚Éó‚ÇÅ h‚ÇÅ )
           ( t‚ÇÇ : Tree k‚Éñ‚ÇÇ k‚Éó‚ÇÇ h‚ÇÇ )
           ( _ : ‚àÄ {kv} ‚Üí kv ‚ààÃå t‚ÇÅ ‚Üí kv ‚ààÃå t‚ÇÇ )
           ( _ : ‚àÄ {kv} ‚Üí kv ‚ààÃå t‚ÇÇ ‚Üí kv ‚ààÃå t‚ÇÅ ) ‚Üí
           ( lst : List KV ) ‚Üí
           (toDiffList t‚ÇÅ) lst ‚â° (toDiffList t‚ÇÇ) lst
  lemjl- (leaf l<u) (leaf l<u‚ÇÅ) x‚ÇÇ x‚ÇÉ lst = P.refl
  lemjl- (leaf l<u) (node k‚ÇÅ t‚ÇÇ t‚ÇÉ bal) x‚ÇÇ x‚ÇÉ lst = contradiction (x‚ÇÉ here) (Œª ())
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (leaf l<u) x‚ÇÇ x‚ÇÉ lst = contradiction (x‚ÇÇ here) (Œª ())
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) x‚ÇÇ x‚ÇÉ lst with compare (proj‚ÇÅ k‚ÇÅ) (proj‚ÇÅ k‚ÇÇ)
  lemjl- (node ( k‚ÇÅ , v‚ÇÅ ) t‚ÇÅ t‚ÇÇ bal) (node ( k‚ÇÇ , v‚ÇÇ ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ) kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ lst | tri‚âà k‚ÇÅ‚âÆk‚ÇÇ k‚ÇÅ‚â°k‚ÇÇ k‚ÇÇ‚âÆk‚ÇÅ rewrite
         k‚ÇÅ‚â°k‚ÇÇ
         -- When the below lines are commented-out, then C-c C-, at goal 0 (below) reports the following types:
            {-
              kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ
                       : {kv : Œ£ Key Value} ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÇ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÅ) t‚ÇÅ t‚ÇÇ bal
              kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ
                       : {kv : Œ£ Key Value} ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÅ) t‚ÇÅ t‚ÇÇ bal ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÇ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ
            -}

         -- However, uncommenting the below rewrite...
         -- | ‚ààÃÉ‚Üív2‚â°v1 (kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ here) -- equivalent to v‚ÇÇ ‚â° v‚ÇÅ
         -- ... results in the following types being reported:
            {-
              kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ
                       : {kv : Œ£ Key Value} ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÅ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÅ) t‚ÇÅ t‚ÇÇ bal
              kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ
                       : {kv : Œ£ Key Value} ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÅ) t‚ÇÅ t‚ÇÇ bal ‚Üí
                         proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ node (k‚ÇÇ , v‚ÇÇ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ
            -}

         -- So, v‚ÇÅ has been rewritten to v‚ÇÇ in kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ but not in kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ. Why?
         = {!!}
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ lst | tri< k‚ÇÅ<k‚ÇÇ k‚ÇÅ‚â¢k‚ÇÇ k‚ÇÇ‚âÆk‚ÇÅ = {!!}
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ lst | tri> k‚ÇÅ‚âÆk‚ÇÇ k‚ÇÅ‚â¢k‚ÇÇ k‚ÇÇ<k‚ÇÅ = {!!}
  
{-
  lemjl- : ‚àÄ { k‚Éñ‚ÇÅ k‚Éó‚ÇÅ h‚ÇÅ k‚Éñ‚ÇÇ k‚Éó‚ÇÇ h‚ÇÇ } ‚Üí
           ( t‚ÇÅ : Tree k‚Éñ‚ÇÅ k‚Éó‚ÇÅ h‚ÇÅ )
           ( t‚ÇÇ : Tree k‚Éñ‚ÇÇ k‚Éó‚ÇÇ h‚ÇÇ )
           ( _ : ‚àÄ {kv} ‚Üí kv ‚ààÃå t‚ÇÅ ‚Üí kv ‚ààÃå t‚ÇÇ )
           ( _ : ‚àÄ {kv} ‚Üí kv ‚ààÃå t‚ÇÇ ‚Üí kv ‚ààÃå t‚ÇÅ ) ‚Üí
           ( lst : List KV ) ‚Üí
           (toDiffList t‚ÇÅ) lst ‚â° (toDiffList t‚ÇÇ) lst
  lemjl- (leaf l<u) (leaf l<u‚ÇÅ) x‚ÇÇ x‚ÇÉ lst = P.refl
  lemjl- (leaf l<u) (node k‚ÇÅ t‚ÇÇ t‚ÇÉ bal) x‚ÇÇ x‚ÇÉ lst = contradiction (x‚ÇÉ here) (Œª ())
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (leaf l<u) x‚ÇÇ x‚ÇÉ lst = contradiction (x‚ÇÇ here) (Œª ())
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) x‚ÇÇ x‚ÇÉ lst with compare (proj‚ÇÅ k‚ÇÅ) (proj‚ÇÅ k‚ÇÇ)
  lemjl- (node ( k‚ÇÅ , v‚ÇÅ ) t‚ÇÅ t‚ÇÇ bal) (node ( k‚ÇÇ , v‚ÇÇ ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ) kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ lst | tri‚âà k‚ÇÅ‚âÆk‚ÇÇ k‚ÇÅ‚â°k‚ÇÇ k‚ÇÇ‚âÆk‚ÇÅ rewrite
         k‚ÇÅ‚â°k‚ÇÇ -- |
         -- ‚ààÃÉ‚Üív1‚â°v2 (kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ here) |
         -- | ‚ààÃÉ‚Üív2‚â°v1 (kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ here)
         -- lemjl- t‚ÇÇ t‚ÇÑ (t2‚Üít4 kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ) {!!} lst -- (t2‚Üít4 kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ) -- subst (‚ààÃÉ‚Üív1‚â°v2 (kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ here)) kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ
         = {!!} -- lemjl- t‚ÇÅ t‚ÇÉ {!!} {!!} ((k‚ÇÇ , v‚ÇÇ) L.‚à∑ toDiffList t‚ÇÑ lst)
  -- (kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ here) -- k‚ÇÇ ‚àº v‚ÇÅ ‚ààÃÉ node (k‚ÇÇ , v‚ÇÇ) t‚ÇÉ t‚ÇÑ bal‚ÇÅ
  -- (kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ here) -- k‚ÇÇ ‚àº v‚ÇÇ ‚ààÃÉ node (k‚ÇÇ , v‚ÇÅ) t‚ÇÅ t‚ÇÇ bal
  -- k‚Üív' (kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ here) (kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ here)

-- {-k‚Üív'-}  {! (lemjl- t‚ÇÇ t‚ÇÑ (? kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ) (? kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ) lst)!}
  -- subst {!!} (lemjl- t‚ÇÇ t‚ÇÑ ({!!} kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ) ({!!} kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ) lst) {!!} where
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ lst | tri< k‚ÇÅ<k‚ÇÇ k‚ÇÅ‚â¢k‚ÇÇ k‚ÇÇ‚âÆk‚ÇÅ = {!!}
  lemjl- (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) kv‚ààÃåt‚ÇÅ‚Üíkv‚ààÃåt‚ÇÇ kv‚ààÃåt‚ÇÇ‚Üíkv‚ààÃåt‚ÇÅ lst | tri> k‚ÇÅ‚âÆk‚ÇÇ k‚ÇÅ‚â¢k‚ÇÇ k‚ÇÇ<k‚ÇÅ = {!!}
-}
  
  lemjl+ : ‚àÄ { k‚Éñ‚ÇÅ k‚Éó‚ÇÅ h‚ÇÅ k‚Éñ‚ÇÇ k‚Éó‚ÇÇ h‚ÇÇ } ‚Üí
           ( t‚ÇÅ : Tree k‚Éñ‚ÇÅ k‚Éó‚ÇÅ h‚ÇÅ )
           ( t‚ÇÇ : Tree k‚Éñ‚ÇÇ k‚Éó‚ÇÇ h‚ÇÇ )
           ( _ : ‚àÄ {kv} ‚Üí proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ t‚ÇÅ ‚Üí proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ t‚ÇÇ )
           ( _ : ‚àÄ {kv} ‚Üí proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ t‚ÇÇ ‚Üí proj‚ÇÅ kv ‚àº proj‚ÇÇ kv ‚ààÃÉ t‚ÇÅ ) ‚Üí
           (toDiffList t‚ÇÅ) L.[] ‚âÖ (toDiffList t‚ÇÇ) L.[]
  lemjl+ (leaf l<u) (leaf l<u‚ÇÅ) x‚ÇÇ x‚ÇÉ = H.refl
  lemjl+ (leaf l<u) (node k‚ÇÅ t‚ÇÇ t‚ÇÉ bal) x‚ÇÇ x‚ÇÉ = contradiction (x‚ÇÉ here) (Œª ())
  lemjl+ (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (leaf l<u) x‚ÇÇ x‚ÇÉ = contradiction (x‚ÇÇ here) (Œª ())
  lemjl+ (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) x‚ÇÇ x‚ÇÉ with compare (proj‚ÇÅ k‚ÇÅ) (proj‚ÇÅ k‚ÇÇ)
  lemjl+ (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) x‚ÇÇ x‚ÇÉ | tri< a ¬¨b ¬¨c = {!!}
  lemjl+ (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) x‚ÇÇ x‚ÇÉ | tri‚âà ¬¨a b ¬¨c = {!!}
  lemjl+ (node k‚ÇÅ t‚ÇÅ t‚ÇÇ bal) (node k‚ÇÇ t‚ÇÉ t‚ÇÑ bal‚ÇÅ) x‚ÇÇ x‚ÇÉ | tri> ¬¨a ¬¨b c = {!!}

  joinÀ°‚Å∫! : ‚àÄ {l u hÀ° h ≥ h} ‚Üí
            (k : KV) ‚Üí
            (tl+ : (‚àÉ Œª i ‚Üí Tree l [ proj‚ÇÅ k ] (i ‚äï hÀ°))) ‚Üí
            (tr : Tree [ proj‚ÇÅ k ] u h ≥) ‚Üí
            (bal : hÀ° ‚àº h ≥ ‚äî h) ‚Üí
            ‚àÉ Œª i ‚Üí ‚àÉ! _‚â°_ Œª (t : Tree l u (i ‚äï (1 + h))) ‚Üí
            (‚àÄ (k' : Key) (v' : Value k') ‚Üí
            (  (k' ‚àº v' ‚ààÃÉ proj‚ÇÇ tl+ ‚Üí k' ‚àº v' ‚ààÃÉ t)
             √ó (k' ‚àº v' ‚ààÃÉ tr ‚Üí k' ‚àº v' ‚ààÃÉ t)
             √ó (k' ‚àº v' ‚ààÃÉ t ‚Üí (k' ‚àº v' ‚ààÃÉ proj‚ÇÇ tl+) ‚äé (k' ‚àº v' ‚ààÃÉ tr) ‚äé (k' , v' ‚â° k) )
             √ó (proj‚ÇÅ k ‚àº proj‚ÇÇ k ‚ààÃÉ t)
             ))
  joinÀ°‚Å∫! k‚ÇÜ (1# , node k‚ÇÇ t‚ÇÅ
                    (node k‚ÇÑ t‚ÇÉ t‚ÇÖ bal)
                                ‚àº+) t‚Çá ‚àº-  = 0# , node k‚ÇÑ
                                                        (node k‚ÇÇ t‚ÇÅ t‚ÇÉ (max‚àº bal))
                                                        (node k‚ÇÜ t‚ÇÖ t‚Çá (‚àºmax bal))
                                                        ‚àº0 , (Œª k' v' ‚Üí proof , (Œª x ‚Üí right (right x)) , proof2 , right here) , (Œª x ‚Üí {!!})
             where
    proof : ‚àÄ {k' k‚ÇÇ t‚ÇÅl t‚ÇÅh k‚ÇÑ t‚ÇÉh k‚ÇÜ t‚ÇÖh t‚Çáu bal}
              {v' : Value k'}
              {t‚ÇÅ : Tree t‚ÇÅl [ proj‚ÇÅ k‚ÇÇ ] t‚ÇÅh}
              {t‚ÇÉ : Tree [ proj‚ÇÅ k‚ÇÇ ] [ proj‚ÇÅ k‚ÇÑ ] t‚ÇÉh}
              {t‚ÇÖ : Tree [ proj‚ÇÅ k‚ÇÑ ] [ proj‚ÇÅ k‚ÇÜ ] t‚ÇÖh}
              {t‚Çá : Tree [ proj‚ÇÅ k‚ÇÜ ] t‚Çáu t‚ÇÅh}  ‚Üí
              k' ‚àº v' ‚ààÃÉ node k‚ÇÇ t‚ÇÅ (node k‚ÇÑ t‚ÇÉ t‚ÇÖ bal) ‚àº+ ‚Üí
              k' ‚àº v' ‚ààÃÉ node k‚ÇÑ (node k‚ÇÇ t‚ÇÅ t‚ÇÉ (max‚àº bal)) (node k‚ÇÜ t‚ÇÖ t‚Çá (‚àºmax bal)) ‚àº0
    proof here = left here
    proof (left x) = left (left x)
    proof (right here) = here
    proof (right (left x)) = left (right x)
    proof (right (right x)) = right (left x)

    proof2 : ‚àÄ {k' k‚ÇÇ t‚ÇÅl t‚ÇÅh k‚ÇÑ t‚ÇÉh k‚ÇÜ t‚ÇÖh t‚Çáu bal}
              {v' : Value k'}
              {t‚ÇÅ : Tree t‚ÇÅl [ proj‚ÇÅ k‚ÇÇ ] t‚ÇÅh}
              {t‚ÇÉ : Tree [ proj‚ÇÅ k‚ÇÇ ] [ proj‚ÇÅ k‚ÇÑ ] t‚ÇÉh}
              {t‚ÇÖ : Tree [ proj‚ÇÅ k‚ÇÑ ] [ proj‚ÇÅ k‚ÇÜ ] t‚ÇÖh}
              {t‚Çá : Tree [ proj‚ÇÅ k‚ÇÜ ] t‚Çáu t‚ÇÅh}  ‚Üí
             k' ‚àº v' ‚ààÃÉ node k‚ÇÑ (node k‚ÇÇ t‚ÇÅ t‚ÇÉ (max‚àº bal)) (node k‚ÇÜ t‚ÇÖ t‚Çá (‚àºmax bal)) ‚àº0 ‚Üí
             k' ‚àº v' ‚ààÃÉ node k‚ÇÇ t‚ÇÅ (node k‚ÇÑ t‚ÇÉ t‚ÇÖ bal) ‚àº+ ‚äé k' ‚àº v' ‚ààÃÉ t‚Çá ‚äé (k' , v' ‚â° k‚ÇÜ)
    proof2 here = inj‚ÇÅ (right here)
    proof2 (left here) = inj‚ÇÅ here
    proof2 (left (left x)) = inj‚ÇÅ (left x)
    proof2 (left (right x)) = inj‚ÇÅ (right (left x))
    proof2 (right here) = inj‚ÇÇ (inj‚ÇÇ P.refl)
    proof2 (right (left x)) = inj‚ÇÅ (right (right x))
    proof2 (right (right x)) = inj‚ÇÇ (inj‚ÇÅ x)
    
  joinÀ°‚Å∫! k‚ÇÑ (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº-) t‚ÇÖ ‚àº-  = 0# , node k‚ÇÇ t‚ÇÅ (node k‚ÇÑ t‚ÇÉ t‚ÇÖ ‚àº0) ‚àº0 , {!!}
  joinÀ°‚Å∫! k‚ÇÑ (1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0) t‚ÇÖ ‚àº-  = 1# , node k‚ÇÇ t‚ÇÅ (node k‚ÇÑ t‚ÇÉ t‚ÇÖ ‚àº-) ‚àº+ , {!!}
  joinÀ°‚Å∫! k‚ÇÇ (1# , t‚ÇÅ)               t‚ÇÉ ‚àº0  = 1# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº- , {!!}
  joinÀ°‚Å∫! k‚ÇÇ (1# , t‚ÇÅ)               t‚ÇÉ ‚àº+  = 0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ ‚àº0 , {!!}
  joinÀ°‚Å∫! k‚ÇÇ (0# , t‚ÇÅ)               t‚ÇÉ bal = 0# , node k‚ÇÇ t‚ÇÅ t‚ÇÉ bal , {!!}

------------------------------------------------------------------------
-- Types and functions with hidden indices

data Tree : Set (ùëº‚ü®Key‚ü© ‚äî ùëº‚ü®Value‚ü© ‚äî ùëº‚ü®<‚ü©) where
  tree : let open Extended-key in
         ‚àÄ {h} ‚Üí Indexed.Tree ‚ä•‚Å∫ ‚ä§‚Å∫ h ‚Üí Tree

empty : Tree
empty = tree (Indexed.empty _)

singleton : (k : Key) ‚Üí Value k ‚Üí Tree
singleton k v = tree (Indexed.singleton k v _)

insert : (k : Key) ‚Üí Value k ‚Üí Tree ‚Üí Tree
insert k v (tree t) = tree $ proj‚ÇÇ $ Indexed.insert k v t _

insertWith : (k : Key) ‚Üí Value k ‚Üí (Value k ‚Üí Value k ‚Üí Value k) ‚Üí
             Tree ‚Üí Tree
insertWith k v f (tree t) = tree $ proj‚ÇÇ $ Indexed.insertWith k v f t _

delete : Key ‚Üí Tree ‚Üí Tree
delete k (tree t) = tree $ proj‚ÇÇ $ Indexed.delete k t

lookup : (k : Key) ‚Üí Tree ‚Üí Maybe (Value k)
lookup k (tree t) = Indexed.lookup k t

map : ({k : Key} ‚Üí Value k ‚Üí Value k) ‚Üí Tree ‚Üí Tree
map f (tree t) = tree $ Indexed.map f t

infix 4 _‚àà?_

_‚àà?_ : Key ‚Üí Tree ‚Üí Bool
k ‚àà? t = is-just (lookup k t)

headTail : Tree ‚Üí Maybe (KV √ó Tree)
headTail (tree (Indexed.leaf _)) = nothing
headTail (tree {h = suc _} t)    with Indexed.headTail t
... | (k , _ , _ , t‚Ä≤) = just (k , tree (Indexed.castÀ° _ t‚Ä≤))

initLast : Tree ‚Üí Maybe (Tree √ó KV)
initLast (tree (Indexed.leaf _)) = nothing
initLast (tree {h = suc _} t)    with Indexed.initLast t
... | (k , _ , _ , t‚Ä≤) = just (tree (Indexed.cast ≥ t‚Ä≤ _) , k)

-- The input does not need to be ordered.

fromList : List KV ‚Üí Tree
fromList = List.foldr (uncurry insert) empty

-- Returns an ordered list.

toList : Tree ‚Üí List KV
toList (tree t) = DiffList.toList (Indexed.toDiffList t)

-- Naive implementations of union.

unionWith : (‚àÄ {k} ‚Üí Value k ‚Üí Value k ‚Üí Value k) ‚Üí
            -- Left ‚Üí right ‚Üí result.
            Tree ‚Üí Tree ‚Üí Tree
unionWith f t‚ÇÅ t‚ÇÇ =
  List.foldr (Œª { (k , v) ‚Üí insertWith k v f }) t‚ÇÇ (toList t‚ÇÅ)

-- Left-biased.

union : Tree ‚Üí Tree ‚Üí Tree
union = unionWith const

unionsWith : (‚àÄ {k} ‚Üí Value k ‚Üí Value k ‚Üí Value k) ‚Üí List Tree ‚Üí Tree
unionsWith f ts = List.foldr (unionWith f) empty ts

-- Left-biased.

unions : List Tree ‚Üí Tree
unions = unionsWith const

