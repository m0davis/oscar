sketch of (load "loader")

loader
  oscar
    tool
    syntax
      setf *constant-transformation*
      setf *bracket-transformation*
    hypergraph
  reason
  rule
    setf simp
      ?
    setf (reason-function simp)
      ?
    ...
    setf *forwards-logical-reasons*
      ?
    setf adjunction
    set-conclusions-function adjunction
      ?
    setf (reason-function adjunction)
    ...
    def-backwards-reason VACUOUS-CONDITION
      ?
    ...
    setf *backwards-logical-reasons*
  argument
  problem
  problem-example
    setf *problems*
  perception-cause
    setf *pretty-list*
    setf *string-symbols*
    setf *temporal-reason-decay*
    setf *reform-list*
    setf (get 'i 'pretty-form)
    def-forwards-reason *PERCEPTION*
      ?
    def-backwards-undercutter *PERCEPTUAL-RELIABILITY*
    def-forwards-reason *DISCOUNTED-PERCEPTION*
    def-backwards-undercutter *PERCEPTUAL-UNRELIABILITY*
    setf *binary-predicates*
    def-backwards-undercutter *PROBABILISTIC-DEFEAT-FOR-TEMPORAL-PROJECTION*
    def-backwards-reason *INCOMPATIBLE-COLORS*
    ...
  perception-cause-example
    setf *simulation-problems*
    make-simulation-problem
    ...

--

sketch of (test)

test
  run-reasoning-problem
    display-problem
      setf *premises*
      setf *fixed-ultimate-epistemic-interests*
      setf *ultimate-epistemic-interests*
      setf *query-number*
      push ... *fixed-ultimate-epistemic-interests*
      setf *forwards-substantive-reasons*
      setf *backwards-substantive-reasons*
      display-reasons
        display-forwards-reason
          print-premise
        display-backwards-reason
    COGITATE
      setf *cycle*
      setf time
      initialize-reasoner
        setf ...
          ?
        initialize-discrimination-net
          setf ...
            ?
          compute-forwards-reason-d-nodes
            store-forwards-reason
              index-forwards-reason
                index-forwards-reason-at-new-nodes
                  push ... (d-node-discrimination-tests ...)
                  push ... *discrimination-net*
                store-forwards-reason-at-new-d-node
              store-forwards-reason-at-d-node
                push ... (d-node-forwards-reasons ...
                setf (ip-d-node ...)
            setf ...
          compute-backwards-reason-d-nodes
            store-backwards-reason
              index-backwards-reason
                store-backwards-reason-at-d-node
                  push ... (d-node-degenerate-backwards-reasons ...)
                  push ... (d-node-backwards-reasons ...)
                  push ... (d-node-degenerate-backwards-reasons ...)
                index-backwards-reason-at-new-nodes
                  push ... (d-node-discrimination-tests ...)
                  push ... *discrimination-net*
                  store-backwards-reason-at-new-d-node
                store-backwards-reason-at-new-d-node
              store-backwards-reason-at-d-node
      reason-backwards-from-query → one-one-match
        reason-backwards-from-whether-query
        reason-backwards-from-?-query
        reason-backwards-from-simple-query
      incf *cycle*
      pull ... *premises*
      queue-premise
        adopt-interest-in-premise-defeater → one-one-match
          interests-for
          store-interest
            push ... *interests*
            index-interest
              store-interest-at-d-node
              index-interest-at-new-nodes
                push ... *discrimination-net*
              store-interest-at-new-d-node
                push ... *discrimination-net*
          display-interest
          push ... *reasoning-log*
          queue-interest
            setf *inference-queue*
          readopt-interest
        push ... *hypergraph*
        push ... *reasoning-log*
        display-unsupported-hypernode
        store-hypernode
          index-hypernode
            store-hypernode-at-d-node
            index-hypernode-at-new-nodes
            store-hypernode-at-new-d-node
              push ... *discrimination-net*
        discharge-interest-in
          discharge-appropriately-related-link
            display-belief-changes
              push ... *reasoning-log*
            construct-interest-link
              draw-conclusion
              push ... *interest-links*
              compute-link-interest → one-one-match
              discharge-link
                display-belief-changes
                construct-interest-link
                draw-conclusion
                cancel-interest-in
                  cancel-interest-in-node
                    setf *skolem-free-suppositions*
                    remove-if-equal ... *skolem-free-suppositions*
                    pull ... *inherited-non-reductio-suppositions*
                    pull ... *non-reductio-supposition-nodes*
                    pull ... *reductio-supposition-nodes*
                    pull ... *desires*
                    pull ... *processed-desires*
                    cancel-interest-scheme
                      cancel-d-node
                    cancel-instantiated-premise
                      cancel-d-node
                    pull ... *inference-queue*
                cancel-node
              apply-degenerate-backwards-reasons
                reason-degenerately-backwards-from-dominant-reason-nodes
                  reason-degenerately-backwards-from-reason-node
                    reason-substantively-from-backwards-reason
            draw-conclusion
              decf *hyperlink-number*
              push ... *hypergraph*
              discharge-interest-in-defeaters
                recursively-compute-nearest-defeasible-ancestors
                  ?
                recursively-compute-hypernode-ancestors
                  ?
              adopt-interest-in-defeaters-for
                ?
              push ... *new-links*
              ...
              cancel-subsumed-links
          cancel-node
            ?
        setf *inference-queue*
          ordered-insert
            ?
      think-or-die
        display-inference-queue
          ?
        setf *inference-queue*
        store-processed-node
        reason-forwards-from
          decf *unused-suppositions*
          discharge-interest-schemes
          apply-forwards-reasons
          discharge-interest-in
          adopt-reductio-interest
          discharge-delayed-reductios
        reason-backwards-from-query
          ?
        form-epistemic-desires-for
          ?
        update-beliefs
          ?
        setf *new-links*
      setf time
      setf *deductive-only*
      display-queries
        ?
      display-run-time-in-seconds
      compute-relevant-nodes
        ?
      show-arguments
        ?
      print-list
        ?
      push ... *test-log*
      display-reasoning
        ?
    display-hypergraph

--

interesting

defun initialize-reasoner

make-backwards-inference is defined twice

--

callees

one-one-match
  i-list-for
    interests-for
      in-interest
      adopt-interest-in-premise-defeater
      reason-backwards-from-whether-query
      reason-backwards-from-simple-query
        reason-backwards-from-query
          OSCAR
          think
          COGITATE0
          COGITATE
          think-or-die
      condition-satisfying-interest
      adopt-interest
    construct-initial-interest-link
      make-backwards-inference
      make-forwards-inference
      instantiate-defeater
    interest-for
      compute-link-interest
      generate-reductio-interests
      make-undercutting-defeater
      make-rebutting-defeater

--

mutual dependencies

construct-initial-interest-link
queue-supposition
queue-non-reductio-supposition

construct-interest-scheme
queue-supposition
apply-forwards-defeasible-reasons

convert-reductio-supposition
apply-forwards-defeasible-reasons

queue-defeater-supposition
apply-forwards-defeasible-reasons

apply-forwards-defeasible-reasons
reason-defeasibly-from-dominant-premise-nodes
reason-defeasibly-from-instantiated-premises
reason-substantively-from-first-instantiated-premise
reason-from-subsidiary-c-lists
reason-substantively-from-non-initial-instantiated-premise
store-instantiated-premise
make-forwards-inference
*DRAW-CONCLUSION
*cancel-subsumed-links
*delete-arguments
*recursively-compute-nearest-defeasible-ancestors
*invert-contradictions-retrospectively
*invert-contradiction
*DRAW-CONCLUSION
adopt-interest-in-defeaters-for
queue-defeater-supposition
queue-non-reductio-defeater-supposition

make-undercutting-defeater
instantiate-defeater

invert-contradictions-from-new-hyperlink
build-hyperlink
*recursively-compute-nearest-defeasible-ancestors

discharge-reductios
draw-reductio-conclusion

discharge-immediate-reductios
draw-reductio-conclusion

reason-from-current-interest-scheme
reason-from-dominant-interest-schemes
discharge-interest-schemes
discharge-interest-in-defeaters
discharge-appropriately-related-link
DISCHARGE-INTEREST-IN
invert-contradictions
discharge-fortuitous-reductios
adjust-support-for-consequences
add-hyperlink
make-rebutting-defeater
construct-interest-link
DISCHARGE-LINK
reason-substantively-from-backwards-reason
reason-degenerately-backwards-from-reason-node
reason-degenerately-backwards-from-dominant-reason-nodes
apply-degenerate-backwards-reasons
make-backwards-inference

reason-from-interest-scheme
discharge-interest-scheme

--

compute-hypernode-justification
compute-link-justification
compute-hyper-defeat-link-justification

--

callers of 'match'

set-match
 subsumed
 cancel-subsumed-links
pretty
convert-to-prefix-form
search-d-nodes
instance-of
one-one-match
 i-list-for
  interests-for
  interest-for
  construct-initial-interest-link
subsumed
 DRAW-CONCLUSION
 draw-reductio-conclusion
subsuming-supposition
cancel-subsumed-links
make-forwards-inference
make-reductio-supposition
EI

--

theorizing about set-match


(defun set-match (patterns data vars)
  (catch 'match
    (let ((matches nil)
	  (open nil)
	  (closed nil))
      (dolist (P patterns)
	(if (some #'(lambda (v) (occur v P)) vars)
	    (push P open)
	  (if (mem P data)
	      (push P closed)
	    (throw 'match nil))))
      (cond (open
	     (let ((P (mem1 open)))
	       (dolist (Q data)
		 (let ((m (match P Q vars)))
		   (when m
		     (dolist (sm (set-match
				  (match-sublis m (cdr open))
				  data
				  (setdifference vars (match-domain m))))
		       (push (list (adjoin= Q (union= closed (mem1 sm)))
				   (merge-matches m (mem2 sm)))
			     matches)))))))
	    (t (setf matches (list (list closed T)))))
      (when (null matches) (throw 'match nil))
      (princ matches) (terpri)
      matches)))

set-match ∷ Patterns → Formulas → Symbols → List (Formulas × Map Symbol Pattern)
set-match [] _ _ = [ [] , ∅ ]
set-match _ [] _ = []
set-match pats@(_ ∷ _) dats@(_ ∷ _) []
 with pats ⊂? dats
... |  no _ = []
... | yes _ = [ pats , ∅ ]
set-match pats@(_ ∷ _) dats@(_ ∷ _) vars@(_ ∷ _) =
  let open-pats = pats havingFreeVarsIn vars
      closed-pats = pats - open
  in
  if closed-pats ⊂ dats then
    let open-pat ∷ open-pats = open-pats in
    foldl
      λ { matches dat →
        case match open-pat dat vars of λ where
        ∅ → matches
        open-pat-match →
          foldl
            λ { matches (sm-closeds , sm-matches) →
              (sm-closeds ∪ closed-pats ∪ [ dat ] , sm-matches ∪ open-pat-match) ∷ matches }
            matches
            (set-match (substitute open-pat-match open-pats) data (vars - domain open-pat-match)) }
      []
      dats
  else
    []



(set-match
  '((f x)
    (g y))
  '((f A)
    (f B)
    (g A)
    (g B))
  '(x y))

(set-match
  '((f x y)
    (g x y)
    (h x y z)
    (h x z)
    (h x z)
    (j x z)
    (f y x))
  '((f A A)
    (g A A)
    (h A A B)
    (h A B)
    (h A A)
    (j A B)
    (h A B)
    (i A w))
  '(x x y y z z w w))

(set-match
  '((f x y)
    (g x y)
    (f x x)
    (g y y))
  '((f A B)
    (g A B))
  '(x y))
(set-match
  '((SUBSET ^@y46 (INT (INV F c18 c0) (INV F c19 c0)))
    (SUBSET (INT (INV F c18 c0) (INV F c19 c0)) (INV F (INT c18 c19) c0))
    (SUBSET ^@y41 (INT (INV F c18 c0) (INV F c19 c0)))
    (~ (EQUAL (INV F (INT c18 c19) c0) (INT (INV F c18 c0) (INV F c19 c0))))
    (SUBSET (INV F (INT c18 c19) c0) ^@y41))

  '((SUBSET (INV F (INT c18 c19) c0) ^@y41)
    (SUBSET ^@y41 (INT (INV F c18 c0) (INV F c19 c0)))
    (~ (EQUAL (INV F (INT c18 c19) c0) (INT (INV F c18 c0) (INV F c19 c0))))
    (SUBSET (INT (INV F c18 c0) (INV F c19 c0)) (INV F (INT c18 c19) c0)))
  '(^@y41 ^@y46))

((SUBSET ^@y46 (INT (INV F c18 c0) (INV F c19 c0)))
 (SUBSET (INT (INV F c18 c0) (INV F c19 c0)) (INV F (INT c18 c19) c0))
 (SUBSET ^@y41 (INT (INV F c18 c0) (INV F c19 c0)))
 (~ (EQUAL (INV F (INT c18 c19) c0) (INT (INV F c18 c0) (INV F c19 c0))))
 (SUBSET (INV F (INT c18 c19) c0) ^@y41))

((SUBSET (INV F (INT c18 c19) c0) ^@y41)
 (SUBSET ^@y41 (INT (INV F c18 c0) (INV F c19 c0)))
 (~ (EQUAL (INV F (INT c18 c19) c0) (INT (INV F c18 c0) (INV F c19 c0))))
 (SUBSET (INT (INV F c18 c0) (INV F c19 c0)) (INV F (INT c18 c19) c0)))
(^@y41 ^@y46)
((((SUBSET (INV F (INT c18 c19) c0) ^@y41)
   (SUBSET (INT (INV F c18 c0) (INV F c19 c0)) (INV F (INT c18 c19) c0))
   (~ (EQUAL (INV F (INT c18 c19) c0) (INT (INV F c18 c0) (INV F c19 c0))))
   (SUBSET ^@y41 (INT (INV F c18 c0) (INV F c19 c0))))
  ((^@y41 . ^@y41) (^@y46 . ^@y41))))

--

stuff that uses eval

conclusion-instantiator
 define-forwards-reason
  find-forwards-con-reasons
   make-problem-from-string
  find-forwards-pf-reasons
 define-backwards-reason
 set-conclusions-function

rectify-formula-condition
 formula-condition
  rectify-forwards-premises
   def-forwards-reason
    *open code
    define-forwards-reason
     find-forwards-con-reasons
      make-problem-from-string
       make-problem-list
        default-problem-list
	 *open code
     find-forwards-pf-reasons
      make-problem-from-string
       ...
   def-backwards-reason
    *open code
   def-forwards-undercutter
    *open code
   def-backwards-undercutter
    *open code
  rectify-backwards-premises
 rectify-strength
 simple-backwards-formula-condition
 rectify-reason-condition

reason-instantiator
 construct-forwards-premise

def-instantiator
 reason-instantiator
  ...
find-backwards-con-reasons
find-backwards-pf-reasons
find-forwards-con-reasons
find-forwards-pf-reasons
rectify-forwards-premises*
define-backwards-reason
make-simulation-problem
make-planning-problem
P-TEST
term-count
default-term-value
factor-difference
combine-exponents0
