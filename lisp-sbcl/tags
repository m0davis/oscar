!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
&-at-elimination	perception-cause.lisp	/^(def-forwards-reason &-at-elimination$/;"	f
&-at-intro	perception-cause.lisp	/^(def-backwards-reason &-at-intro$/;"	f
**percepts**	perception-cause.lisp	/^(defvar **percepts** nil)$/;"	f
*CAUSAL-IMPLICATION*	perception-cause.lisp	/^(def-backwards-reason *CAUSAL-IMPLICATION*$/;"	f
*CAUSAL-IMPLICATION+*	perception-cause.lisp	/^(def-backwards-reason *CAUSAL-IMPLICATION+*$/;"	f
*CAUSAL-IMPLICATION-*	perception-cause.lisp	/^(def-backwards-reason *CAUSAL-IMPLICATION-*$/;"	f
*CAUSAL-IMPLICATION2*	perception-cause.lisp	/^(def-backwards-reason *CAUSAL-IMPLICATION2*$/;"	f
*CAUSAL-UNDERCUTTER*	perception-cause.lisp	/^(def-backwards-undercutter *CAUSAL-UNDERCUTTER*$/;"	f
*CAUSAL-UNDERCUTTER+*	perception-cause.lisp	/^(def-backwards-undercutter *CAUSAL-UNDERCUTTER+*$/;"	f
*CAUSAL-UNDERCUTTER-FOR-CAUSAL-IMPLICATION*	perception-cause.lisp	/^(def-backwards-undercutter *CAUSAL-UNDERCUTTER-FOR-CAUSAL-IMPLICATION*$/;"	f
*COLLISION*	perception-cause.lisp	/^(def-backwards-reason *COLLISION*$/;"	f
*DISCOUNTED-INDEXICAL-PERCEPTION*	perception-cause.lisp	/^(def-forwards-reason *DISCOUNTED-INDEXICAL-PERCEPTION*$/;"	f
*DISCOUNTED-PERCEPTION*	perception-cause.lisp	/^(def-forwards-reason *DISCOUNTED-PERCEPTION*$/;"	f
*EI-adjustment*	loader.lisp	/^(defvar *EI-adjustment* 2.5)$/;"	f
*EI-adjustment*	oscar.lisp	/^(defvar *EI-adjustment* 2.5)$/;"	f
*INCOMPATIBLE-COLORS*	perception-cause.lisp	/^(def-backwards-reason *INCOMPATIBLE-COLORS*$/;"	f
*INDEXICAL-CAUSAL-IMPLICATION*	perception-cause.lisp	/^(def-backwards-reason *INDEXICAL-CAUSAL-IMPLICATION*$/;"	f
*INDEXICAL-CAUSAL-UNDERCUTTER*	perception-cause.lisp	/^(def-backwards-undercutter *INDEXICAL-CAUSAL-UNDERCUTTER*$/;"	f
*INDEXICAL-CAUSAL-UNDERCUTTER+*	perception-cause.lisp	/^(def-backwards-undercutter *INDEXICAL-CAUSAL-UNDERCUTTER+*$/;"	f
*INDEXICAL-CAUSAL-UNDERCUTTER-FOR-CAUSAL-IMPLICATION*	perception-cause.lisp	/^(def-backwards-undercutter *INDEXICAL-CAUSAL-UNDERCUTTER-FOR-CAUSAL-IMPLICATION*$/;"	f
*INDEXICAL-INCOMPATIBLE-COLORS*	perception-cause.lisp	/^(def-backwards-reason *INDEXICAL-INCOMPATIBLE-COLORS*$/;"	f
*INDEXICAL-PERCEPTION*	perception-cause.lisp	/^(def-forwards-reason *INDEXICAL-PERCEPTION*$/;"	f
*INDEXICAL-PERCEPTUAL-RELIABILITY*	perception-cause.lisp	/^(def-backwards-undercutter *INDEXICAL-PERCEPTUAL-RELIABILITY*$/;"	f
*INDEXICAL-PERCEPTUAL-UNRELIABILITY*	perception-cause.lisp	/^(def-backwards-undercutter *INDEXICAL-PERCEPTUAL-UNRELIABILITY*$/;"	f
*INDEXICAL-TEMPORAL-PROJECTION*	perception-cause.lisp	/^(def-backwards-reason *INDEXICAL-TEMPORAL-PROJECTION*$/;"	f
*NEW-POSITION*	perception-cause.lisp	/^(def-backwards-reason *NEW-POSITION*$/;"	f
*NEW-POSITION-*	perception-cause.lisp	/^(def-backwards-reason *NEW-POSITION-*$/;"	f
*PERCEPTION*	perception-cause.lisp	/^(def-forwards-reason *PERCEPTION*$/;"	f
*PERCEPTUAL-RELIABILITY*	perception-cause.lisp	/^(def-backwards-undercutter *PERCEPTUAL-RELIABILITY*$/;"	f
*PERCEPTUAL-UNRELIABILITY*	perception-cause.lisp	/^(def-backwards-undercutter *PERCEPTUAL-UNRELIABILITY*$/;"	f
*POSITION-INCOMPATIBILITY*	perception-cause.lisp	/^(def-backwards-reason *POSITION-INCOMPATIBILITY*$/;"	f
*POSITION-INCOMPATIBILITY*	perception-cause.lisp	/^(def-forwards-reason *POSITION-INCOMPATIBILITY*$/;"	f
*POSITION-INCOMPATIBILITY-1*	perception-cause.lisp	/^(def-backwards-reason *POSITION-INCOMPATIBILITY-1*$/;"	f
*POSITION-INCOMPATIBILITY-2*	perception-cause.lisp	/^(def-backwards-reason *POSITION-INCOMPATIBILITY-2*$/;"	f
*PROBABILISTIC-DEFEAT-FOR-INDEXICAL-PERCEPTION*	perception-cause.lisp	/^(def-backwards-undercutter *PROBABILISTIC-DEFEAT-FOR-INDEXICAL-PERCEPTION*$/;"	f
*PROBABILISTIC-DEFEAT-FOR-INDEXICAL-TEMPORAL-PROJECTION*	perception-cause.lisp	/^(def-backwards-undercutter *PROBABILISTIC-DEFEAT-FOR-INDEXICAL-TEMPORAL-PROJECTION*$/;"	f
*PROBABILISTIC-DEFEAT-FOR-TEMPORAL-PROJECTION*	perception-cause.lisp	/^(def-backwards-undercutter *PROBABILISTIC-DEFEAT-FOR-TEMPORAL-PROJECTION*$/;"	f
*RELIABLE-INFORMANT*	perception-cause.lisp	/^(def-forwards-reason *RELIABLE-INFORMANT*$/;"	f
*TEMPORAL-PROJECTION*	perception-cause.lisp	/^(def-backwards-reason *TEMPORAL-PROJECTION*$/;"	f
*TEMPORAL-PROJECTION-*	perception-cause.lisp	/^(def-backwards-reason *TEMPORAL-PROJECTION-*$/;"	f
*THERMOMETER*	reason.lisp	/^(def-forwards-reason *THERMOMETER*$/;"	f
*VELOCITY-INCOMPATIBILITY-1*	perception-cause.lisp	/^(def-backwards-reason *VELOCITY-INCOMPATIBILITY-1*$/;"	f
*VELOCITY-INCOMPATIBILITY-2*	perception-cause.lisp	/^(def-backwards-reason *VELOCITY-INCOMPATIBILITY-2*$/;"	f
*affected-nodes*	loader.lisp	/^(defvar *affected-nodes* nil)$/;"	f
*answered-discount*	loader.lisp	/^(defvar *answered-discount* .5)$/;"	f
*answered-discount*	oscar.lisp	/^(defvar *answered-discount* .5)$/;"	f
*assignment-tree-dialog*	loader.lisp	/^(defvar *assignment-tree-dialog* nil)$/;"	f
*assignment-tree-subview*	loader.lisp	/^(defvar *assignment-tree-subview* nil)$/;"	f
*auxiliary-backwards-rules*	loader.lisp	/^(defvar *auxiliary-backwards-rules* nil)$/;"	f
*auxiliary-backwards-rules*	oscar.lisp	/^(defvar *auxiliary-backwards-rules* nil)$/;"	f
*auxiliary-forwards-rules*	loader.lisp	/^(defvar *auxiliary-forwards-rules* nil)$/;"	f
*auxiliary-forwards-rules*	oscar.lisp	/^(defvar *auxiliary-forwards-rules* nil)$/;"	f
*backwards-logical-reasons*	problem.lisp	/^(defvar *backwards-logical-reasons* nil)$/;"	f
*backwards-rules*	loader.lisp	/^(defvar *backwards-rules* nil)$/;"	f
*backwards-rules*	oscar.lisp	/^(defvar *backwards-rules* nil)$/;"	f
*backwards-substantive-reasons*	loader.lisp	/^(defvar *backwards-substantive-reasons* nil)$/;"	f
*backwards-substantive-reasons*	oscar.lisp	/^(defvar *backwards-substantive-reasons* nil)$/;"	f
*base-priority*	loader.lisp	/^(defvar *base-priority* .1)$/;"	f
*base-priority*	oscar.lisp	/^(defvar *base-priority* .1)$/;"	f
*blocked-conclusions*	loader.lisp	/^(defvar *blocked-conclusions* nil)$/;"	f
*blocked-conclusions*	oscar.lisp	/^(defvar *blocked-conclusions* nil)$/;"	f
*causal-implication*	loader.lisp	/^(defvar *causal-implication* nil)$/;"	f
*causal-implication*	oscar.lisp	/^(defvar *causal-implication* nil)$/;"	f
*comparison-log*	oscar.lisp	/^(defvar *comparison-log* nil)$/;"	f
*concluded-interest-priority*	loader.lisp	/^(defvar *concluded-interest-priority* .001)$/;"	f
*concluded-interest-priority*	oscar.lisp	/^(defvar *concluded-interest-priority* .001)$/;"	f
*d-trace*	loader.lisp	/^(defvar *d-trace* nil)$/;"	f
*d-trace*	oscar.lisp	/^(defvar *d-trace* nil)$/;"	f
*deductive-only*	loader.lisp	/^(defvar *deductive-only* nil)$/;"	f
*deductive-only*	oscar.lisp	/^(defvar *deductive-only* nil)$/;"	f
*display-inference-queue*	loader.lisp	/^(defvar *display-inference-queue* nil)$/;"	f
*display-inference-queue*	oscar.lisp	/^(defvar *display-inference-queue* nil)$/;"	f
*display?*	loader.lisp	/^(defvar *display?* nil)$/;"	f
*display?*	oscar.lisp	/^(defvar *display?* nil)$/;"	f
*display?*	problem.lisp	/^(defvar *display?* nil)$/;"	f
*doxastic-optative-dispositions*	loader.lisp	/^(defvar *doxastic-optative-dispositions* nil)$/;"	f
*doxastic-optative-dispositions*	oscar.lisp	/^(defvar *doxastic-optative-dispositions* nil)$/;"	f
*environmental-input*	loader.lisp	/^(defvar *environmental-input* nil)$/;"	f
*environmental-input*	oscar.lisp	/^(defvar *environmental-input* nil)$/;"	f
*executable-operations*	loader.lisp	/^(defvar *executable-operations* nil)$/;"	f
*executable-operations*	oscar.lisp	/^(defvar *executable-operations* nil)$/;"	f
*fixed-ultimate-epistemic-interests*	loader.lisp	/^(defvar *fixed-ultimate-epistemic-interests* nil)$/;"	f
*fixed-ultimate-epistemic-interests*	oscar.lisp	/^(defvar *fixed-ultimate-epistemic-interests* nil)$/;"	f
*forwards-logical-reasons*	problem.lisp	/^(defvar *forwards-logical-reasons* nil)$/;"	f
*forwards-rules*	loader.lisp	/^(defvar *forwards-rules* nil)$/;"	f
*forwards-rules*	oscar.lisp	/^(defvar *forwards-rules* nil)$/;"	f
*forwards-substantive-reasons*	loader.lisp	/^(defvar *forwards-substantive-reasons* nil)$/;"	f
*forwards-substantive-reasons*	oscar.lisp	/^(defvar *forwards-substantive-reasons* nil)$/;"	f
*graph-interests*	loader.lisp	/^(defvar *graph-interests* nil)$/;"	f
*graph-interests*	oscar.lisp	/^(defvar *graph-interests* nil)$/;"	f
*graph-log*	loader.lisp	/^(defvar *graph-log* nil)$/;"	f
*graph-log*	oscar.lisp	/^(defvar *graph-log* nil)$/;"	f
*graphics-on*	loader.lisp	/^(defvar *graphics-on* nil)$/;"	f
*graphics-on*	oscar.lisp	/^(defvar *graphics-on* nil)$/;"	f
*graphics-pause*	loader.lisp	/^(defvar *graphics-pause* nil)$/;"	f
*graphics-pause*	oscar.lisp	/^(defvar *graphics-pause* nil)$/;"	f
*hypergraphs-loaded*	oscar.lisp	/^(defvar *hypergraphs-loaded* nil)$/;"	f
*j-trace*	hypergraph.lisp	/^(defvar *j-trace* nil)$/;"	f
*log-on*	loader.lisp	/^(defvar *log-on* nil)$/;"	f
*log-on*	oscar.lisp	/^(defvar *log-on* nil)$/;"	f
*menus-loaded*	oscar.lisp	/^(defvar *menus-loaded* nil)$/;"	f
*monitor-assignment-tree*	loader.lisp	/^(defvar *monitor-assignment-tree* nil)$/;"	f
*old-definitions*	tool.lisp	/^(defvar *old-definitions* nil)$/;"	f
*operators*	syntax.lisp	/^(defvar *operators* nil)$/;"	f
*optative-dispositions*	loader.lisp	/^(defvar *optative-dispositions* nil)$/;"	f
*optative-dispositions*	oscar.lisp	/^(defvar *optative-dispositions* nil)$/;"	f
*package-name*	loader.lisp	/^(defvar *package-name* (package-name *package*))$/;"	f
*package-name*	oscar.lisp	/^(defvar *package-name* (package-name *package*))$/;"	f
*pause*	loader.lisp	/^(defvar *pause* nil)$/;"	f
*pause*	oscar.lisp	/^(defvar *pause* nil)$/;"	f
*permanent-ultimate-epistemic-interests*	loader.lisp	/^(defvar *permanent-ultimate-epistemic-interests* nil)$/;"	f
*permanent-ultimate-epistemic-interests*	oscar.lisp	/^(defvar *permanent-ultimate-epistemic-interests* nil)$/;"	f
*premises*	loader.lisp	/^(defvar *premises* nil)$/;"	f
*premises*	oscar.lisp	/^(defvar *premises* nil)$/;"	f
*priority-interests*	loader.lisp	/^(defvar *priority-interests* nil)$/;"	f
*priority-interests*	oscar.lisp	/^(defvar *priority-interests* nil)$/;"	f
*prob-compiler-loaded*	loader.lisp	/^(defvar *prob-compiler-loaded* nil)$/;"	f
*prob-compiler-loaded*	oscar.lisp	/^(defvar *prob-compiler-loaded* nil)$/;"	f
*problems-loaded*	loader.lisp	/^(defvar *problems-loaded* nil)$/;"	f
*problems-loaded*	oscar.lisp	/^(defvar *problems-loaded* nil)$/;"	f
*proofs?*	loader.lisp	/^(defvar *proofs?* nil)$/;"	f
*proofs?*	oscar.lisp	/^(defvar *proofs?* nil)$/;"	f
*proofs?*	problem.lisp	/^(defvar *proofs?* nil)$/;"	f
*quantifier-discount*	loader.lisp	/^(defvar *quantifier-discount* .95)$/;"	f
*quantifier-discount*	oscar.lisp	/^(defvar *quantifier-discount* .95)$/;"	f
*reductio-discount*	loader.lisp	/^(defvar *reductio-discount* .23)$/;"	f
*reductio-discount*	oscar.lisp	/^(defvar *reductio-discount* .23)$/;"	f
*reductio-interest*	loader.lisp	/^(defvar *reductio-interest* .23)$/;"	f
*reductio-interest*	oscar.lisp	/^(defvar *reductio-interest* .23)$/;"	f
*reform-list*	syntax.lisp	/^(defvar *reform-list* nil)$/;"	f
*s-trace*	hypergraph.lisp	/^(defvar *s-trace* nil)$/;"	f
*safe-trace*	hypergraph.lisp	/^(defvar *safe-trace* nil)$/;"	f
*skolem-multiplier*	loader.lisp	/^(defvar *skolem-multiplier* 10)$/;"	f
*skolem-multiplier*	oscar.lisp	/^(defvar *skolem-multiplier* 10)$/;"	f
*start-display*	loader.lisp	/^(defvar *start-display* nil)$/;"	f
*start-display*	oscar.lisp	/^(defvar *start-display* nil)$/;"	f
*start-trace*	loader.lisp	/^(defvar *start-trace* nil)$/;"	f
*start-trace*	oscar.lisp	/^(defvar *start-trace* nil)$/;"	f
*string-symbols*	syntax.lisp	/^(defvar *string-symbols* nil)$/;"	f
*substantive-interests*	perception-cause.lisp	/^(defvar *substantive-interests* nil)$/;"	f
*syntax-loaded*	loader.lisp	/^(defvar *syntax-loaded* nil)$/;"	f
*syntax-loaded*	oscar.lisp	/^(defvar *syntax-loaded* nil)$/;"	f
*temporal-decay*	loader.lisp	/^(defvar *temporal-decay* .9999)$/;"	f
*temporal-decay*	oscar.lisp	/^(defvar *temporal-decay* .995)$/;"	f
*temporal-decay-minimum*	loader.lisp	/^(defvar *temporal-decay-minimum* (\/ (log .5) (log *temporal-decay*)))$/;"	f
*temporal-decay-minimum*	oscar.lisp	/^(defvar *temporal-decay-minimum* (\/ (log .5) (log *temporal-decay*)))$/;"	f
*temporal-projection*	loader.lisp	/^(defvar *temporal-projection* nil)$/;"	f
*temporal-projection*	oscar.lisp	/^(defvar *temporal-projection* nil)$/;"	f
*time-limit*	loader.lisp	/^(defvar *time-limit* 5)$/;"	f
*time-limit*	oscar.lisp	/^(defvar *time-limit* 5)$/;"	f
*tools-loaded*	loader.lisp	/^(defvar *tools-loaded* nil)$/;"	f
*tools-loaded*	oscar.lisp	/^(defvar *tools-loaded* nil)$/;"	f
*tools-loaded*	tool.lisp	/^(defvar *tools-loaded* t)$/;"	f
*trace*	loader.lisp	/^(defvar *trace* nil)$/;"	f
*trace*	oscar.lisp	/^(defvar *trace* nil)$/;"	f
*trees-loaded*	loader.lisp	/^(defvar *trees-loaded* nil)$/;"	f
*trees-loaded*	oscar.lisp	/^(defvar *trees-loaded* nil)$/;"	f
*ultimate-epistemic-interests*	loader.lisp	/^(defvar *ultimate-epistemic-interests* nil)$/;"	f
*ultimate-epistemic-interests*	oscar.lisp	/^(defvar *ultimate-epistemic-interests* nil)$/;"	f
*use-logic*	loader.lisp	/^(defvar *use-logic* t)$/;"	f
*use-logic*	oscar.lisp	/^(defvar *use-logic* t)$/;"	f
*use-reductio*	loader.lisp	/^(defvar *use-reductio* t)$/;"	f
*use-reductio*	oscar.lisp	/^(defvar *use-reductio* t)$/;"	f
0-insert	tool.lisp	/^(defmacro 0-insert (F x A)$/;"	f
<<	tool.lisp	/^(defun << (x y) (< (round (* 10000 x)) (round (* 10000 y))))$/;"	f
<<=	tool.lisp	/^(defun <<= (x y)$/;"	f
==	tool.lisp	/^(defun == (x y)$/;"	f
===	tool.lisp	/^(defun === (x y &key (test 'equal))$/;"	f
=intersection	tool.lisp	/^(defun =intersection (x y) (intersection x y :test 'equal))$/;"	f
=subst	tool.lisp	/^(defun =subst (a b c)$/;"	f
><	tool.lisp	/^(defun >< (x y)$/;"	f
>>	tool.lisp	/^(defun >> (x y) (> (round (* 10000 x)) (round (* 10000 y))))$/;"	f
>>=	tool.lisp	/^(defun >>= (x y)$/;"	f
?	oscar.lisp	/^(defun ? (formula)$/;"	f
?-genp	syntax.lisp	/^(defun ?-genp (p)$/;"	f
?-matrix	oscar.lisp	/^(defun ?-matrix (p &optional vars)$/;"	f
?-positive-instruction	oscar.lisp	/^(defun ?-positive-instruction (query)$/;"	f
?-query-p	oscar.lisp	/^(defun ?-query-p (Q)$/;"	f
?-variables	oscar.lisp	/^(defun ?-variables (formula)$/;"	f
?interests	oscar.lisp	/^(defun ?interests (formula)$/;"	f
A-removal	rule.lisp	/^(defun A-removal (c depth ip)$/;"	f
ADOPT-REDUCTIO-INTEREST	oscar.lisp	/^(defun ADOPT-REDUCTIO-INTEREST (node depth d-interests)$/;"	f
COGITATE	oscar.lisp	/^(defun COGITATE ()$/;"	f
COGITATE0	oscar.lisp	/^(defun COGITATE0 ()$/;"	f
COLLISION-SYMMETRY	perception-cause.lisp	/^(def-forwards-reason COLLISION-SYMMETRY$/;"	f
DISCHARGE-INTEREST-IN	oscar.lisp	/^(defun DISCHARGE-INTEREST-IN$/;"	f
DISCHARGE-LINK	oscar.lisp	/^(defun DISCHARGE-LINK (link depth degree priority interests)$/;"	f
DISCHARGE-RETROSPECTIVE-REDUCTIOS	oscar.lisp	/^(defun DISCHARGE-RETROSPECTIVE-REDUCTIOS (node match interest depth)$/;"	f
DM	rule.lisp	/^(defun DM (c depth ip)$/;"	f
DRAW-CONCLUSION	oscar.lisp	/^(defun DRAW-CONCLUSION$/;"	f
E-removal	rule.lisp	/^(defun E-removal (c depth ip)$/;"	f
EG	rule.lisp	/^(defun EG (interest depth priority)$/;"	f
EI	rule.lisp	/^(defun EI (c depth ip)$/;"	f
ETERNAL-TRUTHS	perception-cause.lisp	/^(def-backwards-reason ETERNAL-TRUTHS$/;"	f
GREEN-SLYME	reason.lisp	/^(def-forwards-reason GREEN-SLYME$/;"	f
IQ-off	oscar.lisp	/^(defun IQ-off () (setf *display-inference-queue* nil))$/;"	f
IQ-on	oscar.lisp	/^(defun IQ-on () (setf *display-inference-queue* t))$/;"	f
MAKE-REDUCTIO-SUPPOSITION	oscar.lisp	/^(defun MAKE-REDUCTIO-SUPPOSITION (interest depth)$/;"	f
NON-ATOMIC-SUBTERMS	syntax.lisp	/^(defun NON-ATOMIC-SUBTERMS (x)$/;"	f
OSCAR	oscar.lisp	/^(defun OSCAR ()$/;"	f
PAIR-NONIDENTITY	perception-cause.lisp	/^(def-backwards-reason PAIR-NONIDENTITY$/;"	f
PAIR-NONIDENTITY-AT-TIME	perception-cause.lisp	/^(def-backwards-reason PAIR-NONIDENTITY-AT-TIME$/;"	f
PROPER-SUBTERMS	syntax.lisp	/^(defun PROPER-SUBTERMS (x)$/;"	f
R	reason.lisp	/^(def-backwards-reason R$/;"	f
SIMULATE-OSCAR	perception-cause.lisp	/^(defun SIMULATE-OSCAR (n &optional (reductio? nil))$/;"	f
SO	perception-cause.lisp	/^(defun SO (n &optional r) (simulate-oscar n r))$/;"	f
START-REDUCTIO-INTERESTS	oscar.lisp	/^(defun START-REDUCTIO-INTERESTS (node depth interests)$/;"	f
UG	rule.lisp	/^(defun UG (interest depth priority)$/;"	f
UI	rule.lisp	/^(defun UI (c depth ip)$/;"	f
VACUOUS-CONDITION	rule.lisp	/^(def-backwards-reason VACUOUS-CONDITION$/;"	f
a-range	tool.lisp	/^(defun a-range (x) (remove-duplicates (mapcar #'cdr x) :test 'equal))$/;"	f
add-hyper-defeat-link-to-critical-graph	hypergraph.lisp	/^(defun add-hyper-defeat-link-to-critical-graph (dl sigma1 sigma2 &optional (indent 0))$/;"	f
add-hyperlink	oscar.lisp	/^(defun add-hyperlink (link node depth)$/;"	f
add-link-to-critical-graph	hypergraph.lisp	/^(defun add-link-to-critical-graph (link sigma1 sigma2 &optional (indent 0))$/;"	f
add-node-to-critical-graph	hypergraph.lisp	/^(defun add-node-to-critical-graph (node sigma1 sigma2 &optional (indent 0))$/;"	f
add-relevant-nodes	oscar.lisp	/^(defun add-relevant-nodes (node)$/;"	f
add-strictly-relevant-nodes	oscar.lisp	/^(defun add-strictly-relevant-nodes (node)$/;"	f
adjoin=	tool.lisp	/^(defun adjoin= (x y) (adjoin x y :test 'equal))$/;"	f
adjunction	rule.lisp	/^(defun adjunction (interest depth priority)$/;"	f
adjust-for-decay	oscar.lisp	/^(defun adjust-for-decay (strength decay)$/;"	f
adjust-for-time	oscar.lisp	/^(defun adjust-for-time (strength node)$/;"	f
adjust-support-for-consequences	oscar.lisp	/^(defun adjust-support-for-consequences (node old-degree depth)$/;"	f
adopt-interest	oscar.lisp	/^(defun adopt-interest (S degree defeasible? binding)$/;"	f
adopt-interest-in-Q&I-defeaters-for	oscar.lisp	/^(defun adopt-interest-in-Q&I-defeaters-for (sequent)$/;"	f
adopt-interest-in-defeaters-for	oscar.lisp	/^(defun adopt-interest-in-defeaters-for (link instantiations &optional bindings)$/;"	f
adopt-interest-in-premise-defeater	oscar.lisp	/^(defun adopt-interest-in-premise-defeater (S node)$/;"	f
adopt-ultimate-interest	oscar.lisp	/^(defun adopt-ultimate-interest (query)$/;"	f
affected-items	oscar.lisp	/^(defun affected-items (new-beliefs new-retractions altered-interests altered-queries)$/;"	f
all-terms-of	syntax.lisp	/^(defun all-terms-of (p)$/;"	f
analyze-instantiated-premises	oscar.lisp	/^(defun analyze-instantiated-premises ()$/;"	f
analyze-interest-schemes	oscar.lisp	/^(defun analyze-interest-schemes ()$/;"	f
analyze-schemes	oscar.lisp	/^(defun analyze-schemes ()$/;"	f
ancestral-links	oscar.lisp	/^(defun ancestral-links (node)$/;"	f
anchor-hypernode-relative-to-interest	oscar.lisp	/^(defun anchor-hypernode-relative-to-interest (node I indent msg)$/;"	f
anchor-hypernode-relative-to-node	oscar.lisp	/^(defun anchor-hypernode-relative-to-node (node N0 indent msg)$/;"	f
anchor-interest-relative-to-interest	oscar.lisp	/^(defun anchor-interest-relative-to-interest (interest I indent msg)$/;"	f
anchor-interest-relative-to-node	oscar.lisp	/^(defun anchor-interest-relative-to-node (interest N0 indent msg)$/;"	f
answers	oscar.lisp	/^(defun answers (formula query)$/;"	f
antecedent	syntax.lisp	/^(defmacro antecedent (p)$/;"	f
applied-forwards-reason-strength	oscar.lisp	/^(defun applied-forwards-reason-strength (reason binding basis)$/;"	f
apply-Q&I-modules-to	oscar.lisp	/^(defun apply-Q&I-modules-to (conclusion)$/;"	f
apply-backwards-reasons	oscar.lisp	/^(defun apply-backwards-reasons (interest priority depth)$/;"	f
apply-degenerate-backwards-reasons	oscar.lisp	/^(defun apply-degenerate-backwards-reasons (interest priority depth)$/;"	f
apply-forwards-defeasible-reasons	oscar.lisp	/^(defun apply-forwards-defeasible-reasons (node)$/;"	f
apply-forwards-reasons	oscar.lisp	/^(defun apply-forwards-reasons (node depth)$/;"	f
apply-optative-dispositions-to	oscar.lisp	/^(defun apply-optative-dispositions-to (conclusion)$/;"	f
appropriate-for-contradictors	oscar.lisp	/^(defun appropriate-for-contradictors (formula)$/;"	f
appropriate-for-reductio-interest	oscar.lisp	/^(defun appropriate-for-reductio-interest (formula)$/;"	f
appropriate-for-reductio-supposition	oscar.lisp	/^(defun appropriate-for-reductio-supposition (formula)$/;"	f
appropriately-related-node-suppositions	oscar.lisp	/^(defun appropriately-related-node-suppositions (node node* unifier)$/;"	f
appropriately-related-non-reductio-suppositions	oscar.lisp	/^(defun appropriately-related-non-reductio-suppositions (node interest unifier)$/;"	f
appropriately-related-reductio-suppositions	oscar.lisp	/^(defun appropriately-related-reductio-suppositions (node interest unifier)$/;"	f
appropriately-related-supposition	oscar.lisp	/^(defun appropriately-related-supposition (node interest supposition supposition-variables unifier)$/;"	f
appropriately-related-suppositions	oscar.lisp	/^(defun appropriately-related-suppositions (node interest unifier &optional a-list target)$/;"	f
arg-list	syntax.lisp	/^(defun arg-list (p) (cdr p))$/;"	f
arg-list-of	syntax.lisp	/^(defun arg-list-of (p)$/;"	f
arg-terms-of	syntax.lisp	/^(defun arg-terms-of (p)$/;"	f
arithmetical-equality	perception-cause.lisp	/^(def-backwards-reason arithmetical-equality$/;"	f
arithmetical-inequality	perception-cause.lisp	/^(def-backwards-reason arithmetical-inequality$/;"	f
arithmetical-nonequality	perception-cause.lisp	/^(def-backwards-reason arithmetical-nonequality$/;"	f
arithmetical-terms	reason.lisp	/^(defun arithmetical-terms (formula &optional terms)$/;"	f
atomic-formula	syntax.lisp	/^(defun atomic-formula (p)$/;"	f
augment-inherited-non-reductio-suppositions	oscar.lisp	/^(defun augment-inherited-non-reductio-suppositions (interest &optional nodes interests)$/;"	f
backwards-formula-condition	reason.lisp	/^(defun backwards-formula-condition (formula)$/;"	f
bar-indent	tool.lisp	/^(defun bar-indent (depth)$/;"	f
base-reductio-supposition	oscar.lisp	/^(defun base-reductio-supposition (N)$/;"	f
base-test	oscar.lisp	/^(defun base-test (R RA)$/;"	f
bicond1	syntax.lisp	/^(defmacro bicond1 (p)$/;"	f
bicond2	syntax.lisp	/^(defmacro bicond2 (p)$/;"	f
bicondit	syntax.lisp	/^(defun bicondit (p q) (list '<-> p q))$/;"	f
bicondit-intro	rule.lisp	/^(defun bicondit-intro (interest depth priority)$/;"	f
bicondit-simp	rule.lisp	/^(defun bicondit-simp (c depth ip)$/;"	f
biconditionalp	syntax.lisp	/^(defun biconditionalp (p)$/;"	f
binding-function	reason.lisp	/^(defun binding-function (P vars)$/;"	f
binding-unifier	oscar.lisp	/^(defun binding-unifier (binding1 binding2 premise-variables vars1 vars2)$/;"	f
blank-indent	tool.lisp	/^(defun blank-indent (depth &optional stream)$/;"	f
broadly-generating-nodes	oscar.lisp	/^(defun broadly-generating-nodes (interest)$/;"	f
build-hyper-defeat-link	oscar.lisp	/^(defun build-hyper-defeat-link (root target)$/;"	f
build-hyperlink	oscar.lisp	/^(defun build-hyperlink (basis clues rule discount node NDA binding link instantiations depth defeasible?)$/;"	f
c-list-for	oscar.lisp	/^(defun c-list-for (formula)$/;"	f
caddddddr	tool.lisp	/^(defun caddddddr (x) (car (cddddddr x)))$/;"	f
cadddddr	tool.lisp	/^(defun cadddddr (x) (car (cdddddr x)))$/;"	f
caddddr	tool.lisp	/^(defun caddddr (x) (car (cddddr x)))$/;"	f
callees	tool.lisp	/^(defun callees (fun &key print order)$/;"	f
callers	tool.lisp	/^(defun callers (f &optional listees depth functions max-depth)$/;"	f
cancel-d-node	oscar.lisp	/^(defun cancel-d-node (d-node)$/;"	f
cancel-instantiated-premise	oscar.lisp	/^(defun cancel-instantiated-premise (IP)$/;"	f
cancel-interest	oscar.lisp	/^(defun cancel-interest (interest depth)$/;"	f
cancel-interest-in	oscar.lisp	/^(defun cancel-interest-in (interest depth)$/;"	f
cancel-interest-in-node	oscar.lisp	/^(defun cancel-interest-in-node (node depth)$/;"	f
cancel-interest-scheme	oscar.lisp	/^(defun cancel-interest-scheme (IS)$/;"	f
cancel-node	oscar.lisp	/^(defun cancel-node (node depth)$/;"	f
cancel-subsumed-links	oscar.lisp	/^(defun cancel-subsumed-links (link depth)$/;"	f
cancelled-c-list-for	oscar.lisp	/^(defun cancelled-c-list-for (formula)$/;"	f
cat	tool.lisp	/^(defun cat (x y)$/;"	f
cat-list	tool.lisp	/^(defun cat-list (s)$/;"	f
cbp	oscar.lisp	/^(defmacro cbp (P C1 C2 V) `(construct-backwards-premise ,P ,C1 ,C2 ,V))$/;"	f
cddddddr	tool.lisp	/^(defun cddddddr (x) (cdr (cdddddr x)))$/;"	f
cdddddr	tool.lisp	/^(defun cdddddr (x) (cdr (cddddr x)))$/;"	f
cfp	oscar.lisp	/^(defmacro cfp (P V &optional B) `(construct-forwards-premise ,P nil ,V ,B))$/;"	f
change-to-reductio-interest	oscar.lisp	/^(defun change-to-reductio-interest (interest depth d-interests)$/;"	f
changed-defs	tool.lisp	/^(defun changed-defs (&optional do-not-print-changes)$/;"	f
char-list	tool.lisp	/^(defun char-list (x)$/;"	f
char-num	tool.lisp	/^(defun char-num (x)$/;"	f
clear-criticalities	hypergraph.lisp	/^(defun clear-criticalities ()$/;"	f
clear-graph-memories	hypergraph.lisp	/^(defun clear-graph-memories ()$/;"	f
clear-hyperlink-defeat-loops	hypergraph.lisp	/^(defun clear-hyperlink-defeat-loops ()$/;"	f
clear-indent	argument.lisp	/^(defun clear-indent (n &optional fw)$/;"	f
clear-meter	tool.lisp	/^(defun clear-meter (&rest funs)$/;"	f
clue?	oscar.lisp	/^(defun clue? (premise)$/;"	f
collapse-strings	problem.lisp	/^(defun collapse-strings (strings)$/;"	f
compare-last-def	tool.lisp	/^(defun compare-last-def (fun)$/;"	f
compare-lists	tool.lisp	/^(defun compare-lists (x y &key (test #'eq))$/;"	f
compare-meters	tool.lisp	/^(defun compare-meters (meter1 meter2)$/;"	f
compare-trees	tool.lisp	/^(defun compare-trees (tree1 tree2)$/;"	f
competing-percepts	perception-cause.lisp	/^(defun competing-percepts (P Q)$/;"	f
complexity	oscar.lisp	/^(defun complexity (x)$/;"	f
compute-affected-justifications	hypergraph.lisp	/^(defun compute-affected-justifications (link)$/;"	f
compute-backwards-reason-d-nodes	oscar.lisp	/^(defun compute-backwards-reason-d-nodes ()$/;"	f
compute-dependencies	oscar.lisp	/^(defun compute-dependencies (interest)$/;"	f
compute-dependencies-from-node	oscar.lisp	/^(defun compute-dependencies-from-node (node)$/;"	f
compute-discounted-node-strength	oscar.lisp	/^(defun compute-discounted-node-strength (node)$/;"	f
compute-forwards-reason-d-nodes	oscar.lisp	/^(defun compute-forwards-reason-d-nodes ()$/;"	f
compute-hyper-defeat-link-justification	hypergraph.lisp	/^(defun compute-hyper-defeat-link-justification (DL sigma link0 &optional (indent 0) path)$/;"	f
compute-hypernode-degrees-of-justification	hypergraph.lisp	/^(defun compute-hypernode-degrees-of-justification ()$/;"	f
compute-hypernode-dependencies	oscar.lisp	/^(defun compute-hypernode-dependencies (node indent msg)$/;"	f
compute-hypernode-justification	hypergraph.lisp	/^(defun compute-hypernode-justification (node sigma &optional link0 (indent 0) case path)$/;"	f
compute-interest-dependencies	oscar.lisp	/^(defun compute-interest-dependencies (interest indent msg)$/;"	f
compute-interest-graph-defeat-statuses	oscar.lisp	/^(defun compute-interest-graph-defeat-statuses (new-beliefs new-retractions)$/;"	f
compute-interest-supposition-nodes	oscar.lisp	/^(defun compute-interest-supposition-nodes (interest)$/;"	f
compute-link-interest	oscar.lisp	/^(defun compute-link-interest$/;"	f
compute-link-justification	hypergraph.lisp	/^(defun compute-link-justification (link sigma link0 &optional (indent 0) path)$/;"	f
compute-nearest-defeasible-ancestors	oscar.lisp	/^(defun compute-nearest-defeasible-ancestors (basis rule)$/;"	f
compute-new-hypergraphs	hypergraph.lisp	/^(defun compute-new-hypergraphs (link &optional sigma (indent 0))$/;"	f
compute-old-degree-of-justification	oscar.lisp	/^(defun compute-old-degree-of-justification (node)$/;"	f
compute-relevant-nodes	oscar.lisp	/^(defun compute-relevant-nodes (nodes)$/;"	f
compute-strictly-relevant-nodes	oscar.lisp	/^(defun compute-strictly-relevant-nodes (nodes)$/;"	f
compute-undefeated-degrees-of-support	oscar.lisp	/^(defun compute-undefeated-degrees-of-support () ; (break)$/;"	f
concatenate-words	tool.lisp	/^(defun concatenate-words (word-list)$/;"	f
concluded-interest-priority	oscar.lisp	/^(defun concluded-interest-priority (Q)$/;"	f
conclusion-data	oscar.lisp	/^(defun conclusion-data (basis instantiations discharge supposition)$/;"	f
conclusion-instantiator	reason.lisp	/^(defun conclusion-instantiator (formula variables default)$/;"	f
conclusion-variable	oscar.lisp	/^(defun conclusion-variable (x)$/;"	f
cond-antecedent-simp	rule.lisp	/^(defun cond-antecedent-simp (c depth ip)$/;"	f
cond-simp1	rule.lisp	/^(defun cond-simp1 (c depth ip)$/;"	f
cond-simp2	rule.lisp	/^(defun cond-simp2 (c depth ip)$/;"	f
condit	syntax.lisp	/^(defun condit (p q) (list '-> p q))$/;"	f
condition-satisfying-interest	oscar.lisp	/^(defun condition-satisfying-interest (S condition link vars)$/;"	f
conditional-modus-tollens	rule.lisp	/^(defun conditional-modus-tollens (c depth ip)$/;"	f
conditionalization	rule.lisp	/^(def-backwards-reason conditionalization$/;"	f
conditionally-write-to-string	reason.lisp	/^(defun conditionally-write-to-string (s)$/;"	f
conditionalp	syntax.lisp	/^(defun conditionalp (p)$/;"	f
conj	syntax.lisp	/^(defun conj (p q) (list '& p q))$/;"	f
conjunct1	syntax.lisp	/^(defmacro conjunct1 (p)$/;"	f
conjunct2	syntax.lisp	/^(defmacro conjunct2 (p)$/;"	f
conjunctionp	syntax.lisp	/^(defun conjunctionp (p)$/;"	f
conjuncts	syntax.lisp	/^(defun conjuncts (p)$/;"	f
consequent	syntax.lisp	/^(defmacro consequent (p)$/;"	f
consistent-assignment	tool.lisp	/^(defun consistent-assignment (s)$/;"	f
consistent-match	tool.lisp	/^(defun consistent-match (p1 p2)$/;"	f
constituent-terms-of	syntax.lisp	/^(defun constituent-terms-of (c)$/;"	f
constrained-assignment	oscar.lisp	/^(defun constrained-assignment (unifier vars1 vars2)$/;"	f
construct-backwards-premise	oscar.lisp	/^(defun construct-backwards-premise (P C1 C2 V)$/;"	f
construct-forwards-premise	oscar.lisp	/^(defun construct-forwards-premise (P C V &optional B)$/;"	f
construct-initial-interest-link	oscar.lisp	/^(defun construct-initial-interest-link$/;"	f
construct-interest-link	oscar.lisp	/^(defun construct-interest-link$/;"	f
construct-interest-scheme	oscar.lisp	/^(defun construct-interest-scheme$/;"	f
construct-new-interest-for	oscar.lisp	/^(defun construct-new-interest-for$/;"	f
construct-new-interest-for-sequent	oscar.lisp	/^(defun construct-new-interest-for-sequent (S degree maximum-degree)$/;"	f
contra-conditionalization	rule.lisp	/^(def-backwards-reason contra-conditionalization$/;"	f
contradicting-nodes	oscar.lisp	/^(defun contradicting-nodes (n1 n2)$/;"	f
convergent-support-path	hypergraph.lisp	/^(defun convergent-support-path (path sigma DL)$/;"	f
convert-conclusion-variables	oscar.lisp	/^(defun convert-conclusion-variables (formula variables)$/;"	f
convert-from-deductive-only	oscar.lisp	/^(defun convert-from-deductive-only (node)$/;"	f
convert-interest-variables	oscar.lisp	/^(defun convert-interest-variables (formula variables)$/;"	f
convert-non-reductio-sup	oscar.lisp	/^(defun convert-non-reductio-sup (sup)$/;"	f
convert-reductio-supposition	oscar.lisp	/^(defun convert-reductio-supposition (sup discount-factor)$/;"	f
convert-to-prefix-form	syntax.lisp	/^(defun convert-to-prefix-form (P)$/;"	f
convert-to-string	syntax.lisp	/^(defun convert-to-string (s)$/;"	f
convert-to-symbol	syntax.lisp	/^(defun convert-to-symbol (form variables)$/;"	f
convert-unifier-variables	oscar.lisp	/^(defun convert-unifier-variables (unifier variables)$/;"	f
critical-hyperlinks	hypergraph.lisp	/^(defun critical-hyperlinks (DL sigma)$/;"	f
critical-link	hypergraph.lisp	/^(defun critical-link (DL sigma)$/;"	f
critical-set	hypergraph.lisp	/^(defun critical-set (links paths)$/;"	f
crossproduct	tool.lisp	/^(defun crossproduct (A B)$/;"	f
current-degree-of-justification	oscar.lisp	/^(defun current-degree-of-justification (node)$/;"	f
current-maximal-degree-of-justification	oscar.lisp	/^(defun current-maximal-degree-of-justification (node)$/;"	f
d-node	oscar.lisp	/^(defun d-node (n)$/;"	f
d-node-ancestors	oscar.lisp	/^(defun d-node-ancestors (dn)$/;"	f
d-node-descendants	oscar.lisp	/^(defun d-node-descendants (dn)$/;"	f
d-node-for	oscar.lisp	/^(defun d-node-for (formula)$/;"	f
ddn	oscar.lisp	/^(defun ddn (&optional (nodes *discrimination-net*)) (display-discrimination-net nodes))$/;"	f
dead-elimination	perception-cause.lisp	/^(def-forwards-reason dead-elimination$/;"	f
dead-introduction	perception-cause.lisp	/^(def-backwards-reason dead-introduction$/;"	f
decode-time	tool.lisp	/^(defun decode-time (time)$/;"	f
deductive-argument	argument.lisp	/^(defun deductive-argument (arg)$/;"	f
deductive-consequences	oscar.lisp	/^(defun deductive-consequences (node)$/;"	f
deductive-in	oscar.lisp	/^(defun deductive-in (n m)$/;"	f
deductive-link	oscar.lisp	/^(defun deductive-link (L)$/;"	f
deductive-node	oscar.lisp	/^(defun deductive-node (n)$/;"	f
def-backwards-reason	reason.lisp	/^(defmacro def-backwards-reason (name &rest body)$/;"	f
def-backwards-undercutter	reason.lisp	/^(defmacro def-backwards-undercutter (name &rest body)$/;"	f
def-forwards-reason	reason.lisp	/^(defmacro def-forwards-reason (name &rest body)$/;"	f
def-forwards-undercutter	reason.lisp	/^(defmacro def-forwards-undercutter (name &rest body)$/;"	f
def-history	tool.lisp	/^(defun def-history (fun &optional do-not-print)$/;"	f
def-instantiator	oscar.lisp	/^(defun def-instantiator (def vars)$/;"	f
def-symbols	tool.lisp	/^(defun def-symbols (X symbols)$/;"	f
defeat-loops	hypergraph.lisp	/^(defun defeat-loops (link)$/;"	f
defeat-paths	hypergraph.lisp	/^(defun defeat-paths (link1 link2 &optional used-links)$/;"	f
defeater-priority	oscar.lisp	/^(defun defeater-priority (interest)$/;"	f
defeats	oscar.lisp	/^(defun defeats (sequent1 basis sequent2)$/;"	f
define-backwards-reason	problem.lisp	/^(defmacro define-backwards-reason$/;"	f
define-forwards-reason	problem.lisp	/^(defmacro define-forwards-reason$/;"	f
definition	tool.lisp	/^(defun definition (fun)$/;"	f
defunction	tool.lisp	/^(defmacro defunction (fun arg &rest body)$/;"	f
degree-of-interest*	oscar.lisp	/^(defun degree-of-interest* (n)$/;"	f
delete-arguments	oscar.lisp	/^(defun delete-arguments (link node L0 depth)$/;"	f
delete-n	tool.lisp	/^(defun delete-n (n y)$/;"	f
depth	tool.lisp	/^(defun depth (s)$/;"	f
derived-interests	oscar.lisp	/^(defun derived-interests (interest)$/;"	f
descendants-of	oscar.lisp	/^(defun descendants-of (N)$/;"	f
desire-preference	oscar.lisp	/^(defun desire-preference (desire)$/;"	f
direct-callees	tool.lisp	/^(defun direct-callees (fun &optional symbols)$/;"	f
discharge-appropriately-related-link	oscar.lisp	/^(defun discharge-appropriately-related-link (link u* degree new? old-degree N node depth interests)$/;"	f
discharge-delayed-reductios	oscar.lisp	/^(defun discharge-delayed-reductios (node depth d-interests)$/;"	f
discharge-fortuitous-reductio-interests	oscar.lisp	/^(defun discharge-fortuitous-reductio-interests (interest depth)$/;"	f
discharge-fortuitous-reductios	oscar.lisp	/^(defun discharge-fortuitous-reductios (node d-interests depth)$/;"	f
discharge-immediate-reductios	oscar.lisp	/^(defun discharge-immediate-reductios$/;"	f
discharge-interest-in-defeaters	oscar.lisp	/^(defun discharge-interest-in-defeaters (node i-lists old-degree new?)$/;"	f
discharge-interest-scheme	oscar.lisp	/^(defun discharge-interest-scheme (interest-scheme d-node priority depth)$/;"	f
discharge-interest-schemes	oscar.lisp	/^(defun discharge-interest-schemes (node old-degree depth)$/;"	f
discharge-new-reductio-interest	oscar.lisp	/^(defun discharge-new-reductio-interest (interest depth d-interests)$/;"	f
discharge-reductios	oscar.lisp	/^(defun discharge-reductios (node old-degree depth d-interests)$/;"	f
discharge-ultimate-epistemic-interests	oscar.lisp	/^(defun discharge-ultimate-epistemic-interests (new-beliefs new-retractions)$/;"	f
discharged?	oscar.lisp	/^(defun discharged? (interest degree)$/;"	f
disj	syntax.lisp	/^(defun disj (p q) (list 'v p q))$/;"	f
disj-antecedent-simp	rule.lisp	/^(defun disj-antecedent-simp (c depth ip)$/;"	f
disj-cond	rule.lisp	/^(defun disj-cond (interest depth priority)$/;"	f
disj-cond-2	rule.lisp	/^(defun disj-cond-2 (interest depth priority)$/;"	f
disj-simp	rule.lisp	/^(defun disj-simp (c depth ip)$/;"	f
disjoint	tool.lisp	/^(defun disjoint (x y)$/;"	f
disjointp	tool.lisp	/^(defun disjointp (x y)$/;"	f
disjunct-list	syntax.lisp	/^(defun disjunct-list (p)$/;"	f
disjunct1	syntax.lisp	/^(defmacro disjunct1 (p)$/;"	f
disjunct2	syntax.lisp	/^(defmacro disjunct2 (p)$/;"	f
disjunctionp	syntax.lisp	/^(defun disjunctionp (p)$/;"	f
disjuncts	syntax.lisp	/^(defun disjuncts (p)$/;"	f
display-argument	argument.lisp	/^(defun display-argument (arg &optional fw)$/;"	f
display-arguments	argument.lisp	/^(defun display-arguments ()$/;"	f
display-backwards-reason	problem.lisp	/^(defun display-backwards-reason (R)$/;"	f
display-belief-changes	hypergraph.lisp	/^(defun display-belief-changes  (links new-beliefs new-retractions)$/;"	f
display-belief-changes	oscar.lisp	/^(defun display-belief-changes  (links new-beliefs new-retractions)$/;"	f
display-c-lists	oscar.lisp	/^(defun display-c-lists ()$/;"	f
display-callees	tool.lisp	/^(defun display-callees (f &key repeat  (depth 64) symbols)$/;"	f
display-callees*	tool.lisp	/^(defun display-callees*$/;"	f
display-conclusion	oscar.lisp	/^(defun display-conclusion (n)$/;"	f
display-conclusions	oscar.lisp	/^(defun display-conclusions ()$/;"	f
display-conclusions-by-supposition	oscar.lisp	/^(defun display-conclusions-by-supposition ()$/;"	f
display-d-node	oscar.lisp	/^(defun display-d-node (dn depth test)$/;"	f
display-discharge-condition	oscar.lisp	/^(defun display-discharge-condition (interest link)$/;"	f
display-discrimination-net	oscar.lisp	/^(defun display-discrimination-net (&optional (nodes *discrimination-net*))$/;"	f
display-discrimination-node	oscar.lisp	/^(defun display-discrimination-node (d-node listees depth last? nodes &optional test)$/;"	f
display-forwards-reason	problem.lisp	/^(defun display-forwards-reason (R)$/;"	f
display-from	oscar.lisp	/^(defun display-from (n) (setf *display?* nil *trace* nil *start-trace* nil *start-display* n))$/;"	f
display-hypergraph	hypergraph.lisp	/^(defun display-hypergraph ()$/;"	f
display-hypergraphs	hypergraph.lisp	/^(defun display-hypergraphs (link)$/;"	f
display-hyperlink	oscar.lisp	/^(defun display-hyperlink (L)$/;"	f
display-hypernode	oscar.lisp	/^(defun display-hypernode (n )$/;"	f
display-i-lists	oscar.lisp	/^(defun display-i-lists ()$/;"	f
display-inference-graph	oscar.lisp	/^(defun display-inference-graph ()$/;"	f
display-inference-queue	oscar.lisp	/^(defun display-inference-queue ()$/;"	f
display-instantiated-premise	oscar.lisp	/^(defun display-instantiated-premise (ip)$/;"	f
display-interest	oscar.lisp	/^(defun display-interest (interest)$/;"	f
display-interest-scheme	oscar.lisp	/^(defun display-interest-scheme (interest-scheme)$/;"	f
display-interests	oscar.lisp	/^(defun display-interests ()$/;"	f
display-interests-by-supposition	oscar.lisp	/^(defun display-interests-by-supposition ()$/;"	f
display-link	oscar.lisp	/^(defun display-link (L)$/;"	f
display-links	oscar.lisp	/^(defun display-links ()$/;"	f
display-node	oscar.lisp	/^(defun display-node$/;"	f
display-off	oscar.lisp	/^(defun display-off () (setf *display?* nil *trace* nil *start-trace* nil *start-display* nil))$/;"	f
display-on	oscar.lisp	/^(defun display-on () (setf *display?* t))$/;"	f
display-peripherals	oscar.lisp	/^(defun display-peripherals (x boundary nodes-used)$/;"	f
display-problem	problem.lisp	/^(defun display-problem (P)$/;"	f
display-problems	problem.lisp	/^(defun display-problems (&optional n)$/;"	f
display-processed-c-lists	oscar.lisp	/^(defun display-processed-c-lists ()$/;"	f
display-queries	oscar.lisp	/^(defun display-queries ()$/;"	f
display-query	oscar.lisp	/^(defun display-query (Q)$/;"	f
display-reasoning	oscar.lisp	/^(defun display-reasoning (&optional full-display)$/;"	f
display-reasoning-for	oscar.lisp	/^(defun display-reasoning-for (node)$/;"	f
display-reasoning-fully	oscar.lisp	/^(defun display-reasoning-fully ()$/;"	f
display-reasons	problem.lisp	/^(defun display-reasons ()$/;"	f
display-run-time-in-seconds	tool.lisp	/^(defun display-run-time-in-seconds (time)$/;"	f
display-settings	perception-cause.lisp	/^(defun display-settings ()$/;"	f
display-split	hypergraph.lisp	/^(defun display-split (link sigma indent)$/;"	f
display-test-log	oscar.lisp	/^(defun display-test-log ()$/;"	f
display-unsupported-hypernode	oscar.lisp	/^(defun display-unsupported-hypernode (n )$/;"	f
display-used-interest	oscar.lisp	/^(defun display-used-interest$/;"	f
display-values	tool.lisp	/^(defun display-values (fun &rest ranges)$/;"	f
do-until	tool.lisp	/^(defmacro do-until (P Q)$/;"	f
domain	tool.lisp	/^(defun domain (x) (remove-duplicates (mapcar #'car x) :test 'equal))$/;"	f
dot-product	tool.lisp	/^(defun dot-product (x y)$/;"	f
draw-i	oscar.lisp	/^(defun draw-i (x y) (declare (ignore x y)))$/;"	f
draw-interest	oscar.lisp	/^(defun draw-interest (x y z) (declare (ignore x y z)))$/;"	f
draw-just-defeated-node	oscar.lisp	/^(defun draw-just-defeated-node (x y z) (declare (ignore x y z)))$/;"	f
draw-just-node	oscar.lisp	/^(defun draw-just-node (x y z w) (declare (ignore x y z w)))$/;"	f
draw-just-undefeated-node	oscar.lisp	/^(defun draw-just-undefeated-node (x y z) (declare (ignore x y z)))$/;"	f
draw-n	oscar.lisp	/^(defun draw-n (x y z) (declare (ignore x y z)))$/;"	f
draw-reductio-conclusion	oscar.lisp	/^(defun draw-reductio-conclusion (P node node* R Y Y* RA NR interest unifier depth d-interests)$/;"	f
e-assoc	tool.lisp	/^(defun e-assoc (x l)$/;"	f
e-gen	syntax.lisp	/^(defun e-gen (x p) (list 'some x p))$/;"	f
e-genp	syntax.lisp	/^(defun e-genp (p)$/;"	f
e-matrix	syntax.lisp	/^(defun e-matrix (p)$/;"	f
e-vars	syntax.lisp	/^(defun e-vars (p)$/;"	f
ei-level	rule.lisp	/^(defun ei-level (var) (get var 'ei-level))$/;"	f
elapsed-time	tool.lisp	/^(defmacro elapsed-time (form time &optional increment-flag)$/;"	f
element	tool.lisp	/^(defmacro element (n x) `(nth ,n ,x))$/;"	f
explode	tool.lisp	/^(defun explode (s)$/;"	f
export-all	tool.lisp	/^(defun export-all (&optional pkg)$/;"	f
exportation	rule.lisp	/^(defun exportation (c depth ip)$/;"	f
factorial	tool.lisp	/^(defun factorial (n)$/;"	f
fbound-current	tool.lisp	/^(defun fbound-current (fun)$/;"	f
fetch-I-list-for	oscar.lisp	/^(defun fetch-I-list-for (term-list d-node)$/;"	f
fetch-c-list-for	oscar.lisp	/^(defun fetch-c-list-for (formula d-node)$/;"	f
find-backwards-con-reasons	problem.lisp	/^(defun find-backwards-con-reasons (string problem-number)$/;"	f
find-backwards-pf-reasons	problem.lisp	/^(defun find-backwards-pf-reasons (string problem-number)$/;"	f
find-conclusions-from-string	problem.lisp	/^(defun find-conclusions-from-string (string)$/;"	f
find-defeating-arguments	argument.lisp	/^(defun find-defeating-arguments (argument)$/;"	f
find-forwards-con-reasons	problem.lisp	/^(defun find-forwards-con-reasons (string problem-number)$/;"	f
find-forwards-pf-reasons	problem.lisp	/^(defun find-forwards-pf-reasons (string problem-number)$/;"	f
find-match	syntax.lisp	/^(defun find-match (s)$/;"	f
find-matching-c-lists-for	oscar.lisp	/^(defun find-matching-c-lists-for (formula variables)$/;"	f
find-matching-i-lists-for	oscar.lisp	/^(defun find-matching-i-lists-for (formula variables)$/;"	f
find-premises-from-string	problem.lisp	/^(defun find-premises-from-string (string)$/;"	f
find-string	problem.lisp	/^(defun find-string (string1 string2 &optional case-sensitive)$/;"	f
first-n	tool.lisp	/^(defun first-n (n s)$/;"	f
first-p	tool.lisp	/^(defun first-p (x P) (cond ((null x) "none")$/;"	f
fix-nest	syntax.lisp	/^(defun fix-nest (s)$/;"	f
fixed-length-subsets	tool.lisp	/^(defun fixed-length-subsets (n set)$/;"	f
flash-nodes	oscar.lisp	/^(defun flash-nodes (x y z w) (declare (ignore x y z w)))$/;"	f
for-all	tool.lisp	/^(defmacro for-all (x f) (list 'mapc f x))$/;"	f
form-epistemic-desires-for	oscar.lisp	/^(defun form-epistemic-desires-for (interest)$/;"	f
form-percept	perception-cause.lisp	/^(defun form-percept (P clarity &optional source)$/;"	f
format-argument	argument.lisp	/^(defun format-argument (arg  &optional fw)$/;"	f
formula-code	oscar.lisp	/^(defun formula-code (P)$/;"	f
formula-code*	oscar.lisp	/^(defun formula-code* (P descriptor)$/;"	f
formula-complexity	oscar.lisp	/^(defun formula-complexity (formula)$/;"	f
formula-condition	reason.lisp	/^(defun formula-condition (formula premise-variables)$/;"	f
formula-hypernode-variables	oscar.lisp	/^(defun formula-hypernode-variables (p)$/;"	f
formula-instantiator	reason.lisp	/^(defun formula-instantiator (P variables)$/;"	f
formula-profile	reason.lisp	/^(defun formula-profile (P vars descriptor)$/;"	f
fp-formula*	reason.lisp	/^(defun fp-formula* (premise)$/;"	f
full-display-node	oscar.lisp	/^(defun full-display-node (n proof-nodes)$/;"	f
full-display-used-interest	oscar.lisp	/^(defun full-display-used-interest (interest)$/;"	f
funcall*	tool.lisp	/^(defun funcall* (f x) (or (null f) (funcall f x)))$/;"	f
funcall**	oscar.lisp	/^(defun funcall** (f x y) (if f (funcall f x y) t))$/;"	f
funcall+	tool.lisp	/^(defmacro funcall+ (F &rest x)$/;"	f
gdisc	tool.lisp	/^(defun gdisc (f)$/;"	f
gen-conjunction	syntax.lisp	/^(defun gen-conjunction (X)$/;"	f
gen-disjunction	syntax.lisp	/^(defun gen-disjunction (X)$/;"	f
gen-intersection	tool.lisp	/^(defun gen-intersection (x)$/;"	f
gencrossproduct	tool.lisp	/^(defun gencrossproduct (A)$/;"	f
generalized-e-gen	syntax.lisp	/^(defun generalized-e-gen (variables P)$/;"	f
generate-reductio-interests	oscar.lisp	/^(defun generate-reductio-interests (node depth d-interests)$/;"	f
generated-nodes-and-interests	oscar.lisp	/^(defun generated-nodes-and-interests (proof-nodes enabling-interests ultimate-interests)$/;"	f
generating-non-reductio-interests	oscar.lisp	/^(defun generating-non-reductio-interests (N)$/;"	f
generating-reductio-interests	oscar.lisp	/^(defun generating-reductio-interests (N)$/;"	f
genunion	tool.lisp	/^(defun genunion (x)$/;"	f
genunion+	tool.lisp	/^(defun genunion+ (x)$/;"	f
gfunc	tool.lisp	/^(defun gfunc (f)$/;"	f
goal-generating-interest	oscar.lisp	/^(defun goal-generating-interest (goal)$/;"	f
good-interest-ancestor-chains	oscar.lisp	/^(defun good-interest-ancestor-chains (interest)$/;"	f
graph-log-off	oscar.lisp	/^(defun graph-log-off () (setf *graph-log* nil))$/;"	f
graph-log-on	oscar.lisp	/^(defun graph-log-on () (setf *graph-log* t))$/;"	f
graphics-pause-off	oscar.lisp	/^(defun graphics-pause-off () (setf *graphics-pause* nil))$/;"	f
graphics-pause-on	oscar.lisp	/^(defun graphics-pause-on () (setf *graphics-pause* t))$/;"	f
hereditarily-critical-link	hypergraph.lisp	/^(defun hereditarily-critical-link (DL sigma)$/;"	f
hyper-defeat-link	oscar.lisp	/^(defun hyper-defeat-link (n)$/;"	f
hyperlink	oscar.lisp	/^(defun hyperlink (n)$/;"	f
hyperlink-hypernode-defeaters	oscar.lisp	/^(defun hyperlink-hypernode-defeaters (link)$/;"	f
hyperlink-strength+	argument.lisp	/^(defun hyperlink-strength+ (L)$/;"	f
hypernode	oscar.lisp	/^(defun hypernode (n)$/;"	f
hypernode-arguments	argument.lisp	/^(defun hypernode-arguments (node &optional used-sequents)$/;"	f
hypernode-basis-in-arg	argument.lisp	/^(defun hypernode-basis-in-arg (node arg)$/;"	f
hypernode-color	oscar.lisp	/^(defun hypernode-color (x y) (declare (ignore x y)))$/;"	f
hypernode-consequences	oscar.lisp	/^(defun hypernode-consequences (n)$/;"	f
hypernode-defeatees	oscar.lisp	/^(defun hypernode-defeatees (node)$/;"	f
hypernode-descendants-of-interest	oscar.lisp	/^(defun hypernode-descendants-of-interest (interest)$/;"	f
hypernode-position	oscar.lisp	/^(defun hypernode-position (x y) (declare (ignore x y)))$/;"	f
hypernode-unifier	oscar.lisp	/^(defun hypernode-unifier (n m)$/;"	f
i-DM	rule.lisp	/^(defun i-DM (interest depth priority)$/;"	f
i-list-for	oscar.lisp	/^(defun i-list-for (formula i-vars)$/;"	f
i-neg-bicondit	rule.lisp	/^(defun i-neg-bicondit (interest depth priority)$/;"	f
i-neg-condit	rule.lisp	/^(defun i-neg-condit (interest depth priority)$/;"	f
i-neg-disj	rule.lisp	/^(defun i-neg-disj (interest depth priority)$/;"	f
i-neg-eg	rule.lisp	/^(defun i-neg-eg (interest depth priority)$/;"	f
i-neg-ug	rule.lisp	/^(defun i-neg-ug (interest depth priority)$/;"	f
i-preferred	oscar.lisp	/^(defun i-preferred (node1 node2)$/;"	f
iden	syntax.lisp	/^(defun iden (x y) (list '= x y))$/;"	f
iden1	syntax.lisp	/^(defun iden1 (p)$/;"	f
iden2	syntax.lisp	/^(defun iden2 (p)$/;"	f
identityp	syntax.lisp	/^(defun identityp (p)$/;"	f
ifm	oscar.lisp	/^(defun ifm (n)$/;"	f
image	tool.lisp	/^(defmacro image (K f)$/;"	f
imp	tool.lisp	/^(defun imp (s)$/;"	f
implode	tool.lisp	/^(defun implode (x)$/;"	f
in-interest	oscar.lisp	/^(defun in-interest (sequent)$/;"	f
inclusive-hypernode-ancestors	oscar.lisp	/^(defun inclusive-hypernode-ancestors (node)$/;"	f
inconsistent-supposition	oscar.lisp	/^(defun inconsistent-supposition (basis)$/;"	f
indent	tool.lisp	/^(defun indent (depth &optional stream)$/;"	f
independent-hyper-defeat-link-value	hypergraph.lisp	/^(defun independent-hyper-defeat-link-value (dl sigma)$/;"	f
independent-hypernode-value	hypergraph.lisp	/^(defun independent-hypernode-value (node sigma)$/;"	f
independent-link-value	hypergraph.lisp	/^(defun independent-link-value (link sigma)$/;"	f
independent-of	argument.lisp	/^(defun independent-of (sequent argument)$/;"	f
index-backwards-reason	oscar.lisp	/^(defun index-backwards-reason (reason profile d-node)$/;"	f
index-backwards-reason-at-new-nodes	oscar.lisp	/^(defun index-backwards-reason-at-new-nodes (reason d-node profile test)$/;"	f
index-forwards-reason	oscar.lisp	/^(defun index-forwards-reason (reason premise profile d-node)$/;"	f
index-forwards-reason-at-new-nodes	oscar.lisp	/^(defun index-forwards-reason-at-new-nodes$/;"	f
index-hypernode	oscar.lisp	/^(defun index-hypernode (node profile term-list d-node)$/;"	f
index-hypernode-at-new-nodes	oscar.lisp	/^(defun index-hypernode-at-new-nodes (node term-list d-node profile test)$/;"	f
index-instantiated-premise	oscar.lisp	/^(defun index-instantiated-premise$/;"	f
index-instantiated-premise-at-new-nodes	oscar.lisp	/^(defun index-instantiated-premise-at-new-nodes$/;"	f
index-interest	oscar.lisp	/^(defun index-interest (interest profile term-list d-node)$/;"	f
index-interest-at-new-nodes	oscar.lisp	/^(defun index-interest-at-new-nodes (interest term-list d-node profile test)$/;"	f
index-interest-scheme	oscar.lisp	/^(defun index-interest-scheme (interest-scheme profile d-node)$/;"	f
index-interest-scheme-at-new-nodes	oscar.lisp	/^(defun index-interest-scheme-at-new-nodes (interest-scheme d-node profile test)$/;"	f
inequality-transitivity	perception-cause.lisp	/^(def-backwards-reason inequality-transitivity$/;"	f
inequality-transitivity2	perception-cause.lisp	/^(def-backwards-reason inequality-transitivity2$/;"	f
inference-descendants	oscar.lisp	/^(defun inference-descendants (nodes)$/;"	f
initial-node	hypergraph.lisp	/^(defun initial-node (node sigma)$/;"	f
initialize-discrimination-net	oscar.lisp	/^(defun initialize-discrimination-net ()$/;"	f
initialize-reasoner	oscar.lisp	/^(defun initialize-reasoner ()$/;"	f
initiate-actions	oscar.lisp	/^(defun initiate-actions ()$/;"	f
insert	tool.lisp	/^(defun insert (x A R)$/;"	f
instance-of	oscar.lisp	/^(defun instance-of (formula1 formula2)$/;"	f
instantiate-defeater	oscar.lisp	/^(defun instantiate-defeater (undercutting-interest defeater antecedent* link reverse-binding)$/;"	f
instantiated-premise	oscar.lisp	/^(defun instantiated-premise (n)$/;"	f
interest	oscar.lisp	/^(defun interest (n)$/;"	f
interest-ancestor-chains	oscar.lisp	/^(defun interest-ancestor-chains (interest)$/;"	f
interest-descendants	oscar.lisp	/^(defun interest-descendants (interests)$/;"	f
interest-for	oscar.lisp	/^(defun interest-for (sequent vars condition &optional link)$/;"	f
interest-link-priority	oscar.lisp	/^(defun interest-link-priority (link interest-priority interest)$/;"	f
interest-position	oscar.lisp	/^(defun interest-position (x y) (declare (ignore x y)))$/;"	f
interest-preference	oscar.lisp	/^(defun interest-preference (priority complexity)$/;"	f
interest-scheme	oscar.lisp	/^(defun interest-scheme (n)$/;"	f
interest-sequent*	oscar.lisp	/^(defun interest-sequent* (n)$/;"	f
interest-variable	oscar.lisp	/^(defun interest-variable (x)$/;"	f
interests-for	oscar.lisp	/^(defun interests-for (formula i-vars)$/;"	f
inverse	tool.lisp	/^(defun inverse (R) (mapcar #'reverse R))$/;"	f
invert-contradiction	oscar.lisp	/^(defun invert-contradiction  (L node node* D N instantiations depth)$/;"	f
invert-contradictions	oscar.lisp	/^(defun invert-contradictions (node instantiations depth)$/;"	f
invert-contradictions-from-new-hyperlink	oscar.lisp	/^(defun invert-contradictions-from-new-hyperlink (link instantiations)$/;"	f
invert-contradictions-retrospectively	oscar.lisp	/^(defun invert-contradictions-retrospectively (node NDA old-NDA)$/;"	f
ip	oscar.lisp	/^(defun ip (n)$/;"	f
is	oscar.lisp	/^(defun is (n)$/;"	f
is-derived-interest-schemes	oscar.lisp	/^(defmacro is-derived-interest-schemes (is) `(is-derived-premises ,is))$/;"	f
is-desire	oscar.lisp	/^(defun is-desire (c &rest r) (declare (ignore r)) (eq (hypernode-kind c) :desire))$/;"	f
is-inference	oscar.lisp	/^(defun is-inference (c &rest r) (declare (ignore r)) (eq (hypernode-kind c) :inference))$/;"	f
is-past	perception-cause.lisp	/^(def-backwards-reason is-past$/;"	f
is-past-or-present	perception-cause.lisp	/^(def-backwards-reason is-past-or-present$/;"	f
is-percept	oscar.lisp	/^(defun is-percept (c &rest r) (declare (ignore r)) (eq (hypernode-kind c) :percept))$/;"	f
last-link	hypergraph.lisp	/^(defun last-link (values path)$/;"	f
lastmember	tool.lisp	/^(defmacro lastmember (x) `(car (last ,x)))$/;"	f
lessp	tool.lisp	/^(defun lessp (x y)$/;"	f
line-indent	tool.lisp	/^(defun line-indent (n)$/;"	f
link	oscar.lisp	/^(defun link (n)$/;"	f
link-ancestor	oscar.lisp	/^(defun link-ancestor (L link)$/;"	f
link-descendant	hypergraph.lisp	/^(defun link-descendant (L link)$/;"	f
link-interests	oscar.lisp	/^(defun link-interests (link)$/;"	f
list-complexity	tool.lisp	/^(defun list-complexity (x)$/;"	f
list-instantiated-premises	oscar.lisp	/^(defun list-instantiated-premises (&optional d-node)$/;"	f
list-interest-schemes	oscar.lisp	/^(defun list-interest-schemes (&optional d-node)$/;"	f
literal	syntax.lisp	/^(defun literal (p)$/;"	f
log-off	oscar.lisp	/^(defun log-off () (setf *log-on* nil))$/;"	f
log-on	oscar.lisp	/^(defun log-on () (setf *log-on* t))$/;"	f
logic-off	oscar.lisp	/^(defun logic-off () (setf *use-logic* nil) (setf *use-reductio* nil))$/;"	f
logic-on	oscar.lisp	/^(defun logic-on () (setf *use-logic* t) (setf *use-reductio* t))$/;"	f
longest	tool.lisp	/^(defun longest (s) (prog (m n rest)$/;"	f
make-@	syntax.lisp	/^(defun make-@ (p q) (list '@ p q))$/;"	f
make-backwards-inference	oscar.lisp	/^(defun make-backwards-inference$/;"	f
make-clauses	reason.lisp	/^(defun make-clauses (body)$/;"	f
make-conclusion-variable	oscar.lisp	/^(defun make-conclusion-variable ()$/;"	f
make-forwards-inference	oscar.lisp	/^(defun make-forwards-inference (binding instantiations basis clues depth ip)$/;"	f
make-interest-variable	oscar.lisp	/^(defun make-interest-variable ()$/;"	f
make-new-conclusion	oscar.lisp	/^(defun make-new-conclusion$/;"	f
make-new-reductio-supposition	oscar.lisp	/^(defun make-new-reductio-supposition (interest X i-list P c-vars depth)$/;"	f
make-oscar-window	oscar.lisp	/^(defun make-oscar-window () nil)$/;"	f
make-problem-from-string	problem.lisp	/^(defun make-problem-from-string (problem-string)$/;"	f
make-problem-list	problem.lisp	/^(defun make-problem-list (set-string)$/;"	f
make-rebutting-defeater	oscar.lisp	/^(defun make-rebutting-defeater (variables base formula supposition antecedent* link)$/;"	f
make-simulation-problem	perception-cause.lisp	/^(defmacro make-simulation-problem (&rest body)$/;"	f
make-skolem-e-constant	oscar.lisp	/^(defun make-skolem-e-constant ()$/;"	f
make-skolem-e-function	oscar.lisp	/^(defun make-skolem-e-function ()$/;"	f
make-skolem-i-constant	oscar.lisp	/^(defun make-skolem-i-constant ()$/;"	f
make-skolem-i-function	oscar.lisp	/^(defun make-skolem-i-function ()$/;"	f
make-undercutting-defeater	oscar.lisp	/^(defun make-undercutting-defeater (base formula supposition antecedent* link reverse-binding)$/;"	f
mapcar1	tool.lisp	/^(defun mapcar1 (f x y) (mapcar #'(lambda (z) (apply f (list z y))) x))$/;"	f
match	tool.lisp	/^(defun match (pat exp var)$/;"	f
match-domain	tool.lisp	/^(defun match-domain (m)$/;"	f
match-sequential-sublis	oscar.lisp	/^(defun match-sequential-sublis (m x)$/;"	f
match-sublis	tool.lisp	/^(defun match-sublis (m x &key (test 'eq))$/;"	f
matching-c-lists-for	oscar.lisp	/^(defun matching-c-lists-for (term-list i-variables d-node)$/;"	f
matching-i-lists-for	oscar.lisp	/^(defun matching-i-lists-for (term-list c-variables d-node)$/;"	f
max+	tool.lisp	/^(defun max+ (m n)$/;"	f
maximal-subsets	tool.lisp	/^(defun maximal-subsets (X P)$/;"	f
maximum	tool.lisp	/^(defun maximum (X) (apply #'max X))$/;"	f
maximum0	tool.lisp	/^(defun maximum0 (X) (if X (apply #'max X) 0.0))$/;"	f
mem	tool.lisp	/^(defun mem (element  set)$/;"	f
mem1	tool.lisp	/^(defmacro mem1 (x) `(car ,x))$/;"	f
mem10	tool.lisp	/^(defmacro mem10 (x) `(nth 9 ,x))$/;"	f
mem11	tool.lisp	/^(defmacro mem11 (x) `(nth 10 ,x))$/;"	f
mem12	tool.lisp	/^(defmacro mem12 (x) `(nth 11 ,x))$/;"	f
mem13	tool.lisp	/^(defmacro mem13 (x) `(nth 12 ,x))$/;"	f
mem14	tool.lisp	/^(defmacro mem14 (x) `(nth 13 ,x))$/;"	f
mem15	tool.lisp	/^(defmacro mem15 (x) `(nth 14 ,x))$/;"	f
mem16	tool.lisp	/^(defmacro mem16 (x) `(nth 15 ,x))$/;"	f
mem17	tool.lisp	/^(defmacro mem17 (x) `(nth 16 ,x))$/;"	f
mem18	tool.lisp	/^(defmacro mem18 (x) `(nth 17 ,x))$/;"	f
mem2	tool.lisp	/^(defmacro mem2 (x) `(cadr ,x))$/;"	f
mem3	tool.lisp	/^(defmacro mem3 (x) `(nth 2 ,x))$/;"	f
mem4	tool.lisp	/^(defmacro mem4 (x) `(nth 3 ,x))$/;"	f
mem5	tool.lisp	/^(defmacro mem5 (x) `(nth 4 ,x))$/;"	f
mem6	tool.lisp	/^(defmacro mem6 (x) `(nth 5 ,x))$/;"	f
mem7	tool.lisp	/^(defmacro mem7 (x) `(nth 6 ,x))$/;"	f
mem8	tool.lisp	/^(defmacro mem8 (x) `(nth 7 ,x))$/;"	f
mem9	tool.lisp	/^(defmacro mem9 (x) `(nth 8 ,x))$/;"	f
member1	tool.lisp	/^(defun member1 (x) (car x))$/;"	f
member10	tool.lisp	/^(defun member10 (x) (nth 9 x))$/;"	f
member11	tool.lisp	/^(defun member11 (x) (nth 10 x))$/;"	f
member12	tool.lisp	/^(defun member12 (x) (nth 11 x))$/;"	f
member13	tool.lisp	/^(defun member13 (x) (nth 12 x))$/;"	f
member14	tool.lisp	/^(defun member14 (x) (nth 13 x))$/;"	f
member15	tool.lisp	/^(defun member15 (x) (nth 14 x))$/;"	f
member16	tool.lisp	/^(defun member16 (x) (nth 15 x))$/;"	f
member17	tool.lisp	/^(defun member17 (x) (nth 16 x))$/;"	f
member18	tool.lisp	/^(defun member18 (x) (nth 17 x))$/;"	f
member2	tool.lisp	/^(defun member2 (x) (cadr x))$/;"	f
member3	tool.lisp	/^(defun member3 (x) (nth 2 x))$/;"	f
member4	tool.lisp	/^(defun member4 (x) (nth 3 x))$/;"	f
member5	tool.lisp	/^(defun member5 (x) (nth 4 x))$/;"	f
member6	tool.lisp	/^(defun member6 (x) (nth 5 x))$/;"	f
member7	tool.lisp	/^(defun member7 (x) (nth 6 x))$/;"	f
member8	tool.lisp	/^(defun member8 (x) (nth 7 x))$/;"	f
member9	tool.lisp	/^(defun member9 (x) (nth 8 x))$/;"	f
merge-matches	tool.lisp	/^(defun merge-matches (m m*)$/;"	f
merge-matches*	oscar.lisp	/^(defun merge-matches* (m1 m2)$/;"	f
merge-sequential-matches	oscar.lisp	/^(defun merge-sequential-matches (m m*)$/;"	f
merge-unifiers*	oscar.lisp	/^(defun merge-unifiers* (u1 u2)$/;"	f
meter	tool.lisp	/^(defun meter (&rest funs)$/;"	f
meter-all	tool.lisp	/^(defun meter-all ()$/;"	f
metered-call	tool.lisp	/^(defmacro metered-call (fun def)$/;"	f
mgu	oscar.lisp	/^(defun mgu (x y vars)$/;"	f
mgu-list	oscar.lisp	/^(defun mgu-list (x y vars)$/;"	f
minimal-safe-arguments	hypergraph.lisp	/^(defun minimal-safe-arguments (sigma  DL indent)$/;"	f
minimal-subsets	tool.lisp	/^(defun minimal-subsets (X P)$/;"	f
minimum	tool.lisp	/^(defun minimum (X) (apply #'min X))$/;"	f
minimum0	tool.lisp	/^(defun minimum0 (X) (if X (apply #'min X) 0.0))$/;"	f
modus-ponens1	rule.lisp	/^(defun modus-ponens1 (c depth ip)$/;"	f
modus-ponens2	rule.lisp	/^(defun modus-ponens2 (c depth ip)$/;"	f
modus-tollens1	rule.lisp	/^(defun modus-tollens1 (c depth ip)$/;"	f
modus-tollens2	rule.lisp	/^(defun modus-tollens2 (c depth ip)$/;"	f
monitor-assignment-tree	oscar.lisp	/^(defun monitor-assignment-tree (x) (ignore x))$/;"	f
my-paths-from	tool.lisp	/^(defun my-paths-from (f g &optional functions path paths)$/;"	f
my-who-calls	tool.lisp	/^(defun my-who-calls (f)$/;"	f
named-decimal-number	tool.lisp	/^(defun named-decimal-number (string)$/;"	f
named-integer	tool.lisp	/^(defun named-integer (s)$/;"	f
neg	syntax.lisp	/^(defun neg (p)$/;"	f
neg-EG	rule.lisp	/^(defun neg-EG (c depth ip)$/;"	f
neg-UG	rule.lisp	/^(defun neg-UG (c depth ip)$/;"	f
neg-at-elimination	perception-cause.lisp	/^(def-forwards-reason neg-at-elimination$/;"	f
neg-at-intro	perception-cause.lisp	/^(def-backwards-reason neg-at-intro$/;"	f
neg-at-intro2	perception-cause.lisp	/^(def-backwards-reason neg-at-intro2$/;"	f
neg-bicondit-simp	rule.lisp	/^(defun neg-bicondit-simp (c depth ip)$/;"	f
neg-condit	rule.lisp	/^(defun neg-condit (c depth ip)$/;"	f
neg-disj	rule.lisp	/^(defun neg-disj (c depth ip)$/;"	f
neg-elim	rule.lisp	/^(defun neg-elim (c depth ip)$/;"	f
neg-in	rule.lisp	/^(defun neg-in (P)$/;"	f
neg-intro	rule.lisp	/^(defun neg-intro (interest depth priority)$/;"	f
negand	syntax.lisp	/^(defmacro negand (p)$/;"	f
negationp	syntax.lisp	/^(defun negationp (p)$/;"	f
nf	oscar.lisp	/^(defun nf (n)$/;"	f
ni-unifier	oscar.lisp	/^(defun ni-unifier (n m)$/;"	f
nodes-for	oscar.lisp	/^(defun nodes-for (formula)$/;"	f
non-circular	oscar.lisp	/^(defun non-circular (sequent ancestors)$/;"	f
non-reductio-interest-supposition	oscar.lisp	/^(defun non-reductio-interest-supposition (interest &optional nodes interests)$/;"	f
not-alive-elimination	perception-cause.lisp	/^(def-forwards-reason not-alive-elimination$/;"	f
not-alive-introduction	perception-cause.lisp	/^(def-backwards-reason not-alive-introduction$/;"	f
not-dead-elimination	perception-cause.lisp	/^(def-forwards-reason not-dead-elimination$/;"	f
not-dead-introduction	perception-cause.lisp	/^(def-backwards-reason not-dead-introduction$/;"	f
not-strictly-relevant-nodes	oscar.lisp	/^(defun not-strictly-relevant-nodes ()$/;"	f
notational-variant	oscar.lisp	/^(defun notational-variant (p q &optional vars)$/;"	f
nseq	tool.lisp	/^(defun nseq (n)$/;"	f
nseq<	tool.lisp	/^(defun nseq< (n)$/;"	f
number-of	tool.lisp	/^(defun number-of (X F)$/;"	f
number-of-occurrences	tool.lisp	/^(defun number-of-occurrences (x s)$/;"	f
o-occur	reason.lisp	/^(defun o-occur (x s &key (test 'eq))$/;"	f
o-occur*	reason.lisp	/^(defun o-occur* (x s &key (test 'eq))$/;"	f
o-occur+	reason.lisp	/^(defun o-occur+ (x s &key (test 'eq))$/;"	f
o-occur++	reason.lisp	/^(defun o-occur++ (x s &key (test 'eq))$/;"	f
occur	tool.lisp	/^(defun occur (x s &key (test 'eq))$/;"	f
occur*	tool.lisp	/^(defun occur* (x s &key (test 'eq))$/;"	f
occur-quoted	reason.lisp	/^(defun occur-quoted (x s &key (test 'eq))$/;"	f
occur-unquoted	reason.lisp	/^(defun occur-unquoted (x s &key (test 'eq))$/;"	f
occur1	tool.lisp	/^(defun occur1 (x s &key (test 'eq))$/;"	f
occurs-conjunctively-with	rule.lisp	/^(defun occurs-conjunctively-with (x y P)$/;"	f
occurs-disjunctively-with	rule.lisp	/^(defun occurs-disjunctively-with (x y P)$/;"	f
occurs-with	syntax.lisp	/^(defun occurs-with (x y P)$/;"	f
one-one-match	oscar.lisp	/^(defun one-one-match (p q p-vars q-vars)$/;"	f
order	tool.lisp	/^(defun order (X R)$/;"	f
order-1	tool.lisp	/^(defun order-1 (x y) (< (mem1 x) (mem1 y)))$/;"	f
order-2	tool.lisp	/^(defun order-2 (x y) (< (mem2 x) (mem2 y)))$/;"	f
order-3	tool.lisp	/^(defun order-3 (x y) (< (mem3 x) (mem3 y)))$/;"	f
order-4	tool.lisp	/^(defun order-4 (x y) (< (mem4 x) (mem4 y)))$/;"	f
ordered-insert	tool.lisp	/^(defun ordered-insert (x queue R)$/;"	f
p-princ	tool.lisp	/^(defun p-princ (x)$/;"	f
p-print	tool.lisp	/^(defun p-print (x &optional indent)$/;"	f
p-print-list	tool.lisp	/^(defun p-print-list (L &optional (n 1) (indent-depth 0))$/;"	f
package-symbols	tool.lisp	/^(defun package-symbols (&optional pkg)$/;"	f
parallelize-match	oscar.lisp	/^(defun parallelize-match (sm vars)$/;"	f
parameter-test	tool.lisp	/^(defmacro parameter-test (A param prog)$/;"	f
parse	syntax.lisp	/^(defun parse (s variables)$/;"	f
parse-arithmetical-formula	reason.lisp	/^(defun parse-arithmetical-formula (p)$/;"	f
pause	tool.lisp	/^(defun pause ()$/;"	f
pause-flag-off	tool.lisp	/^(defun pause-flag-off () (setq pause-flag nil))$/;"	f
pause-flag-on	tool.lisp	/^(defun pause-flag-on (&optional x)$/;"	f
pause-graphics	oscar.lisp	/^(defun pause-graphics ())$/;"	f
pause-off	oscar.lisp	/^(defun pause-off () (setf *pause* nil))$/;"	f
pause-on	oscar.lisp	/^(defun pause-on () (setf *pause* t))$/;"	f
percept-preference	oscar.lisp	/^(defun percept-preference (percept)$/;"	f
permutations	oscar.lisp	/^(defun permutations (X)$/;"	f
pl	tool.lisp	/^(defun pl ()$/;"	f
potent-suppositions	oscar.lisp	/^(defun potent-suppositions (NRS RA)$/;"	f
powerset	tool.lisp	/^(defun powerset (X)$/;"	f
pp	tool.lisp	/^(defmacro pp (f) `(let ((pv *print-level*)$/;"	f
pranc-to-string	oscar.lisp	/^(defun pranc-to-string (x) (declare (ignore x)))$/;"	f
predicationp	syntax.lisp	/^(defun predicationp (p)$/;"	f
premise-code	oscar.lisp	/^(defun premise-code (P variables)$/;"	f
premise-code*	oscar.lisp	/^(defun premise-code* (P variables descriptor)$/;"	f
premise-hypernode-specifier	oscar.lisp	/^(defun premise-hypernode-specifier (premise)$/;"	f
premise-preference	oscar.lisp	/^(defun premise-preference (premise)$/;"	f
pretty	syntax.lisp	/^(defun pretty (p)$/;"	f
pretty-cons	syntax.lisp	/^(defun pretty-cons (x)$/;"	f
princ-list	tool.lisp	/^(defun princ-list (L)$/;"	f
princ-sequent-set	tool.lisp	/^(defun princ-sequent-set (X &optional stream)$/;"	f
princ-set	tool.lisp	/^(defun princ-set (X &optional stream)$/;"	f
princ-sigma	hypergraph.lisp	/^(defun princ-sigma (sigma)$/;"	f
prinp	tool.lisp	/^(defun prinp (P &optional stream)$/;"	f
prinp-sequent	tool.lisp	/^(defun prinp-sequent (X &optional stream)$/;"	f
prinp-test	oscar.lisp	/^(defun prinp-test (test)$/;"	f
print-argument	argument.lisp	/^(defun print-argument (x stream depth)$/;"	f
print-argument-relations	argument.lisp	/^(defun print-argument-relations (arg &optional (arguments *arguments*) (depth 0))$/;"	f
print-b-premise	oscar.lisp	/^(defun print-b-premise (premise stream depth)$/;"	f
print-c-list	oscar.lisp	/^(defun print-c-list (x stream depth)$/;"	f
print-d-node	oscar.lisp	/^(defun print-d-node (x stream depth)$/;"	f
print-desire	oscar.lisp	/^(defun print-desire (desire stream depth)$/;"	f
print-f-premise	oscar.lisp	/^(defun print-f-premise (premise stream depth)$/;"	f
print-formatted-argument	argument.lisp	/^(defun print-formatted-argument (nodes arg &optional fw)$/;"	f
print-goal	oscar.lisp	/^(defun print-goal (goal stream depth)$/;"	f
print-hyper-defeat-link	oscar.lisp	/^(defun print-hyper-defeat-link (x stream depth)$/;"	f
print-hyperlink	oscar.lisp	/^(defun print-hyperlink (x stream depth)$/;"	f
print-hypernode	hypergraph.lisp	/^(defun print-hypernode (x stream depth)$/;"	f
print-i-list	oscar.lisp	/^(defun print-i-list (x stream depth)$/;"	f
print-inference-queue-node	oscar.lisp	/^(defun print-inference-queue-node (x stream depth)$/;"	f
print-instantiated-premise	oscar.lisp	/^(defun print-instantiated-premise (x stream depth)$/;"	f
print-interest	oscar.lisp	/^(defun print-interest (x stream depth)$/;"	f
print-interest-link	oscar.lisp	/^(defun print-interest-link (x stream depth)$/;"	f
print-interest-scheme	oscar.lisp	/^(defun print-interest-scheme (x stream depth)$/;"	f
print-list	tool.lisp	/^(defun print-list (L &optional (n 1) (indent-depth 0) stream)$/;"	f
print-percept	oscar.lisp	/^(defun print-percept (percept stream depth)$/;"	f
print-premise	problem.lisp	/^(defun print-premise (P)$/;"	f
print-pretty	tool.lisp	/^(defun print-pretty (x &optional stream)$/;"	f
print-query	oscar.lisp	/^(defun print-query (x stream depth)$/;"	f
print-reason	oscar.lisp	/^(defun print-reason (x stream depth)$/;"	f
print-sequent	oscar.lisp	/^(defun print-sequent (S &optional stream)$/;"	f
print-supposition	argument.lisp	/^(defun print-supposition (sup indent-value &optional fw)$/;"	f
print-undefeated-degrees-of-support	oscar.lisp	/^(defun print-undefeated-degrees-of-support ()$/;"	f
problem-strings	problem.lisp	/^(defun problem-strings (set-string)$/;"	f
process-unprocessed-interest	oscar.lisp	/^(defun process-unprocessed-interest (interest)$/;"	f
process-unprocessed-node	oscar.lisp	/^(defun process-unprocessed-node (node proof-nodes enabling-interests)$/;"	f
processed-c-list-for	oscar.lisp	/^(defun processed-c-list-for (formula)$/;"	f
processed-nodes-for	oscar.lisp	/^(defun processed-nodes-for (formula)$/;"	f
projectible	perception-cause.lisp	/^(defun projectible (p)$/;"	f
proof-off	oscar.lisp	/^(defun proof-off () (setf *proofs?* nil))$/;"	f
proof-on	oscar.lisp	/^(defun proof-on () (setf *proofs?* t))$/;"	f
proper-subset	tool.lisp	/^(defun proper-subset (X Y)$/;"	f
pull	tool.lisp	/^(defmacro pull (x s)$/;"	f
pursue-c-list-for	oscar.lisp	/^(defun pursue-c-list-for (formula profile d-node)$/;"	f
pursue-c-lists-for	oscar.lisp	/^(defun pursue-c-lists-for (formula profile term-list variables d-node)$/;"	f
pursue-d-node-for	oscar.lisp	/^(defun pursue-d-node-for (profile d-node)$/;"	f
pursue-i-lists-for	oscar.lisp	/^(defun pursue-i-lists-for (formula profile term-list variables d-node)$/;"	f
q-matrix	syntax.lisp	/^(defun q-matrix (p) (mem3 p))$/;"	f
q-variable	syntax.lisp	/^(defun q-variable (p) (mem2 p))$/;"	f
quantifiers-matrix	syntax.lisp	/^(defun quantifiers-matrix (p)$/;"	f
query	oscar.lisp	/^(defun query (n)$/;"	f
query-preference	oscar.lisp	/^(defun query-preference (query)$/;"	f
queue-defeater-supposition	oscar.lisp	/^(defun queue-defeater-supposition (sup)$/;"	f
queue-desire	oscar.lisp	/^(defun queue-desire (desire)$/;"	f
queue-for-inference	oscar.lisp	/^(defun queue-for-inference (node)$/;"	f
queue-interest	oscar.lisp	/^(defun queue-interest (interest priority)$/;"	f
queue-non-reductio-defeater-supposition	oscar.lisp	/^(defun queue-non-reductio-defeater-supposition (supposition)$/;"	f
queue-non-reductio-supposition	oscar.lisp	/^(defun queue-non-reductio-supposition$/;"	f
queue-percept	oscar.lisp	/^(defun queue-percept (percept)$/;"	f
queue-premise	oscar.lisp	/^(defun queue-premise (premise)$/;"	f
queue-query-for-interest	oscar.lisp	/^(defun queue-query-for-interest (query)$/;"	f
queue-supposition	oscar.lisp	/^(defun queue-supposition (supposition instance-supposition e-vars discount-factor interest)$/;"	f
r-first	tool.lisp	/^(defun r-first (x R)$/;"	f
range	tool.lisp	/^(defun range (x) (remove-duplicates (mapcar #'cadr x) :test 'equal))$/;"	f
re-queue-interest	oscar.lisp	/^(defun re-queue-interest (link interest-priority interest degree)$/;"	f
readopt-interest	oscar.lisp	/^(defun readopt-interest (interest defeated-links)$/;"	f
real-ratio	tool.lisp	/^(defun real-ratio (m n)$/;"	f
real-root	tool.lisp	/^(defun real-root (m n)$/;"	f
reason	oscar.lisp	/^(defun reason (name)$/;"	f
reason-backwards-from	oscar.lisp	/^(defun reason-backwards-from (interest priority depth)$/;"	f
reason-backwards-from-?-query	oscar.lisp	/^(defun reason-backwards-from-?-query (query priority depth)$/;"	f
reason-backwards-from-dominant-reason-nodes	oscar.lisp	/^(defun reason-backwards-from-dominant-reason-nodes (interest priority depth d-node)$/;"	f
reason-backwards-from-query	oscar.lisp	/^(defun reason-backwards-from-query (query priority  depth)$/;"	f
reason-backwards-from-reason-node	oscar.lisp	/^(defun reason-backwards-from-reason-node (interest priority depth d-node)$/;"	f
reason-backwards-from-simple-query	oscar.lisp	/^(defun reason-backwards-from-simple-query (query priority depth)$/;"	f
reason-backwards-from-whether-query	oscar.lisp	/^(defun reason-backwards-from-whether-query (query priority depth)$/;"	f
reason-code	oscar.lisp	/^(defun reason-code (P variables)$/;"	f
reason-code*	oscar.lisp	/^(defun reason-code* (P variables descriptor)$/;"	f
reason-defeasibly-from-dominant-premise-nodes	oscar.lisp	/^(defun reason-defeasibly-from-dominant-premise-nodes (node d-node)$/;"	f
reason-defeasibly-from-instantiated-premises	oscar.lisp	/^(defun reason-defeasibly-from-instantiated-premises (node d-node)$/;"	f
reason-degenerately-backwards-from-dominant-reason-nodes	oscar.lisp	/^(defun reason-degenerately-backwards-from-dominant-reason-nodes$/;"	f
reason-degenerately-backwards-from-reason-node	oscar.lisp	/^(defun reason-degenerately-backwards-from-reason-node (interest priority depth d-node)$/;"	f
reason-forwards-from	oscar.lisp	/^(defun reason-forwards-from (node depth)$/;"	f
reason-from-current-interest-scheme	oscar.lisp	/^(defun reason-from-current-interest-scheme (node d-node old-degree depth)$/;"	f
reason-from-dominant-interest-schemes	oscar.lisp	/^(defun reason-from-dominant-interest-schemes (node d-node old-degree depth)$/;"	f
reason-from-dominant-premise-nodes	oscar.lisp	/^(defun reason-from-dominant-premise-nodes (node d-node depth)$/;"	f
reason-from-instantiated-premises	oscar.lisp	/^(defun reason-from-instantiated-premises (node d-node depth)$/;"	f
reason-from-interest-scheme	oscar.lisp	/^(defun reason-from-interest-scheme (node priority depth is)$/;"	f
reason-from-subsidiary-c-lists	oscar.lisp	/^(defun reason-from-subsidiary-c-lists (d-node depth ip)$/;"	f
reason-instantiator	reason.lisp	/^(defun reason-instantiator (P variables)$/;"	f
reason-instantiator-	reason.lisp	/^(defun reason-instantiator- (P variables)$/;"	f
reason-ips	oscar.lisp	/^(defun reason-ips (reason)$/;"	f
reason-iss	oscar.lisp	/^(defun reason-iss (reason)$/;"	f
reason-substantively-from-backwards-reason	oscar.lisp	/^(defun reason-substantively-from-backwards-reason (reason interest depth priority)$/;"	f
reason-substantively-from-first-instantiated-premise	oscar.lisp	/^(defun reason-substantively-from-first-instantiated-premise (node depth ip)$/;"	f
reason-substantively-from-non-initial-instantiated-premise	oscar.lisp	/^(defun reason-substantively-from-non-initial-instantiated-premise$/;"	f
rebuts	oscar.lisp	/^(defun rebuts (sequent1 sequent2)$/;"	f
recompute-priorities	oscar.lisp	/^(defun recompute-priorities (new-beliefs new-retractions altered-interests altered-queries)$/;"	f
recompute-reductio-ancestors	oscar.lisp	/^(defun recompute-reductio-ancestors (node sup)$/;"	f
record-dependencies	hypergraph.lisp	/^(defun record-dependencies (link sigma indent)$/;"	f
record-query-answers	oscar.lisp	/^(defun record-query-answers (link)$/;"	f
rectify-backwards-premises	reason.lisp	/^(defun rectify-backwards-premises (premise-list variables &optional c-vars)$/;"	f
rectify-backwards-premises*	problem.lisp	/^(defun rectify-backwards-premises* (premise-list variables)$/;"	f
rectify-binding	oscar.lisp	/^(defun rectify-binding (binding0 unifier ip)$/;"	f
rectify-conclusions-list	reason.lisp	/^(defun rectify-conclusions-list (conclusions default)$/;"	f
rectify-formula-condition	reason.lisp	/^(defun rectify-formula-condition (formula)$/;"	f
rectify-forwards-premises	reason.lisp	/^(defun rectify-forwards-premises (premise-list variables &optional c-vars)$/;"	f
rectify-forwards-premises*	problem.lisp	/^(defun rectify-forwards-premises* (premise-list variables)$/;"	f
rectify-reason-condition	reason.lisp	/^(defun rectify-reason-condition (formula premise-variables)$/;"	f
rectify-strength	reason.lisp	/^(defun rectify-strength (formula premise-variables)$/;"	f
recursively-compute-hypernode-ancestors	oscar.lisp	/^(defun recursively-compute-hypernode-ancestors (node ancestors)$/;"	f
recursively-compute-nearest-defeasible-ancestors	oscar.lisp	/^(defun recursively-compute-nearest-defeasible-ancestors$/;"	f
redefine-constant	tool.lisp	/^(defmacro redefine-constant (x val)$/;"	f
reductio-off	oscar.lisp	/^(defun reductio-off () (setf *use-reductio* nil))$/;"	f
reductio-on	oscar.lisp	/^(defun reductio-on () (setf *use-reductio* t) (setf *use-logic* t))$/;"	f
reductio-supposition	oscar.lisp	/^(defun reductio-supposition (node) (eq (hypernode-justification node) :reductio-supposition))$/;"	f
reductio-unifier	oscar.lisp	/^(defun reductio-unifier (n m)$/;"	f
refined-profile	reason.lisp	/^(defun refined-profile (profile)$/;"	f
refined-profile*	reason.lisp	/^(defun refined-profile* (profile n)$/;"	f
reform	syntax.lisp	/^(defun reform (s &optional variables)$/;"	f
reform-	syntax.lisp	/^(defun reform- (s variables)$/;"	f
reform-forwards-premise-list	problem.lisp	/^(defun reform-forwards-premise-list (string)$/;"	f
reform-if-string	syntax.lisp	/^(defun reform-if-string (p &optional variables)$/;"	f
reform-list	problem.lisp	/^(defun reform-list (string)$/;"	f
relevant-nodes	oscar.lisp	/^(defun relevant-nodes (node &optional nodes-used)$/;"	f
remove-double-negation	oscar.lisp	/^(defun remove-double-negation (P)$/;"	f
remove-duplicates=	tool.lisp	/^(defun remove-duplicates= (x)$/;"	f
remove-if-equal	tool.lisp	/^(defun remove-if-equal (x y)$/;"	f
remove-package	tool.lisp	/^(defun remove-package (&optional pkg)$/;"	f
replace-item-in-list	tool.lisp	/^(defun replace-item-in-list (x y S)$/;"	f
rerun	oscar.lisp	/^(defun rerun (&rest args)$/;"	f
reset-memories	hypergraph.lisp	/^(defun reset-memories (link)$/;"	f
reset-meter	tool.lisp	/^(defun reset-meter (&rest funs)$/;"	f
reset-meter-entry	tool.lisp	/^(defun reset-meter-entry (fun)$/;"	f
resolve-variable-conflicts	syntax.lisp	/^(defun resolve-variable-conflicts (p &optional variables (reset-counter? t))$/;"	f
retrieved-interest-priority	oscar.lisp	/^(defun retrieved-interest-priority (preference complexity)$/;"	f
reverse-match	oscar.lisp	/^(defun reverse-match (m)$/;"	f
rewrite-u-vars	oscar.lisp	/^(defun rewrite-u-vars (formula vars)$/;"	f
right-branches	oscar.lisp	/^(defun right-branches (interest)$/;"	f
run	oscar.lisp	/^(defun run (&rest args)$/;"	f
run-reasoning-problem	oscar.lisp	/^(defun run-reasoning-problem (P)$/;"	f
run-reasoning-problem*	oscar.lisp	/^(defun run-reasoning-problem* (P)$/;"	f
s-find	tool.lisp	/^(defun s-find (x s)$/;"	f
safe-support-path	hypergraph.lisp	/^(defun safe-support-path (path sigma DL)$/;"	f
search-d-node-interests	oscar.lisp	/^(defun search-d-node-interests (formula d-node)$/;"	f
search-d-nodes	oscar.lisp	/^(defun search-d-nodes (formula d-node)$/;"	f
seq-subst	tool.lisp	/^(defun seq-subst (new old s)$/;"	f
sequent-complexity	oscar.lisp	/^(defun sequent-complexity (sequent)$/;"	f
sequent-formula	syntax.lisp	/^(defun sequent-formula (sequent)$/;"	f
sequent-supposition	syntax.lisp	/^(defun sequent-supposition (sequent)$/;"	f
sequential-sublis	oscar.lisp	/^(defun sequential-sublis (m X)$/;"	f
set-conclusions-function	rule.lisp	/^(defun set-conclusions-function (reason)$/;"	f
set-def-binding	oscar.lisp	/^(defun set-def-binding (def-instantiator var binding)$/;"	f
set-match	tool.lisp	/^(defun set-match (patterns data vars)$/;"	f
set-mgu	oscar.lisp	/^(defun set-mgu (X Y vars)$/;"	f
set-prinp	tool.lisp	/^(defun set-prinp (X &optional stream)$/;"	f
set-unifier	oscar.lisp	/^(defun set-unifier (X Y X-vars Y-vars)$/;"	f
setdifference	tool.lisp	/^(defun setdifference (x y) (set-difference x y :test 'equal))$/;"	f
show-all-meter	tool.lisp	/^(defun show-all-meter ()$/;"	f
show-arguments	argument.lisp	/^(defun show-arguments (&optional nodes)$/;"	f
show-callers	tool.lisp	/^(defun show-callers (f &optional (max-depth 5))$/;"	f
show-d-node	oscar.lisp	/^(defun show-d-node (n)$/;"	f
show-history	tool.lisp	/^(defun show-history (&optional fun)$/;"	f
show-hypernode	oscar.lisp	/^(defun show-hypernode (n)$/;"	f
show-interest	oscar.lisp	/^(defun show-interest (n)$/;"	f
show-meter-entry	tool.lisp	/^(defun show-meter-entry (fun count time avg)$/;"	f
show-queries	oscar.lisp	/^(defun show-queries ()$/;"	f
show-query	oscar.lisp	/^(defun show-query (Q)$/;"	f
show-reason	oscar.lisp	/^(defun show-reason (reason)$/;"	f
show-symbol-bindings	tool.lisp	/^(defun show-symbol-bindings (&optional pkg)$/;"	f
sigma-defeat-loop	hypergraph.lisp	/^(defun sigma-defeat-loop (d-loop sigma)$/;"	f
simp	rule.lisp	/^(defun simp (c depth ip)$/;"	f
simple-backwards-formula-condition	reason.lisp	/^(defun simple-backwards-formula-condition (formula premise-variables)$/;"	f
skolem-free	oscar.lisp	/^(defun skolem-free (P)$/;"	f
skolem-function	oscar.lisp	/^(defun skolem-function (x)$/;"	f
skolem-functions	oscar.lisp	/^(defun skolem-functions (p)$/;"	f
speak-text	oscar.lisp	/^(defun speak-text (x) (declare (ignore x)))$/;"	f
splice	tool.lisp	/^(defun splice (x n y)$/;"	f
split-hypergraph	hypergraph.lisp	/^(defun split-hypergraph (link &optional sigma (indent 0))$/;"	f
stepper	tool.lisp	/^(defmacro stepper (form)$/;"	f
store-backwards-reason	oscar.lisp	/^(defun store-backwards-reason (reason profile)$/;"	f
store-backwards-reason-at-d-node	oscar.lisp	/^(defun store-backwards-reason-at-d-node (reason d-node)$/;"	f
store-backwards-reason-at-new-d-node	oscar.lisp	/^(defun store-backwards-reason-at-new-d-node (reason d-node test)$/;"	f
store-forwards-reason	oscar.lisp	/^(defun store-forwards-reason (reason premise profile)$/;"	f
store-forwards-reason-at-d-node	oscar.lisp	/^(defun store-forwards-reason-at-d-node (reason premise d-node)$/;"	f
store-forwards-reason-at-new-d-node	oscar.lisp	/^(defun store-forwards-reason-at-new-d-node (reason premise d-node test)$/;"	f
store-hypernode	oscar.lisp	/^(defun store-hypernode (node formula)$/;"	f
store-hypernode-at-d-node	oscar.lisp	/^(defun store-hypernode-at-d-node (node term-list dn)$/;"	f
store-hypernode-at-new-d-node	oscar.lisp	/^(defun store-hypernode-at-new-d-node (node term-list d-node test)$/;"	f
store-hypernode-with-c-list	oscar.lisp	/^(defun store-hypernode-with-c-list (node formula c-list)$/;"	f
store-instantiated-premise	oscar.lisp	/^(defun store-instantiated-premise$/;"	f
store-instantiated-premise-at-d-node	oscar.lisp	/^(defun store-instantiated-premise-at-d-node$/;"	f
store-instantiated-premise-at-new-d-node	oscar.lisp	/^(defun store-instantiated-premise-at-new-d-node$/;"	f
store-interest	oscar.lisp	/^(defun store-interest (interest &optional i-list)$/;"	f
store-interest-at-d-node	oscar.lisp	/^(defun store-interest-at-d-node (interest term-list dn)$/;"	f
store-interest-at-new-d-node	oscar.lisp	/^(defun store-interest-at-new-d-node (interest term-list d-node test)$/;"	f
store-interest-record	oscar.lisp	/^(defun store-interest-record (in record)$/;"	f
store-interest-scheme	oscar.lisp	/^(defun store-interest-scheme (interest-scheme profile d-node)$/;"	f
store-interest-scheme-at-d-node	oscar.lisp	/^(defun store-interest-scheme-at-d-node (interest-scheme d-node)$/;"	f
store-interest-scheme-at-new-d-node	oscar.lisp	/^(defun store-interest-scheme-at-new-d-node (interest-scheme  d-node test)$/;"	f
store-interest-with-c-lists	oscar.lisp	/^(defun store-interest-with-c-lists (interest c-lists)$/;"	f
store-processed-node	oscar.lisp	/^(defun store-processed-node (node)$/;"	f
strict-arithmetical-inequality	perception-cause.lisp	/^(def-backwards-reason strict-arithmetical-inequality$/;"	f
strictly-base-reductio-supposition	oscar.lisp	/^(defun strictly-base-reductio-supposition (N)$/;"	f
strictly-relevant-nodes	oscar.lisp	/^(defun strictly-relevant-nodes ()$/;"	f
string-length	tool.lisp	/^(defun string-length (s)$/;"	f
string-list	problem.lisp	/^(defun string-list (string)$/;"	f
string-rep	tool.lisp	/^(defun string-rep (n) (write-to-string n))$/;"	f
strongly-discharging-node	oscar.lisp	/^(defun strongly-discharging-node (dn interest proof-nodes enabling-interests)$/;"	f
subformula1	syntax.lisp	/^(defun subformula1 (p) (mem2 p))$/;"	f
subformula2	syntax.lisp	/^(defun subformula2 (p) (mem3 p))$/;"	f
sublis-in-tree	tool.lisp	/^(defun sublis-in-tree (m tree &key test)$/;"	f
sublis=	tool.lisp	/^(defun sublis= (m x)$/;"	f
subset	tool.lisp	/^(defun subset (f l)$/;"	f
subsetp*	oscar.lisp	/^(defun subsetp* (X Y)$/;"	f
subsetp=	tool.lisp	/^(defun subsetp= (X Y)$/;"	f
subsidiary-hyperlinks-for-link	hypergraph.lisp	/^(defun subsidiary-hyperlinks-for-link (link sigma path DL indent)$/;"	f
subsidiary-hyperlinks-for-node	hypergraph.lisp	/^(defun subsidiary-hyperlinks-for-node (node sigma path DL indent)$/;"	f
subst*	tool.lisp	/^(defun subst* (a b c &key (test 'eq))$/;"	f
substructures	tool.lisp	/^(defun substructures (s)$/;"	f
subsumed	oscar.lisp	/^(defun subsumed (node basis sequent NDA non-reductio-supposition rule binding d-node)$/;"	f
subsumes	oscar.lisp	/^(defun subsumes (sequent1 sequent2)$/;"	f
subsumes-basis	oscar.lisp	/^(defun subsumes-basis (X Y)$/;"	f
subsuming-supposition	oscar.lisp	/^(defun subsuming-supposition (supposition)$/;"	f
sup-order	argument.lisp	/^(defun sup-order (n m)$/;"	f
supposition-variables	oscar.lisp	/^(defun supposition-variables (sup)$/;"	f
symbol	reason.lisp	/^(def-backwards-reason symbol$/;"	f
symbol	reason.lisp	/^(def-forwards-reason symbol$/;"	f
temporally-projectible	perception-cause.lisp	/^(defun temporally-projectible (p)$/;"	f
term-lists	reason.lisp	/^(defun term-lists (P vars descriptor)$/;"	f
terms-of	syntax.lisp	/^(defun terms-of (p)$/;"	f
test	oscar.lisp	/^(defun test (&rest rest)$/;"	f
test&compare	oscar.lisp	/^(defun test&compare ()$/;"	f
test&load	oscar.lisp	/^(defun test&load ()$/;"	f
test*	oscar.lisp	/^(defun test* (&optional n)$/;"	f
think	oscar.lisp	/^(defun think ()$/;"	f
think-or-die	oscar.lisp	/^(defun think-or-die ()$/;"	f
tilde	syntax.lisp	/^(defun tilde (p) (list '~ p))$/;"	f
time-dif	tool.lisp	/^(defun time-dif (t1 t2)$/;"	f
trace-from	oscar.lisp	/^(defun trace-from (n) (setf *start-trace* n *display?* nil *trace* nil))$/;"	f
trace-function	tool.lisp	/^(defun trace-function (fun)$/;"	f
trace-functions	tool.lisp	/^(defun trace-functions (funs)$/;"	f
trace-off	oscar.lisp	/^(defun trace-off () (setf *trace* nil *start-trace* nil))$/;"	f
trace-on	oscar.lisp	/^(defun trace-on () (setf *display?* t) (setf *trace* t))$/;"	f
tree-agreement	tool.lisp	/^(defun tree-agreement (t1 t2)$/;"	f
trim-comments	problem.lisp	/^(defun trim-comments (string)$/;"	f
try	oscar.lisp	/^(defun try (&optional x)$/;"	f
try-interest	oscar.lisp	/^(defun try-interest (&optional n)$/;"	f
try-to-perform	oscar.lisp	/^(defun try-to-perform (act )$/;"	f
turn-on-metering	tool.lisp	/^(defun turn-on-metering (fun)$/;"	f
u-closure	syntax.lisp	/^(defun u-closure (p X)$/;"	f
u-gen	syntax.lisp	/^(defun u-gen (x p) (list 'all x p))$/;"	f
u-genp	syntax.lisp	/^(defun u-genp (p)$/;"	f
u-matrix	syntax.lisp	/^(defun u-matrix (p)$/;"	f
u-vars	syntax.lisp	/^(defun u-vars (p)$/;"	f
ultimate-target	hypergraph.lisp	/^(defun ultimate-target (link)$/;"	f
unboundp	tool.lisp	/^(defun unboundp (x) (not (boundp x)))$/;"	f
uncalled-callers	tool.lisp	/^(defun uncalled-callers (function-list &key print order)$/;"	f
undercut1	syntax.lisp	/^(defmacro undercut1 (p)$/;"	f
undercut2	syntax.lisp	/^(defmacro undercut2 (p)$/;"	f
undercuts	oscar.lisp	/^(defun undercuts (sequent1 basis sequent2)$/;"	f
undercutterp	syntax.lisp	/^(defun undercutterp (p)$/;"	f
undercutters-for	reason.lisp	/^(defun undercutters-for (reason)$/;"	f
unifier	oscar.lisp	/^(defun unifier (p q p-vars q-vars)$/;"	f
unifier*	oscar.lisp	/^(defun unifier* (p q p-vars q-vars)$/;"	f
unify-list	reason.lisp	/^(defun unify-list (term-list vars unifier)$/;"	f
unify-premise-terms	reason.lisp	/^(defun unify-premise-terms (term-lists premise-variables vars unifier0)$/;"	f
unify-premise-terms*	reason.lisp	/^(defun unify-premise-terms* (term-lists vars unifier0)$/;"	f
unifying-nodes	oscar.lisp	/^(defun unifying-nodes (interest)$/;"	f
union=	tool.lisp	/^(defun union= (x y) (union x y :test 'equal))$/;"	f
unionimage	tool.lisp	/^(defmacro unionimage (K f)$/;"	f
unionimage+	tool.lisp	/^(defmacro unionimage+ (K f)$/;"	f
unionmapcar	tool.lisp	/^(defmacro unionmapcar (f A) `(apply 'append (mapcar, f ,A)))$/;"	f
unionmapcar	tool.lisp	/^(defun unionmapcar (f A) (apply 'append (mapcar f A)))$/;"	f
unionmapcar+	tool.lisp	/^(defmacro unionmapcar+ (f X)$/;"	f
unionmapcar+	tool.lisp	/^(defun unionmapcar+ (f X)$/;"	f
unionmapcar-	tool.lisp	/^(defmacro unionmapcar- (f X &key (test 'eq))$/;"	f
unionmapcar2=	tool.lisp	/^(defmacro unionmapcar2= (f X Y)$/;"	f
unionmapcar2=	tool.lisp	/^(defun unionmapcar2= (f X Y)$/;"	f
unionmapcar=	tool.lisp	/^(defmacro unionmapcar= (f X)$/;"	f
unionmapcar=	tool.lisp	/^(defun unionmapcar= (f X)$/;"	f
unmeter	tool.lisp	/^(defun unmeter (&rest funs)$/;"	f
untrace-funs	tool.lisp	/^(defun untrace-funs (funs)$/;"	f
update-beliefs	hypergraph.lisp	/^(defun update-beliefs ()$/;"	f
update-beliefs	oscar.lisp	/^(defun update-beliefs ()$/;"	f
update-environmental-input	oscar.lisp	/^(defun update-environmental-input ()$/;"	f
update-percepts	perception-cause.lisp	/^(defun update-percepts ()$/;"	f
validating-deductive-node	oscar.lisp	/^(defun validating-deductive-node (S deductive-rule?)$/;"	f
validating-node	oscar.lisp	/^(defun validating-node (interest degree binding)$/;"	f
value	tool.lisp	/^(defun value (assignment obj)$/;"	f
var-kind	oscar.lisp	/^(defun var-kind (var) (get var 'var-kind))$/;"	f
variable-correspondence	oscar.lisp	/^(defun variable-correspondence (P Q P-vars Q-vars terms)$/;"	f
verbose-off	tool.lisp	/^(defun verbose-off ()$/;"	f
verbose-on	tool.lisp	/^(defun verbose-on ()$/;"	f
warn-off	tool.lisp	/^(defun warn-off ()$/;"	f
warn-on	tool.lisp	/^(defun warn-on ()$/;"	f
whether-formula	syntax.lisp	/^(defun whether-formula (P)$/;"	f
whether-query-p	oscar.lisp	/^(defun whether-query-p (Q)$/;"	f
word-list	tool.lisp	/^(defun word-list (string)$/;"	f
~	hypergraph.lisp	/^(defun ~ (x y)$/;"	f
