{- Revision with emphasis on proofs -}

------------------------------------------------------------------------
-- The Agda standard library
--
-- AVL trees
------------------------------------------------------------------------

-- AVL trees are balanced binary search trees.

-- The search tree invariant is specified using the technique
-- described by Conor McBride in his talk "Pivotal pragmatism".

module Data.AVL2 where

module HEIGHT where
  open import Data.Fin using (Fin ; zero ; suc)
  open import Data.Nat.Base

  pattern 0# = zero
  pattern 1# = suc zero
  pattern ## = suc (suc ())
  
  infixl 6 _âŠ•_
    
  _âŠ•_ : Fin 2 â†’ â„• â†’ â„•
  0# âŠ• n = n
  1# âŠ• n = suc n
  ## âŠ• n

  _âŠ•_âŠ–1 : Fin 2 â†’ â„• â†’ â„•
  i âŠ• zero âŠ–1 = zero
  i âŠ• suc n âŠ–1 = i âŠ• n
 
  infix 4 _âˆ¼_âŠ”_
 
  -- If i âˆ¼ j âŠ” m, then the difference between i and j is at most 1,
  -- and the maximum of i and j is m. _âˆ¼_âŠ”_ is used to record the
  -- balance factor of the AVL trees, and also to ensure that the
  -- absolute value of the balance factor is never more than 1.
 
  data _âˆ¼_âŠ”_ : â„• â†’ â„• â†’ â„• â†’ Set where
    âˆ¼+ : âˆ€ {n} â†’     n âˆ¼ 1 + n âŠ” 1 + n
    âˆ¼0 : âˆ€ {n} â†’     n âˆ¼ n     âŠ” n
    âˆ¼- : âˆ€ {n} â†’ 1 + n âˆ¼ n     âŠ” 1 + n
 
  -- Some lemmas.
 
  maxâˆ¼ : âˆ€ {i j m} â†’ i âˆ¼ j âŠ” m â†’ m âˆ¼ i âŠ” m
  maxâˆ¼ âˆ¼+ = âˆ¼-
  maxâˆ¼ âˆ¼0 = âˆ¼0
  maxâˆ¼ âˆ¼- = âˆ¼0
 
  âˆ¼max : âˆ€ {i j m} â†’ i âˆ¼ j âŠ” m â†’ j âˆ¼ m âŠ” m
  âˆ¼max âˆ¼+ = âˆ¼0
  âˆ¼max âˆ¼0 = âˆ¼0
  âˆ¼max âˆ¼- = âˆ¼+


module ADDBOUNDS where

  data [_]âº {a} (A : Set a) : Set a where
    âŠ¥âº  : [ A ]âº
    [_] : (k : A) â†’ [ A ]âº
    âŠ¤âº  : [ A ]âº
   
  open import Relation.Binary
  open import Data.Unit
  open import Data.Empty
  open import Level using ( _âŠ”_ ; Lift ; lift )
  open Lift
   
  open StrictTotalOrder
 
  StrictTotalOrderâº : âˆ€ {a â„“â‚ â„“â‚‚} â†’ StrictTotalOrder a â„“â‚ â„“â‚‚ â†’ StrictTotalOrder a â„“â‚ â„“â‚‚
  StrictTotalOrderâº {a} {â„“â‚} {â„“â‚‚} sto = record { Carrier = [ Carrier sto ]âº ; _â‰ˆ_ = _â‰ˆâº_ ; _<_ = _<âº_ ; isStrictTotalOrder = IsStrictTotalOrderâº } where
  
    _â‰ˆâº_ : [ Carrier sto ]âº â†’ [ Carrier sto ]âº â†’ Set â„“â‚
    [ k ] â‰ˆâº [ kâ‚ ] = (_â‰ˆ_ sto k kâ‚)
    âŠ¥âº â‰ˆâº âŠ¥âº = Lift âŠ¤
    âŠ¤âº â‰ˆâº âŠ¤âº = Lift âŠ¤
    _  â‰ˆâº _  = Lift âŠ¥

    _<âº_ : [ Carrier sto ]âº â†’ [ Carrier sto ]âº â†’ Set â„“â‚‚
    âŠ¥âº    <âº [ _ ] = Lift âŠ¤
    âŠ¥âº    <âº âŠ¤âº    = Lift âŠ¤
    [ x ] <âº [ y ] = _<_ sto x y
    [ _ ] <âº âŠ¤âº    = Lift âŠ¤
    _     <âº _     = Lift âŠ¥

    IsStrictTotalOrderâº : IsStrictTotalOrder _â‰ˆâº_ _<âº_
    IsStrictTotalOrderâº = record { isEquivalence = IsEquivalenceâº ; trans = Î» {i} {j} {k} â†’ transâº {i} {j} {k} ; compare = compareâº ; <-resp-â‰ˆ = <-resp-â‰ˆâº } where
    
      IsEquivalenceâº : IsEquivalence _â‰ˆâº_
      IsEquivalenceâº = record { refl = Î» {x} â†’ reflâº {x} ; sym = Î» {i} {j} â†’ symâº {i} {j} ; trans = Î» {i} {j} {k} â†’ transâº {i} {j} {k} } where
     
        reflâº : Reflexive _â‰ˆâº_
        reflâº {âŠ¥âº} = lift tt
        reflâº {âŠ¤âº} = lift tt
        reflâº {[ k ]} = Eq.refl sto
     
        symâº : Symmetric _â‰ˆâº_
        symâº {âŠ¥âº}    {âŠ¥âº}    _         = lift tt
        symâº {âŠ¥âº}    {[ _ ]} (lift ())
        symâº {âŠ¥âº}    {âŠ¤âº}    (lift ())
        symâº {[ _ ]} {âŠ¥âº}    (lift ())
        symâº {[ _ ]} {[ _ ]}           = Eq.sym sto
        symâº {[ _ ]} {âŠ¤âº}    (lift ())
        symâº {âŠ¤âº}    {âŠ¥âº}    (lift ())
        symâº {âŠ¤âº}    {[ _ ]} (lift ())
        symâº {âŠ¤âº}    {âŠ¤âº}    _         = lift tt
     
        transâº : Transitive _â‰ˆâº_
        transâº {âŠ¥âº}     {âŠ¥âº}        {âŠ¥âº}      _         _         = lift tt
        transâº {âŠ¥âº}     {[ _ ]}               (lift ())
        transâº {âŠ¥âº}     {âŠ¤âº}                  (lift ())
        transâº {[ _ ]}  {âŠ¥âº}                  (lift ())
        transâº {[ _ ]}  {[ _ ]} {[ _ ]}                           = Eq.trans sto
        transâº {[ _ ]}  {âŠ¤âº}                  (lift ())
        transâº {âŠ¤âº}     {âŠ¥âº}                  (lift ())
        transâº {âŠ¤âº}     {[ _ ]}               (lift ())
        transâº {âŠ¤âº}     {âŠ¤âº}        {âŠ¤âº}      _         _         = lift tt
        transâº          {j = âŠ¥âº}    {[ _ ]}   _         (lift ())
        transâº          {j = âŠ¥âº}    {âŠ¤âº}      _         (lift ())
        transâº          {j = [ _ ]} {âŠ¥âº}      _         (lift ())
        transâº          {j = [ _ ]} {âŠ¤âº}      _         (lift ())
        transâº          {j = âŠ¤âº}    {âŠ¥âº}      _         (lift ())
        transâº          {j = âŠ¤âº}    {[ _ ]}   _         (lift ())

    
      transâº : Transitive _<âº_
      transâº {âŠ¥âº}    {âŠ¥âº}                    (lift ())
      transâº {âŠ¥âº}    {[ _ ]}     {[ _ ]}     _         _         = lift tt
      transâº {âŠ¥âº}    {[ _ ]}     {âŠ¤âº}        _         _         = lift tt
      transâº {[ _ ]} {âŠ¥âº}                    (lift ())
      transâº {[ _ ]} {[ _ ]}     {[ _ ]} = trans sto
      transâº {[ _ ]} {[ _ ]}     {âŠ¤âº}        _         _         = lift tt
      transâº {âŠ¤âº}    (lift ())
      transâº         {j = [ _ ]} {âŠ¥âº} _                (lift ())
      transâº         {j = âŠ¤âº}    {âŠ¥âº}        _         (lift ())
      transâº         {j = âŠ¤âº}    {[ _ ]}     _         (lift ())
      transâº         {j = âŠ¤âº}    {âŠ¤âº}        _         (lift ())
   
      compareâº : Trichotomous _â‰ˆâº_ _<âº_
      compareâº âŠ¥âº âŠ¥âº    = triâ‰ˆ lower     (lift tt) lower
      compareâº âŠ¥âº [ _ ] = tri< (lift tt) lower     lower
      compareâº âŠ¥âº âŠ¤âº    = tri< (lift tt) lower     lower
      compareâº [ _ ] âŠ¥âº = tri> lower     lower     (lift tt)
      compareâº [ x ] [ y ] = compare sto x y
      compareâº [ _ ] âŠ¤âº = tri< (lift tt) lower     lower
      compareâº âŠ¤âº âŠ¥âº    = tri> lower     lower     (lift tt)
      compareâº âŠ¤âº [ _ ] = tri> lower     lower     (lift tt)
      compareâº âŠ¤âº âŠ¤âº    = triâ‰ˆ lower     (lift tt) lower
   
      open import Data.Product
   
      <-resp-â‰ˆâº : _<âº_ Respectsâ‚‚ _â‰ˆâº_
      projâ‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {[ k ]} (lift ())
      projâ‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¤âº}    (lift ())
      projâ‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¥âº}    (lift ())
      projâ‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¤âº}    (lift ())
      projâ‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¥âº}    (lift ())
      projâ‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {[ k ]} (lift ())
      projâ‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¥âº}    y=z       x<y = x<y
      projâ‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¤âº}    y=z       x<y = x<y
      projâ‚ <-resp-â‰ˆâº {âŠ¥âº}    {[ y ]} {[ z ]} y=z       x<y = x<y
      projâ‚ <-resp-â‰ˆâº {âŠ¤âº}    {[ y ]} {[ z ]} y=z       x<y = x<y
      projâ‚ <-resp-â‰ˆâº {[ x ]} {[ y ]} {[ z ]}                     = projâ‚ (<-resp-â‰ˆ sto) {x} {y} {z}
      projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {[ k ]} (lift ())
      projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¤âº}    (lift ())
      projâ‚‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¥âº}    (lift ())
      projâ‚‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¤âº}    (lift ())
      projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¥âº}    (lift ())
      projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {[ k ]} (lift ())
      projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¥âº}    y=z       y<x = y<x
      projâ‚‚ <-resp-â‰ˆâº {âŠ¥âº}    {[ y ]} {[ z ]} y=z       y<x = y<x
      projâ‚‚ <-resp-â‰ˆâº {âŠ¤âº}    {[ y ]} {[ z ]} y=z       y<x = y<x
      projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¤âº}    y=z       y<x = y<x
      projâ‚‚ <-resp-â‰ˆâº {[ x ]} {[ y ]} {[ z ]}                     = projâ‚‚ (<-resp-â‰ˆ sto) {x} {y} {z}

  
  open import Relation.Binary.Core using (_â‰¡_ ; refl)
  open import Data.Product

  IsStrictTotalOrderâº : âˆ€ {a â„“â‚‚} {A : Set a} {_<_ : Rel A â„“â‚‚} â†’ IsStrictTotalOrder _â‰¡_ _<_ â†’ âˆƒ Î» (_<âº_ : Rel [ A ]âº â„“â‚‚) â†’  IsStrictTotalOrder _â‰¡_ _<âº_
  IsStrictTotalOrderâº {â„“â‚‚ = â„“â‚‚} {A = A} {_<_} isto = _<âº_ , record { isEquivalence = IsEquivalenceâº ; trans = Î» {i} {j} {k} â†’ transâº {i} {j} {k} ; compare = compareâº ; <-resp-â‰ˆ = <-resp-â‰ˆâº } where

    IsEquivalenceâº : IsEquivalence _â‰¡_
    IsEquivalenceâº = record { refl = refl ; sym = symâº ; trans = transâº } where
      symâº : Symmetric _â‰¡_
      symâº refl = refl

      transâº : Transitive _â‰¡_
      transâº refl refl = refl

    _<âº_ : [ A ]âº â†’ [ A ]âº â†’ Set â„“â‚‚
    âŠ¥âº    <âº [ _ ] = Lift âŠ¤
    âŠ¥âº    <âº âŠ¤âº    = Lift âŠ¤
    [ x ] <âº [ y ] = _<_ x y
    [ _ ] <âº âŠ¤âº    = Lift âŠ¤
    _     <âº _     = Lift âŠ¥
  
    transâº : Transitive _<âº_
    transâº {âŠ¥âº}    {âŠ¥âº}                    (lift ())
    transâº {âŠ¥âº}    {[ _ ]}     {[ _ ]}     _         _         = lift tt
    transâº {âŠ¥âº}    {[ _ ]}     {âŠ¤âº}        _         _         = lift tt
    transâº {[ _ ]} {âŠ¥âº}                    (lift ())
    transâº {[ _ ]} {[ _ ]}     {[ _ ]} = IsStrictTotalOrder.trans isto
    transâº {[ _ ]} {[ _ ]}     {âŠ¤âº}        _         _         = lift tt
    transâº {âŠ¤âº}    (lift ())
    transâº         {j = [ _ ]} {âŠ¥âº} _                (lift ())
    transâº         {j = âŠ¤âº}    {âŠ¥âº}        _         (lift ())
    transâº         {j = âŠ¤âº}    {[ _ ]}     _         (lift ())
    transâº         {j = âŠ¤âº}    {âŠ¤âº}        _         (lift ())

    liftit : âˆ€ {a} {A : Set a} {x y : A} â†’ x â‰¡ y â†’ [ x ] â‰¡ [ y ]
    liftit {a} {Aâ‚} {x} {.x} refl = refl

    liftit2 : âˆ€ {a} {A : Set a} {x y : A} â†’ [ x ] â‰¡ [ y ] â†’ x â‰¡ y
    liftit2 {a} {Aâ‚} {x} {.x} refl = refl

    open import Relation.Nullary.Negation

    compareâº : Trichotomous _â‰¡_ _<âº_
    compareâº âŠ¥âº âŠ¥âº    = triâ‰ˆ lower     refl   lower
    compareâº âŠ¥âº [ _ ] = tri< (lift tt) (Î» ()) lower
    compareâº âŠ¥âº âŠ¤âº    = tri< (lift tt) (Î» ()) lower
    compareâº [ _ ] âŠ¥âº = tri> lower     (Î» ()) (lift tt)
    compareâº [ x ] [ y ] with IsStrictTotalOrder.compare isto x y
    compareâº [ x ] [ y ] | tri< a Â¬b Â¬c = tri< a (contraposition (liftit2 {A = A}) Â¬b) Â¬c
    compareâº [ x ] [ y ] | triâ‰ˆ Â¬a b Â¬c rewrite b = triâ‰ˆ Â¬a refl Â¬c
    compareâº [ x ] [ y ] | tri> Â¬a Â¬b c = tri> Â¬a (contraposition (liftit2 {A = A}) Â¬b) c
    compareâº [ _ ] âŠ¤âº = tri< (lift tt) (Î» ()) lower
    compareâº âŠ¤âº âŠ¥âº    = tri> lower     (Î» ()) (lift tt)
    compareâº âŠ¤âº [ _ ] = tri> lower     (Î» ()) (lift tt)
    compareâº âŠ¤âº âŠ¤âº    = triâ‰ˆ lower     refl   lower
 
    open import Data.Product
 
    <-resp-â‰ˆâº : _<âº_ Respectsâ‚‚ _â‰¡_
    projâ‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {[ k ]} ()
    projâ‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¤âº}    ()
    projâ‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¥âº}    ()
    projâ‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¤âº}    ()
    projâ‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¥âº}    ()
    projâ‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {[ k ]} ()
    projâ‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¥âº}    y=z       x<y = x<y
    projâ‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¤âº}    y=z       x<y = x<y
    projâ‚ <-resp-â‰ˆâº {âŠ¥âº}    {[ y ]} {[ z ]} y=z       x<y = x<y
    projâ‚ <-resp-â‰ˆâº {âŠ¤âº}    {[ y ]} {[ z ]} y=z       x<y = x<y
    projâ‚ <-resp-â‰ˆâº {[ x ]} {[ y ]} {[ z ]} y=z       x<y rewrite liftit2 y=z = x<y
    projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {[ k ]} ()
    projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¤âº}    ()
    projâ‚‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¥âº}    ()
    projâ‚‚ <-resp-â‰ˆâº {x}     {[ k ]} {âŠ¤âº}    ()
    projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¥âº}    ()
    projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {[ k ]} ()
    projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¥âº}    {âŠ¥âº}    y=z       y<x = y<x
    projâ‚‚ <-resp-â‰ˆâº {âŠ¥âº}    {[ y ]} {[ z ]} y=z       y<x = y<x
    projâ‚‚ <-resp-â‰ˆâº {âŠ¤âº}    {[ y ]} {[ z ]} y=z       y<x = y<x
    projâ‚‚ <-resp-â‰ˆâº {x}     {âŠ¤âº}    {âŠ¤âº}    y=z       y<x = y<x
    projâ‚‚ <-resp-â‰ˆâº {[ x ]} {[ y ]} {[ z ]} y=z       x<y rewrite liftit2 y=z = x<y
      
open import Relation.Binary
open import Data.Product
open import Relation.Binary.PropositionalEquality

{-
module TREE (let open StrictTotalOrder)
  {ğ‘¼âŸ¨KeyâŸ© ğ‘¼âŸ¨â‰ˆâŸ© ğ‘¼âŸ¨<âŸ© ğ‘¼âŸ¨ValueâŸ©}
  (strictTotalOrder : StrictTotalOrder ğ‘¼âŸ¨KeyâŸ© ğ‘¼âŸ¨â‰ˆâŸ© ğ‘¼âŸ¨<âŸ©)
  (Value : Carrier strictTotalOrder â†’ Set ğ‘¼âŸ¨ValueâŸ©)
  where

  open import Level using ( _âŠ”_ ; Lift ; lift )
  open import Data.Product

  Key : Set ğ‘¼âŸ¨KeyâŸ©
  Key = Carrier strictTotalOrder

  KV : Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ©)
  KV = Î£ Key Value
  
  open ADDBOUNDS
  open HEIGHT

  open import Data.Nat.Base hiding (_âŠ”_)

  open StrictTotalOrder (StrictTotalOrderâº strictTotalOrder) renaming (_<_ to _<âº_) using ()
  open StrictTotalOrder strictTotalOrder


  data Tree (l u : [ Key ]âº) : â„• â†’ Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ©) where
    leaf : (l<u : l <âº u) â†’ Tree l u 0
    node : âˆ€ {hË¡ hÊ³ h}
           (k : KV)
           (lk : Tree l [ projâ‚ k ] hË¡)
           (ku : Tree [ projâ‚ k ] u hÊ³)
           (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
           Tree l u (suc h)

  open import Relation.Binary.PropositionalEquality as P using (_â‰¡_ ; sym)

  Tree<* : (<k : [ Key ]âº) â†’ (kv : KV) â†’ (h : â„•) â†’ (âˆƒ! _â‰¡_ (Î» s â†’ s â‰¡ (Tree <k [ projâ‚ kv ] h)))
  Tree<* <k (k , _) h = Tree <k [ k ] h , _â‰¡_.refl , sym
 
  Tree< : [ Key ]âº â†’ KV â†’ â„• â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
  Tree< <k (k , _) h = Tree <k [ k ] h
 
  Tree> : âˆ€ (kv : KV) â†’ (>k : [ Key ]âº) â†’ (h : â„•) â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
  Tree> (k , _) >k h = Tree [ k ] >k h
 
  data _âˆˆ_ { <k >k } ( kv : KV ) : âˆ€ { h } â†’ Tree <k >k h â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© ) where
    here : âˆ€
           { <h >h h }
           { <t : Tree< <k kv <h }
           { >t : Tree> kv >k >h }
           { bal : <h âˆ¼ >h âŠ” h }
           â†’ kv âˆˆ node kv <t >t bal
    left : âˆ€
           { <h >h h kâ€² } { vâ€² : Value kâ€² }
           { <t : Tree <k [ kâ€² ] <h }
           { >t : Tree [ kâ€² ]  >k >h }
           { bal : <h âˆ¼ >h âŠ” h }
           â†’ kv âˆˆ <t
           â†’ kv âˆˆ node ( kâ€² , vâ€² ) <t >t bal
    right : âˆ€
            { <h >h h kâ€² } { vâ€² : Value kâ€² }
            { <t : Tree <k [ kâ€² ] <h }
            { >t : Tree [ kâ€² ] >k >h }
            { bal : <h âˆ¼ >h âŠ” h }
            â†’ kv âˆˆ >t
            â†’ kv âˆˆ node ( kâ€² , vâ€² ) <t >t bal

  open import Relation.Nullary

  _âˆˆ?_ : âˆ€ {l u h} â†’ (k : Key) â†’ (t : Tree l u h) â†’ Dec (âˆƒ Î» v â†’ (k , v) âˆˆ t)
  k âˆˆ? leaf l<u = no (Î» {(_ , ())})
  k âˆˆ? node (k' , v') _ _ _ with StrictTotalOrder.compare strictTotalOrder k k'
  k âˆˆ? node (k' , v') lk ku bal | tri< a Â¬b Â¬c = {!!}
  k âˆˆ? node (k' , v') lk ku bal | triâ‰ˆ Â¬a b Â¬c = yes {!v' , here!}
  k âˆˆ? node (k' , v') lk ku bal | tri> Â¬a Â¬b c = {!!}
-}
  

{-
module TREE (let open Relation.Binary)
  {ğ‘¼âŸ¨KeyâŸ© ğ‘¼âŸ¨ValueâŸ© ğ‘¼âŸ¨<âŸ©}
  {Key : Set ğ‘¼âŸ¨KeyâŸ©} (Value : Key â†’ Set ğ‘¼âŸ¨ValueâŸ©)
  {_â‰ˆ_ : Rel Key ğ‘¼âŸ¨<âŸ©}
  {_<_ : Rel Key ğ‘¼âŸ¨<âŸ©}
  (isStrictTotalOrder : IsStrictTotalOrder _â‰ˆ_ _<_)
  where

  open import Level using ( _âŠ”_ ; Lift ; lift )
  open import Data.Product
  
  KV : Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ©)
  KV = Î£ Key Value
   
  open ADDBOUNDS
  open HEIGHT

  open import Data.Nat.Base hiding (_âŠ”_)

  open StrictTotalOrder (StrictTotalOrderâº isStrictTotalOrder) renaming (_<_ to _<âº_) using ()

  data Tree (l u : [ Key ]âº) : â„• â†’ Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ©) where
    leaf : (l<u : l <âº u) â†’ Tree l u 0
    node : âˆ€ {hË¡ hÊ³ h}
           (k : KV)
           (lk : Tree l [ projâ‚ k ] hË¡)
           (ku : Tree [ projâ‚ k ] u hÊ³)
           (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
           Tree l u (suc h)

  open import Relation.Binary.PropositionalEquality as P using (_â‰¡_ ; sym)

  Tree<* : (<k : [ Key ]âº) â†’ (kv : KV) â†’ (h : â„•) â†’ (âˆƒ! _â‰ˆ_ (Î» s â†’ s â‰¡ (Tree <k [ projâ‚ kv ] h)))
  Tree<* <k (k , _) h = Tree <k [ k ] h , _â‰¡_.refl , sym
 
  Tree< : [ Key ]âº â†’ KV â†’ â„• â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
  Tree< <k (k , _) h = Tree <k [ k ] h
 
  Tree> : âˆ€ (kv : KV) â†’ (>k : [ Key ]âº) â†’ (h : â„•) â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
  Tree> (k , _) >k h = Tree [ k ] >k h
 
  data _âˆˆ_ { <k >k } ( kv : KV ) : âˆ€ { h } â†’ Tree <k >k h â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© ) where
    here : âˆ€
           { <h >h h }
           { <t : Tree< <k kv <h }
           { >t : Tree> kv >k >h }
           { bal : <h âˆ¼ >h âŠ” h }
           â†’ kv âˆˆ node kv <t >t bal
    left : âˆ€
           { <h >h h kâ€² } { vâ€² : Value kâ€² }
           { <t : Tree <k [ kâ€² ] <h }
           { >t : Tree [ kâ€² ]  >k >h }
           { bal : <h âˆ¼ >h âŠ” h }
           â†’ kv âˆˆ <t
           â†’ kv âˆˆ node ( kâ€² , vâ€² ) <t >t bal
    right : âˆ€
            { <h >h h kâ€² } { vâ€² : Value kâ€² }
            { <t : Tree <k [ kâ€² ] <h }
            { >t : Tree [ kâ€² ] >k >h }
            { bal : <h âˆ¼ >h âŠ” h }
            â†’ kv âˆˆ >t
            â†’ kv âˆˆ node ( kâ€² , vâ€² ) <t >t bal
-}






















{-      
  infix 4 _<âº_
   
  _<âº_ : Keyâº â†’ Keyâº â†’ Set ğ‘¼âŸ¨<âŸ©
  âŠ¥âº    <âº [ _ ] = Lift âŠ¤
  âŠ¥âº    <âº âŠ¤âº    = Lift âŠ¤
  [ x ] <âº [ y ] = x < y
  [ _ ] <âº âŠ¤âº    = Lift âŠ¤
  _     <âº _     = Lift âŠ¥
   
  -- A pair of ordering constraints.
   
  infix 4 _<_<_
   
  _<_<_ : Keyâº â†’ Key â†’ Keyâº â†’ Set ğ‘¼âŸ¨<âŸ©
  l < x < u = l <âº [ x ] Ã— [ x ] <âº u
   
  -- _<âº_ is transitive.
   
  transâº : âˆ€ l {m u} â†’ l <âº m â†’ m <âº u â†’ l <âº u
   
  transâº [ l ] {m = [ m ]} {u = [ u ]} l<m m<u = trans l<m m<u
   
  transâº âŠ¥âº    {u = [ _ ]} _ _ = _
  transâº âŠ¥âº    {u = âŠ¤âº}    _ _ = _
  transâº [ _ ] {u = âŠ¤âº}    _ _ = _
   
  transâº _     {m = âŠ¥âº}    {u = âŠ¥âº}    _ (lift ())
  transâº _     {m = [ _ ]} {u = âŠ¥âº}    _ (lift ())
  transâº _     {m = âŠ¤âº}    {u = âŠ¥âº}    _ (lift ())
  transâº [ _ ] {m = âŠ¥âº}    {u = [ _ ]} (lift ()) _
  transâº [ _ ] {m = âŠ¤âº}    {u = [ _ ]} _ (lift ())
  transâº âŠ¤âº    {m = âŠ¥âº}                (lift ()) _
  transâº âŠ¤âº    {m = [ _ ]}             (lift ()) _
  transâº âŠ¤âº    {m = âŠ¤âº}                (lift ()) _
  -}

{-
open import Relation.Binary
open import Relation.Binary.PropositionalEquality as P using (_â‰¡_ ; sym)

module SUB
  {ğ‘¼âŸ¨KeyâŸ© ğ‘¼âŸ¨ValueâŸ© ğ‘¼âŸ¨<âŸ©}
  {Key : Set ğ‘¼âŸ¨KeyâŸ©} (Value : Key â†’ Set ğ‘¼âŸ¨ValueâŸ©)
  {_<_ : Rel Key ğ‘¼âŸ¨<âŸ©}
  (isStrictTotalOrder : IsStrictTotalOrder _â‰¡_ _<_)
  where

  open import Data.Bool.Base using (Bool)
  import Data.DifferenceList as DiffList
  open import Data.Empty
  open import Data.List.Base as List using (List)
  open import Data.Maybe.Base hiding (map)
  open import Data.Nat.Base hiding (_<_; _âŠ”_ ; compare)
  open import Data.Product hiding (map)
  open import Data.Unit
  open import Function
  open import Level using (_âŠ”_; Lift; lift)
   
  open IsStrictTotalOrder isStrictTotalOrder
   
  ------------------------------------------------------------------------
  -- Extended keys
   
  module Extended-key where
   
    -- The key type extended with a new minimum and maximum.
   
    data Keyâº : Set ğ‘¼âŸ¨KeyâŸ© where
      âŠ¥âº âŠ¤âº : Keyâº
      [_]   : (k : Key) â†’ Keyâº
   
    -- An extended strict ordering relation.
   
    infix 4 _<âº_
   
    _<âº_ : Keyâº â†’ Keyâº â†’ Set ğ‘¼âŸ¨<âŸ©
    âŠ¥âº    <âº [ _ ] = Lift âŠ¤
    âŠ¥âº    <âº âŠ¤âº    = Lift âŠ¤
    [ x ] <âº [ y ] = x < y
    [ _ ] <âº âŠ¤âº    = Lift âŠ¤
    _     <âº _     = Lift âŠ¥
   
    -- A pair of ordering constraints.
   
    infix 4 _<_<_
   
    _<_<_ : Keyâº â†’ Key â†’ Keyâº â†’ Set ğ‘¼âŸ¨<âŸ©
    l < x < u = l <âº [ x ] Ã— [ x ] <âº u
   
    -- _<âº_ is transitive.
   
    transâº : âˆ€ l {m u} â†’ l <âº m â†’ m <âº u â†’ l <âº u
   
    transâº [ l ] {m = [ m ]} {u = [ u ]} l<m m<u = trans l<m m<u
   
    transâº âŠ¥âº    {u = [ _ ]} _ _ = _
    transâº âŠ¥âº    {u = âŠ¤âº}    _ _ = _
    transâº [ _ ] {u = âŠ¤âº}    _ _ = _
   
    transâº _     {m = âŠ¥âº}    {u = âŠ¥âº}    _ (lift ())
    transâº _     {m = [ _ ]} {u = âŠ¥âº}    _ (lift ())
    transâº _     {m = âŠ¤âº}    {u = âŠ¥âº}    _ (lift ())
    transâº [ _ ] {m = âŠ¥âº}    {u = [ _ ]} (lift ()) _
    transâº [ _ ] {m = âŠ¤âº}    {u = [ _ ]} _ (lift ())
    transâº âŠ¤âº    {m = âŠ¥âº}                (lift ()) _
    transâº âŠ¤âº    {m = [ _ ]}             (lift ()) _
    transâº âŠ¤âº    {m = âŠ¤âº}                (lift ()) _
   
  ------------------------------------------------------------------------
  -- Types and functions which are used to keep track of height
  -- invariants
   
  module Height-invariants where
   
    -- Bits. (I would use Fin 2 instead if Agda had "defined patterns",
    -- so that I could pattern match on 1# instead of suc zero; the text
    -- "suc zero" takes up a lot more space.)
   
    data â„•â‚‚ : Set where
      0# : â„•â‚‚
      1# : â„•â‚‚
   
    -- Addition.
   
    infixl 6 _âŠ•_
   
    _âŠ•_ : â„•â‚‚ â†’ â„• â†’ â„•
    0# âŠ• n = n
    1# âŠ• n = 1 + n
   
    -- i âŠ• n -1 = pred (i âŠ• n).
   
    _âŠ•_â”€1 : â„•â‚‚ â†’ â„• â†’ â„•
    i âŠ• zero  â”€1 = 0
    i âŠ• suc n â”€1 = i âŠ• n
   
    infix 4 _âˆ¼_âŠ”_
   
    -- If i âˆ¼ j âŠ” m, then the difference between i and j is at most 1,
    -- and the maximum of i and j is m. _âˆ¼_âŠ”_ is used to record the
    -- balance factor of the AVL trees, and also to ensure that the
    -- absolute value of the balance factor is never more than 1.
   
    data _âˆ¼_âŠ”_ : â„• â†’ â„• â†’ â„• â†’ Set where
      âˆ¼+ : âˆ€ {n} â†’     n âˆ¼ 1 + n âŠ” 1 + n
      âˆ¼0 : âˆ€ {n} â†’     n âˆ¼ n     âŠ” n
      âˆ¼- : âˆ€ {n} â†’ 1 + n âˆ¼ n     âŠ” 1 + n
   
    -- Some lemmas.
   
    maxâˆ¼ : âˆ€ {i j m} â†’ i âˆ¼ j âŠ” m â†’ m âˆ¼ i âŠ” m
    maxâˆ¼ âˆ¼+ = âˆ¼-
    maxâˆ¼ âˆ¼0 = âˆ¼0
    maxâˆ¼ âˆ¼- = âˆ¼0
   
    âˆ¼max : âˆ€ {i j m} â†’ i âˆ¼ j âŠ” m â†’ j âˆ¼ m âŠ” m
    âˆ¼max âˆ¼+ = âˆ¼0
    âˆ¼max âˆ¼0 = âˆ¼0
    âˆ¼max âˆ¼- = âˆ¼+
   
  ------------------------------------------------------------------------
  -- AVL trees
   
  -- Key/value pairs.
   
  KV : Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ©)
  KV = Î£ Key Value
   
  module Indexed where
   
    open Extended-key
    open Height-invariants
   
    -- The trees have three parameters/indices: a lower bound on the
    -- keys, an upper bound, and a height.
    --
    -- (The bal argument is the balance factor.)
   
    data Tree (l u : Keyâº) : â„• â†’ Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ©) where
      leaf : (l<u : l <âº u) â†’ Tree l u 0
      node : âˆ€ {hË¡ hÊ³ h}
             (k : KV)
             (lk : Tree l [ projâ‚ k ] hË¡)
             (ku : Tree [ projâ‚ k ] u hÊ³)
             (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
             Tree l u (suc h)
   
    Tree<* : (<k : Keyâº) â†’ (kv : KV) â†’ (h : â„•) â†’ âˆƒ! _â‰¡_ Î» s â†’ s â‰¡ Tree <k [ projâ‚ kv ] h
    Tree<* <k (k , _) h = Tree <k [ k ] h , _â‰¡_.refl , sym
   
    Tree< : Keyâº â†’ KV â†’ â„• â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
    Tree< <k (k , _) h = Tree <k [ k ] h
   
    Tree> : âˆ€ (kv : KV) â†’ (>k : Keyâº) â†’ (h : â„•) â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
    Tree> (k , _) >k h = Tree [ k ] >k h
   
    data _âˆˆ_ { <k >k } ( kv : KV ) : âˆ€ { h } â†’ Tree <k >k h â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© ) where
      here : âˆ€
             { <h >h h }
             { <t : Tree< <k kv <h }
             { >t : Tree> kv >k >h }
             { bal : <h âˆ¼ >h âŠ” h }
             â†’ kv âˆˆ node kv <t >t bal
      left : âˆ€
             { <h >h h kâ€² } { vâ€² : Value kâ€² }
             { <t : Tree <k [ kâ€² ] <h }
             { >t : Tree [ kâ€² ]  >k >h }
             { bal : <h âˆ¼ >h âŠ” h }
             â†’ kv âˆˆ <t
             â†’ kv âˆˆ node ( kâ€² , vâ€² ) <t >t bal
      right : âˆ€
              { <h >h h kâ€² } { vâ€² : Value kâ€² }
              { <t : Tree <k [ kâ€² ] <h }
              { >t : Tree [ kâ€² ] >k >h }
              { bal : <h âˆ¼ >h âŠ” h }
              â†’ kv âˆˆ >t
              â†’ kv âˆˆ node ( kâ€² , vâ€² ) <t >t bal
   
  --  âˆˆâ†’Tree : âˆ€ (kvs : Setoid KV)
   
    open import Relation.Nullary
   
    Treeâ†’âˆˆ : âˆ€ { <k >k h } â†’ (t : Tree <k >k h) â†’ { kv : KV } â†’ Dec (kv âˆˆ t)
    Treeâ†’âˆˆ (leaf l<u) = no (Î» ())
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {(k' , v')} with compare k k'
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k' , v'} | tri< a Â¬b Â¬c = {!!}
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k' , v'} | triâ‰ˆ Â¬a b Â¬c = {!!}
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k' , v'} | tri> Â¬a Â¬b c = {!!}
   
    {-
    Treeâ†’âˆˆ (leaf l<u) = no (Î» ())
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k1} {{ b = b }} with compare k k1
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k1} {{ b = b }} | tri< k<k _ _ = {!!}
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k1} {{ b = b }} | tri> _ _ k>k = {!!}
    Treeâ†’âˆˆ (node (k , v) t tâ‚ bal) {k1} {vv} {.(k , } {{ b = refl }} | triâ‰ˆ _ k=k _ rewrite k=k = ?
    -}
    
    -- Cast operations. Logarithmic in the size of the tree, if we don't
    -- count the time needed to construct the new proofs in the leaf
    -- cases. (The same kind of caveat applies to other operations
    -- below.)
    --
    -- Perhaps it would be worthwhile changing the data structure so
    -- that the casts could be implemented in constant time (excluding
    -- proof manipulation). However, note that this would not change the
    -- worst-case time complexity of the operations below (up toÂ Î˜).
   
    castË¡ : âˆ€ {l m u h} â†’ l <âº m â†’ Tree m u h â†’ Tree l u h
    castË¡ {l} l<m (leaf m<u)         = leaf (transâº l l<m m<u)
    castË¡     l<m (node k mk ku bal) = node k (castË¡ l<m mk) ku bal
   
    castÊ³ : âˆ€ {l m u h} â†’ Tree l m h â†’ m <âº u â†’ Tree l u h
    castÊ³ {l} (leaf l<m)         m<u = leaf (transâº l l<m m<u)
    castÊ³     (node k lk km bal) m<u = node k lk (castÊ³ km m<u) bal
   
    -- Various constant-time functions which construct trees out of
    -- smaller pieces, sometimes using rotation.
   
    joinË¡âº : âˆ€ {l u hË¡ hÊ³ h} â†’
             (k : KV) â†’
             (âˆƒ Î» i â†’ Tree l [ projâ‚ k ] (i âŠ• hË¡)) â†’
             Tree [ projâ‚ k ] u hÊ³ â†’
             (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
             âˆƒ Î» i â†’ Tree l u (i âŠ• (1 + h))
    joinË¡âº kâ‚† (1# , node kâ‚‚ tâ‚
                      (node kâ‚„ tâ‚ƒ tâ‚… bal)
                                  âˆ¼+) tâ‚‡ âˆ¼-  = (0# , node kâ‚„
                                                          (node kâ‚‚ tâ‚ tâ‚ƒ (maxâˆ¼ bal))
                                                          (node kâ‚† tâ‚… tâ‚‡ (âˆ¼max bal))
                                                          âˆ¼0)
    joinË¡âº kâ‚„ (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼-) tâ‚… âˆ¼-  = (0# , node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… âˆ¼0) âˆ¼0)
    joinË¡âº kâ‚„ (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0) tâ‚… âˆ¼-  = (1# , node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… âˆ¼-) âˆ¼+)
    joinË¡âº kâ‚‚ (1# , tâ‚)               tâ‚ƒ âˆ¼0  = (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼-)
    joinË¡âº kâ‚‚ (1# , tâ‚)               tâ‚ƒ âˆ¼+  = (0# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0)
    joinË¡âº kâ‚‚ (0# , tâ‚)               tâ‚ƒ bal = (0# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
   
    joinÊ³âº : âˆ€ {l u hË¡ hÊ³ h} â†’
             (k : KV) â†’
             Tree l [ projâ‚ k ] hË¡ â†’
             (âˆƒ Î» i â†’ Tree [ projâ‚ k ] u (i âŠ• hÊ³)) â†’
             (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
             âˆƒ Î» i â†’ Tree l u (i âŠ• (1 + h))
    joinÊ³âº kâ‚‚ tâ‚ (1# , node kâ‚†
                         (node kâ‚„ tâ‚ƒ tâ‚… bal)
                                  tâ‚‡ âˆ¼-) âˆ¼+  = (0# , node kâ‚„
                                                          (node kâ‚‚ tâ‚ tâ‚ƒ (maxâˆ¼ bal))
                                                          (node kâ‚† tâ‚… tâ‚‡ (âˆ¼max bal))
                                                          âˆ¼0)
    joinÊ³âº kâ‚‚ tâ‚ (1# , node kâ‚„ tâ‚ƒ tâ‚… âˆ¼+) âˆ¼+  = (0# , node kâ‚„ (node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0) tâ‚… âˆ¼0)
    joinÊ³âº kâ‚‚ tâ‚ (1# , node kâ‚„ tâ‚ƒ tâ‚… âˆ¼0) âˆ¼+  = (1# , node kâ‚„ (node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼+) tâ‚… âˆ¼-)
    joinÊ³âº kâ‚‚ tâ‚ (1# , tâ‚ƒ)               âˆ¼0  = (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼+)
    joinÊ³âº kâ‚‚ tâ‚ (1# , tâ‚ƒ)               âˆ¼-  = (0# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0)
    joinÊ³âº kâ‚‚ tâ‚ (0# , tâ‚ƒ)               bal = (0# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
   
    joinË¡â» : âˆ€ {l u} hË¡ {hÊ³ h} â†’
             (k : KV) â†’
             (âˆƒ Î» i â†’ Tree l [ projâ‚ k ] (i âŠ• hË¡ â”€1)) â†’
             Tree [ projâ‚ k ] u hÊ³ â†’
             (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
             âˆƒ Î» i â†’ Tree l u (i âŠ• h)
    joinË¡â» zero    kâ‚‚ (0# , tâ‚) tâ‚ƒ bal = (1# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
    joinË¡â» zero    kâ‚‚ (1# , tâ‚) tâ‚ƒ bal = (1# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
    joinË¡â» (suc _) kâ‚‚ (0# , tâ‚) tâ‚ƒ âˆ¼+  = joinÊ³âº kâ‚‚ tâ‚ (1# , tâ‚ƒ) âˆ¼+
    joinË¡â» (suc _) kâ‚‚ (0# , tâ‚) tâ‚ƒ âˆ¼0  = (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼+)
    joinË¡â» (suc _) kâ‚‚ (0# , tâ‚) tâ‚ƒ âˆ¼-  = (0# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0)
    joinË¡â» (suc _) kâ‚‚ (1# , tâ‚) tâ‚ƒ bal = (1# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
   
    joinÊ³â» : âˆ€ {l u hË¡} hÊ³ {h} â†’
             (k : KV) â†’
             Tree l [ projâ‚ k ] hË¡ â†’
             (âˆƒ Î» i â†’ Tree [ projâ‚ k ] u (i âŠ• hÊ³ â”€1)) â†’
             (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
             âˆƒ Î» i â†’ Tree l u (i âŠ• h)
    joinÊ³â» zero    kâ‚‚ tâ‚ (0# , tâ‚ƒ) bal = (1# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
    joinÊ³â» zero    kâ‚‚ tâ‚ (1# , tâ‚ƒ) bal = (1# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
    joinÊ³â» (suc _) kâ‚‚ tâ‚ (0# , tâ‚ƒ) âˆ¼-  = joinË¡âº kâ‚‚ (1# , tâ‚) tâ‚ƒ âˆ¼-
    joinÊ³â» (suc _) kâ‚‚ tâ‚ (0# , tâ‚ƒ) âˆ¼0  = (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼-)
    joinÊ³â» (suc _) kâ‚‚ tâ‚ (0# , tâ‚ƒ) âˆ¼+  = (0# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0)
    joinÊ³â» (suc _) kâ‚‚ tâ‚ (1# , tâ‚ƒ) bal = (1# , node kâ‚‚ tâ‚ tâ‚ƒ bal)
   
    -- Extracts the smallest element from the tree, plus the rest.
    -- Logarithmic in the size of the tree.
   
    headTail : âˆ€ {l u h} â†’ Tree l u (1 + h) â†’
               âˆƒ Î» (k : KV) â†’ l <âº [ projâ‚ k ] Ã—
                              âˆƒ Î» i â†’ Tree [ projâ‚ k ] u (i âŠ• h)
    headTail (node kâ‚ (leaf l<kâ‚) tâ‚‚ âˆ¼+) = (kâ‚ , l<kâ‚ , 0# , tâ‚‚)
    headTail (node kâ‚ (leaf l<kâ‚) tâ‚‚ âˆ¼0) = (kâ‚ , l<kâ‚ , 0# , tâ‚‚)
    headTail (node {hË¡ = suc _} kâ‚ƒ tâ‚â‚‚ tâ‚„ bal) with headTail tâ‚â‚‚
    ... | (kâ‚ , l<kâ‚ , tâ‚‚) = (kâ‚ , l<kâ‚ , joinË¡â» _ kâ‚ƒ tâ‚‚ tâ‚„ bal)
   
    -- Extracts the largest element from the tree, plus the rest.
    -- Logarithmic in the size of the tree.
   
    initLast : âˆ€ {l u h} â†’ Tree l u (1 + h) â†’
               âˆƒ Î» (k : KV) â†’ [ projâ‚ k ] <âº u Ã—
                              âˆƒ Î» i â†’ Tree l [ projâ‚ k ] (i âŠ• h)
    initLast (node kâ‚‚ tâ‚ (leaf kâ‚‚<u) âˆ¼-) = (kâ‚‚ , kâ‚‚<u , (0# , tâ‚))
    initLast (node kâ‚‚ tâ‚ (leaf kâ‚‚<u) âˆ¼0) = (kâ‚‚ , kâ‚‚<u , (0# , tâ‚))
    initLast (node {hÊ³ = suc _} kâ‚‚ tâ‚ tâ‚ƒâ‚„ bal) with initLast tâ‚ƒâ‚„
    ... | (kâ‚„ , kâ‚„<u , tâ‚ƒ) = (kâ‚„ , kâ‚„<u , joinÊ³â» _ kâ‚‚ tâ‚ tâ‚ƒ bal)
   
    -- Another joining function. Logarithmic in the size of either of
    -- the input trees (which need to have almost equal heights).
   
    join : âˆ€ {l m u hË¡ hÊ³ h} â†’
           Tree l m hË¡ â†’ Tree m u hÊ³ â†’ (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
           âˆƒ Î» i â†’ Tree l u (i âŠ• h)
    join tâ‚ (leaf m<u) âˆ¼0 = (0# , castÊ³ tâ‚ m<u)
    join tâ‚ (leaf m<u) âˆ¼- = (0# , castÊ³ tâ‚ m<u)
    join {hÊ³ = suc _} tâ‚ tâ‚‚â‚ƒ bal with headTail tâ‚‚â‚ƒ
    ... | (kâ‚‚ , m<kâ‚‚ , tâ‚ƒ) = joinÊ³â» _ kâ‚‚ (castÊ³ tâ‚ m<kâ‚‚) tâ‚ƒ bal
   
    -- An empty tree.
   
    empty : âˆ€ {l u} â†’ l <âº u â†’ Tree l u 0
    empty = leaf
   
    -- A singleton tree.
   
    singleton : âˆ€ {l u} (k : Key) â†’ Value k â†’ l < k < u â†’ Tree l u 1
    singleton k v (l<k , k<u) = node (k , v) (leaf l<k) (leaf k<u) âˆ¼0
   
    -- Inserts a key into the tree, using a function to combine any
    -- existing value with the new value. Logarithmic in the size of the
    -- tree (assuming constant-time comparisons and a constant-time
    -- combining function).
   
    insertWith : âˆ€ {l u h} â†’ (k : Key) â†’ Value k â†’
                 (Value k â†’ Value k â†’ Value k) â†’  -- New â†’ old â†’ result.
                 Tree l u h â†’ l < k < u â†’
                 âˆƒ Î» i â†’ Tree l u (i âŠ• h)
    insertWith k v f (leaf l<u) l<k<u = (1# , singleton k v l<k<u)
    insertWith k v f (node (kâ€² , vâ€²) lp pu bal) (l<k , k<u) with compare k kâ€²
    ... | tri< k<kâ€² _ _ = joinË¡âº (kâ€² , vâ€²) (insertWith k v f lp (l<k , k<kâ€²)) pu bal
    ... | tri> _ _ kâ€²<k = joinÊ³âº (kâ€² , vâ€²) lp (insertWith k v f pu (kâ€²<k , k<u)) bal
    ... | triâ‰ˆ _ kâ‰¡kâ€² _ rewrite P.sym kâ‰¡kâ€² = (0# , node (k , f v vâ€²) lp pu bal)
   
    -- Inserts a key into the tree. If the key already exists, then it
    -- is replaced. Logarithmic in the size of the tree (assuming
    -- constant-time comparisons).
   
    insert : âˆ€ {l u h} â†’ (k : Key) â†’ Value k â†’ Tree l u h â†’ l < k < u â†’
             âˆƒ Î» i â†’ Tree l u (i âŠ• h)
    insert k v = insertWith k v const
   
    -- Deletes the key/value pair containing the given key, if any.
    -- Logarithmic in the size of the tree (assuming constant-time
    -- comparisons).
   
    delete : âˆ€ {l u h} â†’ Key â†’ Tree l u h â†’
             âˆƒ Î» i â†’ Tree l u (i âŠ• h â”€1)
    delete k (leaf l<u)         = (0# , leaf l<u)
    delete k (node p lp pu bal) with compare k (projâ‚ p)
    ... | tri< _ _ _ = joinË¡â» _ p (delete k lp) pu bal
    ... | tri> _ _ _ = joinÊ³â» _ p lp (delete k pu) bal
    ... | triâ‰ˆ _ _ _ = join lp pu bal
   
    -- Looks up a key. Logarithmic in the size of the tree (assuming
    -- constant-time comparisons).
   
    lookup : âˆ€ {l u h} â†’ (k : Key) â†’ Tree l u h â†’ Maybe (Value k)
    lookup k (leaf _)                  = nothing
    lookup k (node (kâ€² , v) lkâ€² kâ€²u _) with compare k kâ€²
    ... | tri< _ _  _ = lookup k lkâ€²
    ... | tri> _ _  _ = lookup k kâ€²u
    ... | triâ‰ˆ _ eq _ rewrite eq = just v
   
    -- Maps a function over all values in the tree.
   
    map : (âˆ€ {k} â†’ Value k â†’ Value k) â†’
          âˆ€ {l u h} â†’ Tree l u h â†’ Tree l u h
    map f (leaf l<u)             = leaf l<u
    map f (node (k , v) l r bal) = node (k , f v) (map f l) (map f r) bal
   
    -- Converts the tree to an ordered list. Linear in the size of the
    -- tree.
   
    open DiffList
   
    toDiffList : âˆ€ {l u h} â†’ Tree l u h â†’ DiffList KV
    toDiffList (leaf _)       = []
    toDiffList (node k l r _) = toDiffList l ++ k âˆ· toDiffList r
   
  module OrderedList where
    open Indexed
   
    open Extended-key
    open Height-invariants
    
    open import Relation.Binary.HeterogeneousEquality as H using ( _â‰…_ )
    open import Relation.Nullary.Negation
    import Data.List as L
   
    infixr 6 _âˆ·_
    data OrderedList (l u : Keyâº) : Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨<âŸ©) where
      [] : {{l<u : l <âº u}} â†’ OrderedList l u
      _âˆ·_ : âˆ€
             (k : Key)
             {{_ : l <âº [ k ]}}
             (ku : OrderedList [ k ] u) â†’
             OrderedList l u
   
    infixr 8 _++_
    _++_ : âˆ€ {l n u} â†’ OrderedList l n â†’ (âˆ€ {m} â†’ {{_ : m <âº n}} â†’ OrderedList m u) â†’ OrderedList l u
    [] ++ ys = ys
    (x âˆ· xs) ++ ys = x âˆ· xs ++ ys
   
    
      
    
   
  module MSD where
   
    open Indexed hiding ( _âˆˆ_ )
   
    open Extended-key
    open Height-invariants
    
    open import Relation.Binary.HeterogeneousEquality as H using ( _â‰…_ )
    open import Relation.Nullary.Negation
    import Data.List as L
   
    TreeâŸ¶<âº : âˆ€ { kâƒ– kâƒ— h } â†’ Tree kâƒ– kâƒ— h â†’ kâƒ– <âº kâƒ—
    TreeâŸ¶<âº ( leaf kâƒ–<kâƒ— ) = kâƒ–<kâƒ—
    TreeâŸ¶<âº { kâƒ– = kâƒ– } ( node _ tâƒ– tâƒ— _ ) = transâº kâƒ– ( TreeâŸ¶<âº tâƒ– ) ( TreeâŸ¶<âº tâƒ— )
   
    data _âˆˆ_ { kâƒ– kâƒ— } ( k : Key ) : âˆ€ { h } â†’ Tree kâƒ– kâƒ— h â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© ) where
      here : âˆ€
             { hâƒ– hâƒ— h v }
             { tâƒ– : Tree kâƒ– [ k ] hâƒ– }
             { tâƒ— : Tree [ k ]  kâƒ— hâƒ— }
             { bal : hâƒ– âˆ¼ hâƒ— âŠ” h }
             â†’ k âˆˆ node ( k , v ) tâƒ– tâƒ— bal
      left : âˆ€
             { hâƒ– hâƒ— h kâ€² } { vâ€² : Value kâ€² }
             { tâƒ– : Tree kâƒ– [ kâ€² ] hâƒ– }
             { tâƒ— : Tree [ kâ€² ]  kâƒ— hâƒ— }
             { bal : hâƒ– âˆ¼ hâƒ— âŠ” h }
             â†’ k âˆˆ tâƒ–
             â†’ k âˆˆ node ( kâ€² , vâ€² ) tâƒ– tâƒ— bal
      right : âˆ€
              { hâƒ– hâƒ— h kâ€² } { vâ€² : Value kâ€² }
              { tâƒ– : Tree kâƒ– [ kâ€² ] hâƒ– }
              { tâƒ— : Tree [ kâ€² ] kâƒ— hâƒ— }
              { bal : hâƒ– âˆ¼ hâƒ— âŠ” h }
              â†’ k âˆˆ tâƒ—
              â†’ k âˆˆ node ( kâ€² , vâ€² ) tâƒ– tâƒ— bal
   
    âˆˆâŸ¶Tree : âˆ€ { l u h } { t : Tree l u h } { k : Key } â†’ k âˆˆ t â†’ Tree l u h
    âˆˆâŸ¶Tree { t = t } _ = t
   
    âˆˆâŸ¶<< : âˆ€ { l u h } { t : Tree l u h } { k : Key } â†’ k âˆˆ t â†’ l < k < u
    âˆˆâŸ¶<< ( here { tâƒ– = tâƒ– } { tâƒ— = tâƒ— } ) = TreeâŸ¶<âº tâƒ– , TreeâŸ¶<âº tâƒ—
    âˆˆâŸ¶<< { l = l } { u = u } { k = k } ( left { kâ€² = kâ€² } { tâƒ— = tâƒ— } kâˆˆtË¡ ) = l<k , k<u where
      l<k<kâ€² : l < k < [ kâ€² ]
      l<k<kâ€² = âˆˆâŸ¶<< kâˆˆtË¡
     
      l<k : l <âº [ k ]
      l<k = projâ‚ l<k<kâ€²
     
      k<kâ€² : [ k ] <âº [ kâ€² ]
      k<kâ€² = projâ‚‚ l<k<kâ€²
     
      kâ€²<u : [ kâ€² ] <âº u
      kâ€²<u = TreeâŸ¶<âº tâƒ—
     
      k<u : [ k ] <âº u
      k<u = transâº [ k ] { m = [ kâ€² ] } { u = u } k<kâ€² kâ€²<u
    âˆˆâŸ¶<< { l = l } { u = u } { k = k } ( right { kâ€² = kâ€² } { tâƒ– = lkâ€² } kâˆˆtÊ³ ) = l<k , k<u where
      kâ€²<k<u : [ kâ€² ] < k < u
      kâ€²<k<u = âˆˆâŸ¶<< kâˆˆtÊ³
     
      k<u : [ k ] <âº u
      k<u = projâ‚‚ kâ€²<k<u
     
      kâ€²<k : [ kâ€² ] <âº [ k ] 
      kâ€²<k = projâ‚ kâ€²<k<u
     
      l<kâ€² : l <âº [ kâ€² ]
      l<kâ€² = TreeâŸ¶<âº lkâ€²
     
      l<k : l <âº [ k ]
      l<k = transâº l { m = [ kâ€² ] } { u = [ k ] } l<kâ€² kâ€²<k
     
    data _âˆ¼_âˆˆÌƒ_ { kâƒ– kâƒ— : Keyâº } ( k : Key ) ( v : Value k ) {- ( k' : Key ) â¦ƒ _ : k â‰¡ k' â¦„ -} : âˆ€ { h : â„• } â†’ Tree kâƒ– kâƒ— h â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© ) where
      here : âˆ€
             { hâƒ– hâƒ— h }
             { tâƒ– : Tree kâƒ– [ k ] hâƒ– }
             { tâƒ— : Tree [ k ]  kâƒ— hâƒ— }
             { bal : hâƒ– âˆ¼ hâƒ— âŠ” h }
             â†’ k âˆ¼ v âˆˆÌƒ node ( k , v ) tâƒ– tâƒ— bal
      left : âˆ€
             { hâƒ– hâƒ— h kâ€² } { vâ€² : Value kâ€² }
             { tâƒ– : Tree kâƒ– [ kâ€² ] hâƒ– }
             { tâƒ— : Tree [ kâ€² ]  kâƒ— hâƒ— }
             { bal : hâƒ– âˆ¼ hâƒ— âŠ” h }
             â†’ k âˆ¼ v âˆˆÌƒ tâƒ–
             â†’ k âˆ¼ v âˆˆÌƒ node ( kâ€² , vâ€² ) tâƒ– tâƒ— bal
      right : âˆ€
              { hâƒ– hâƒ— h kâ€² } { vâ€² : Value kâ€² }
              { tâƒ– : Tree kâƒ– [ kâ€² ] hâƒ– }
              { tâƒ— : Tree [ kâ€² ] kâƒ— hâƒ— }
              { bal : hâƒ– âˆ¼ hâƒ— âŠ” h }
              â†’ k âˆ¼ v âˆˆÌƒ tâƒ—
              â†’ k âˆ¼ v âˆˆÌƒ node ( kâ€² , vâ€² ) tâƒ– tâƒ— bal
   
    _âˆˆÌŒ_ : âˆ€ { kâƒ– kâƒ— : Keyâº } { h } ( kv : KV ) â†’ ( t : Tree kâƒ– kâƒ— h )  â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ© )
    (k , v) âˆˆÌŒ t = k âˆ¼ v âˆˆÌƒ t
   
    âˆˆÌƒâ†’âˆˆ : âˆ€ { k l u h } { v : Value k } { t : Tree l u h } â†’ k âˆ¼ v âˆˆÌƒ t â†’ k âˆˆ t
    âˆˆÌƒâ†’âˆˆ here = here
    âˆˆÌƒâ†’âˆˆ (left x) = left (âˆˆÌƒâ†’âˆˆ x)
    âˆˆÌƒâ†’âˆˆ (right x) = right (âˆˆÌƒâ†’âˆˆ x)
   
    âˆˆÌŒâŸ¶l<âºk : âˆ€ { k l u h } { v : Value k } { t : Tree l u h } â†’ k âˆ¼ v âˆˆÌƒ t â†’ l <âº [ k ]
    âˆˆÌŒâŸ¶l<âºk x = projâ‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ x))
   
    âˆˆÌŒâŸ¶k<âºu : âˆ€ { k l u h } { v : Value k } { t : Tree l u h } â†’ k âˆ¼ v âˆˆÌƒ t â†’ [ k ] <âº u
    âˆˆÌŒâŸ¶k<âºu x = projâ‚‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ x))
   
    open import Data.Sum using (_âŠ_ ; injâ‚ ; injâ‚‚)
   
    aâ‰®a : âˆ€ { k } â†’ k < k â†’ âŠ¥
    aâ‰®a = irrefl P.refl
    
    lemL : âˆ€ { k l h } { v : Value k } { t : Tree l [ k ] h } â†’ k âˆ¼ v âˆˆÌƒ t â†’ âŠ¥
    lemL x = contradiction ( projâ‚‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ x))) ( aâ‰®a) where
      
    lemR : âˆ€ { k u h } { v : Value k } { t : Tree [ k ] u h } â†’ k âˆ¼ v âˆˆÌƒ t â†’ âŠ¥
    lemR x = contradiction ( projâ‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ x))) ( aâ‰®a) where
   
    open import Relation.Binary.Consequences
      
    kâ†’v : âˆ€ {kv1 kv2 : KV} {l u h} {t : Tree l u h} â†’ kv1 âˆˆÌŒ t â†’ kv2 âˆˆÌŒ t â†’ projâ‚ kv1 â‰¡ projâ‚ kv2 â†’ kv1 â‰… kv2
    kâ†’v here here P.refl = H.refl
    kâ†’v (here { tâƒ– = tâƒ– })  (left kv2âˆˆÌŒt) P.refl = âŠ¥-elim (lemL kv2âˆˆÌŒt)
    kâ†’v here (right kv2âˆˆÌŒt) P.refl = âŠ¥-elim (lemR kv2âˆˆÌŒt)
    kâ†’v (left kv1âˆˆÌŒtË¡) here P.refl = âŠ¥-elim (lemL kv1âˆˆÌŒtË¡)
    kâ†’v (left kv1âˆˆÌŒtË¡) (left kv2âˆˆÌŒt) P.refl = kâ†’v kv1âˆˆÌŒtË¡ kv2âˆˆÌŒt P.refl
    kâ†’v (left kv1âˆˆÌŒtË¡) (right kv2âˆˆÌŒt) P.refl = contradiction (projâ‚‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv1âˆˆÌŒtË¡))) (triâŸ¶asym compare (projâ‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv2âˆˆÌŒt))))
    kâ†’v (right kv1âˆˆÌŒtÊ³) here P.refl = âŠ¥-elim (lemR kv1âˆˆÌŒtÊ³)
    kâ†’v (right kv1âˆˆÌŒtÊ³) (left kv2âˆˆÌŒt) P.refl = contradiction (projâ‚‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv2âˆˆÌŒt))) (triâŸ¶asym compare (projâ‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv1âˆˆÌŒtÊ³))))
    kâ†’v (right kv1âˆˆÌŒtÊ³) (right kv2âˆˆÌŒt) P.refl = kâ†’v kv1âˆˆÌŒtÊ³ kv2âˆˆÌŒt P.refl
   
    kâ†’v' : âˆ€ { k : Key } { vâ‚ vâ‚‚ : Value k } { l u h } { t : Tree l u h } â†’ k âˆ¼ vâ‚ âˆˆÌƒ t â†’ k âˆ¼ vâ‚‚ âˆˆÌƒ t â†’ vâ‚ â‰¡ vâ‚‚
    kâ†’v' here here = P.refl
    kâ†’v' here (left kv2âˆˆÌŒt) = âŠ¥-elim (lemL kv2âˆˆÌŒt)
    kâ†’v' here (right kv2âˆˆÌŒt) = âŠ¥-elim (lemR kv2âˆˆÌŒt)
    kâ†’v' (left kv1âˆˆÌŒtË¡) here = âŠ¥-elim (lemL kv1âˆˆÌŒtË¡)
    kâ†’v' (left kv1âˆˆÌŒtË¡) (left kv2âˆˆÌŒt) = kâ†’v' kv1âˆˆÌŒtË¡ kv2âˆˆÌŒt
    kâ†’v' (left kv1âˆˆÌŒtË¡) (right kv2âˆˆÌŒt) = contradiction (projâ‚‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv1âˆˆÌŒtË¡))) (triâŸ¶asym compare (projâ‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv2âˆˆÌŒt))))
    kâ†’v' (right kv1âˆˆÌŒtÊ³) here = âŠ¥-elim (lemR kv1âˆˆÌŒtÊ³)
    kâ†’v' (right kv1âˆˆÌŒtÊ³) (left kv2âˆˆÌŒt) = contradiction (projâ‚‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv2âˆˆÌŒt))) (triâŸ¶asym compare (projâ‚ (âˆˆâŸ¶<< (âˆˆÌƒâ†’âˆˆ kv1âˆˆÌŒtÊ³))))
    kâ†’v' (right kv1âˆˆÌŒtÊ³) (right kv2âˆˆÌŒt) = kâ†’v' kv1âˆˆÌŒtÊ³ kv2âˆˆÌŒt
   
    <âºâŸ¶< : âˆ€ {l u} â†’ [ l ] <âº [ u ] â†’ l < u
    <âºâŸ¶< [l]<âº[u] = [l]<âº[u]
   
    kv<kâ†’kvâˆˆt1 : âˆ€ {l1 u1 k kv h1 h2 H1} â†’
              {v : Value k}
              {t1 : Tree l1 [ k ] h1} â†’
              {t2 : Tree [ k ] u1 h2} â†’
              {bal1 : h1 âˆ¼ h2 âŠ” H1} â†’
              projâ‚ kv < k â†’
              kv âˆˆÌŒ node (k , v) t1 t2 bal1 â†’ 
              kv âˆˆÌŒ t1
    kv<kâ†’kvâˆˆt1 kv<k here = âŠ¥-elim (irrefl P.refl kv<k)
    kv<kâ†’kvâˆˆt1 kv<k (left kvâˆˆÌŒnode) = kvâˆˆÌŒnode
    kv<kâ†’kvâˆˆt1 {kv = (k , v)} kv<k (right kvâˆˆÌŒnode) = contradiction (<âºâŸ¶< (âˆˆÌŒâŸ¶l<âºk kvâˆˆÌŒnode)) (triâŸ¶asym compare kv<k)
   
    k<kvâ†’kvâˆˆt2 : âˆ€ {l1 u1 k kv h1 h2 H1} â†’
              {v : Value k}
              {t1 : Tree l1 [ k ] h1} â†’
              {t2 : Tree [ k ] u1 h2} â†’
              {bal1 : h1 âˆ¼ h2 âŠ” H1} â†’
              k < projâ‚ kv â†’
              kv âˆˆÌŒ node (k , v) t1 t2 bal1 â†’ 
              kv âˆˆÌŒ t2
    k<kvâ†’kvâˆˆt2 k<kv here = âŠ¥-elim (irrefl P.refl k<kv)
    k<kvâ†’kvâˆˆt2 k<kv (right kvâˆˆÌŒnode) = kvâˆˆÌŒnode
    k<kvâ†’kvâˆˆt2 {kv = (k , v)} k<kv (left kvâˆˆÌŒnode) = contradiction (<âºâŸ¶< (âˆˆÌŒâŸ¶k<âºu kvâˆˆÌŒnode)) (triâŸ¶asym compare k<kv)
   
    t1â†’t3 : âˆ€ {l1 l2 u1 u2 k kv h1 h2 h3 h4 H1 H2} â†’
              {v : Value k}
              {t1 : Tree l1 [ k ] h1} â†’
              {t2 : Tree [ k ] u1 h2} â†’
              {t3 : Tree l2 [ k ] h3} â†’
              {t4 : Tree [ k ] u2 h4} â†’
              {bal1 : h1 âˆ¼ h2 âŠ” H1}
              {bal2 : h3 âˆ¼ h4 âŠ” H2} â†’
              (kv âˆˆÌŒ node (k , v) t1 t2 bal1 â†’ kv âˆˆÌŒ node (k , v) t3 t4 bal2) â†’
              kv âˆˆÌŒ t1 â†’ kv âˆˆÌŒ t3
    t1â†’t3 âˆˆÌŒâ†’âˆˆÌŒ kvâˆˆÌŒt1 = let kvâˆˆÌŒnode12 = left kvâˆˆÌŒt1 in kv<kâ†’kvâˆˆt1 (<âºâŸ¶< (âˆˆÌŒâŸ¶k<âºu kvâˆˆÌŒt1)) (âˆˆÌŒâ†’âˆˆÌŒ kvâˆˆÌŒnode12)
   
    t2â†’t4 : âˆ€ {l1 l2 u1 u2 k kv h1 h2 h3 h4 H1 H2} â†’
              {v : Value k}
              {t1 : Tree l1 [ k ] h1} â†’
              {t2 : Tree [ k ] u1 h2} â†’
              {t3 : Tree l2 [ k ] h3} â†’
              {t4 : Tree [ k ] u2 h4} â†’
              {bal1 : h1 âˆ¼ h2 âŠ” H1}
              {bal2 : h3 âˆ¼ h4 âŠ” H2} â†’
              (kv âˆˆÌŒ node (k , v) t1 t2 bal1 â†’ kv âˆˆÌŒ node (k , v) t3 t4 bal2) â†’
              kv âˆˆÌŒ t2 â†’ kv âˆˆÌŒ t4
    t2â†’t4 âˆˆÌŒâ†’âˆˆÌŒ kvâˆˆÌŒt2 = let kvâˆˆÌŒnode12 = right kvâˆˆÌŒt2 in k<kvâ†’kvâˆˆt2 (<âºâŸ¶< (âˆˆÌŒâŸ¶l<âºk kvâˆˆÌŒt2)) (âˆˆÌŒâ†’âˆˆÌŒ kvâˆˆÌŒnode12)
   
    open import Relation.Binary.PropositionalEquality.Core
    open import Relation.Binary.PropositionalEquality
   
    âˆˆÌƒâ†’v1â‰¡v2 : âˆ€ { k l u h1 h2 h } â†’ { v1 v2 : Value k } { tâ‚ : Tree l [ k ] h1 } { tâ‚‚ : Tree [ k ] u h2 } { bal : h1 âˆ¼ h2 âŠ” h } â†’ k âˆ¼ v1 âˆˆÌƒ node (k , v2) tâ‚ tâ‚‚ bal â†’ v1 â‰¡ v2
    âˆˆÌƒâ†’v1â‰¡v2 here = refl
    âˆˆÌƒâ†’v1â‰¡v2 (left x) = âŠ¥-elim (lemL x)
    âˆˆÌƒâ†’v1â‰¡v2 (right x) = âŠ¥-elim (lemR x)
      
    âˆˆÌƒâ†’v2â‰¡v1 : âˆ€ { k l u h1 h2 h } â†’ { v1 v2 : Value k } { tâ‚ : Tree l [ k ] h1 } { tâ‚‚ : Tree [ k ] u h2 } { bal : h1 âˆ¼ h2 âŠ” h } â†’ k âˆ¼ v1 âˆˆÌƒ node (k , v2) tâ‚ tâ‚‚ bal â†’ v2 â‰¡ v1
    âˆˆÌƒâ†’v2â‰¡v1 here = refl
    âˆˆÌƒâ†’v2â‰¡v1 (left x) = âŠ¥-elim (lemL x)
    âˆˆÌƒâ†’v2â‰¡v1 (right x) = âŠ¥-elim (lemR x)
   
  {-
    data Tree* (l u : Keyâº) : â„• â†’ Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ©) where
      leaf : (l<u : l <âº u) â†’ Tree* l u 0
      node : âˆ€ {hË¡ hÊ³ h}
             (k : KV)
             (lk : Tree* l [ projâ‚ k ] hË¡)
             (ku : Tree* [ projâ‚ k ] u hÊ³)
             (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
             Tree* l u (suc h)
  -}
    duh : âˆ€ {k lâ‚â‚‚ lâ‚ƒâ‚„ uâ‚â‚‚ uâ‚ƒâ‚„ hâ‚ hâ‚‚ hâ‚â‚‚ hâ‚ƒ hâ‚„ hâ‚ƒâ‚„} {vâ‚ vâ‚‚ : Value k}
            { tâ‚ : Tree lâ‚â‚‚ [ k ] hâ‚ }
            { tâ‚‚ : Tree [ k ] uâ‚â‚‚ hâ‚‚ }
            { tâ‚ƒ : Tree lâ‚ƒâ‚„ [ k ] hâ‚ƒ }
            { tâ‚„ : Tree [ k ] uâ‚ƒâ‚„ hâ‚„ }
            { balâ‚â‚‚ : hâ‚ âˆ¼ hâ‚‚ âŠ” hâ‚â‚‚ }
            { balâ‚ƒâ‚„ : hâ‚ƒ âˆ¼ hâ‚„ âŠ” hâ‚ƒâ‚„ } â†’
            (âˆ€ {kv : Î£ Key Value} â†’
             projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ node (k , vâ‚) tâ‚ tâ‚‚ balâ‚â‚‚ â†’
             projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ node (k , vâ‚‚) tâ‚ƒ tâ‚„ balâ‚ƒâ‚„
            )
          â†’ vâ‚‚ â‰¡ vâ‚
          â†’ (âˆ€ {kv : Î£ Key Value} â†’
             projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ node (k , vâ‚) tâ‚ tâ‚‚ balâ‚â‚‚ â†’
             projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ node (k , vâ‚) tâ‚ƒ tâ‚„ balâ‚ƒâ‚„)
    duh x xâ‚ xâ‚‚ rewrite xâ‚ = x xâ‚‚
   
    open OrderedList
   
    toOrderedList : âˆ€ {l u h} â†’ Tree l u h â†’ OrderedList l u
    toOrderedList (leaf l<u) = []
    toOrderedList (node k tl tr bal) = toOrderedList tl ++ (projâ‚ k âˆ· toOrderedList tr)
   
    data _âˆˆâ‚—_ {l u} (k : Key) : OrderedList l u â†’ Set (ğ‘¼âŸ¨<âŸ© âŠ” ğ‘¼âŸ¨KeyâŸ©) where
      here : âˆ€ {ks : OrderedList [ k ] u} {{p : l <âº [ k ] }} â†’ k âˆˆâ‚— (k âˆ· ks)
      succ : âˆ€ {k' : Key} {ks : OrderedList [ k' ] u} {{p : l <âº [ k' ] }} â†’ k âˆˆâ‚— ks â†’ k âˆˆâ‚— (k' âˆ· ks)
   
    lem'' : âˆ€ {l u} (y : OrderedList l u) (l<u : l <âº u) â†’ (x : âˆ€ (k : Key) â†’ (k âˆˆâ‚— y â†’ _âˆˆâ‚—_ {l} {u} k [])) â†’ [] â‰¡ y
    lem'' {l} {u} ([]) l<uâ‚ x = {!refl!} -- l<uâ‚ != .l<u of type l <âº u
    lem'' (k âˆ· y) l<u xâ‚ = {!!}
    
    lem' : âˆ€ {l u} (y : OrderedList l u) (l<u : l <âº u) â†’ (x : âˆ€ (k : Key) â†’ (k âˆˆâ‚— y â†’ _âˆˆ_ {l} k (leaf l<u))) â†’ [] â‰¡ y
    lem' {l} {u} ([]) l<uâ‚ x = {!refl!} -- l<uâ‚ != .l<u of type l <âº u
    lem' (k âˆ· y) l<u xâ‚ = {!!}
    
    lem : âˆ€ {l u} (y : OrderedList l u) (l<u : l <âº u) â†’ (x : âˆ€ (k : Key) â†’ (_âˆˆ_ {l} k (leaf l<u) â†’ k âˆˆâ‚— y) Ã— (k âˆˆâ‚— y â†’ _âˆˆ_ {l} k (leaf l<u))) â†’ [] â‰¡ y
    lem {l} {u} ([]) l<uâ‚ x = {!refl!} -- l<uâ‚ != .l<u of type l <âº u
    lem (k âˆ· y) l<u xâ‚ = {!!}
   
    LEM : âˆ€ { l u } k {a : OrderedList l [ k ]} {b : OrderedList [ k ] u} â†’ k âˆˆâ‚— (a ++ (k âˆ· b))
    LEM k {[]} = here
    LEM k {kâ‚ âˆ· a} = succ (LEM k {a})
   
    LEM2 : âˆ€ { l m u } {a : OrderedList l m} {b : âˆ€ {m'} {{_ : m' <âº m}} â†’ OrderedList m' u} â†’ âˆ€ k â†’ k âˆˆâ‚— a â†’ k âˆˆâ‚— (a ++ b)
    LEM2 = {!!}
   
    lemma1 : âˆ€ {l u h} â†’ (t : Tree l u h) â†’ (o : OrderedList l u) â†’ o â‰¡ toOrderedList t â†’ âˆ€ k â†’ k âˆˆ t â†’ k âˆˆâ‚— o
    lemma1 ._ ._ refl k (here {tâƒ– = tâƒ–}) = LEM k {a = toOrderedList tâƒ–}
    lemma1 (node k1 tl tr bal) ._ refl k (left x1) = LEM2 k (lemma1 _ _ refl k x1)
    lemma1 ._ ._ refl k (right xâ‚) = {!!}
   
    lemma2 : âˆ€ {kâ‚ hË¡ hÊ³ h k l u} {bal      : hË¡ âˆ¼ hÊ³ âŠ” h} {tr       : Tree [ projâ‚ k ] u hÊ³} {tl       : Tree l [ projâ‚ k ] hË¡}
               (x : kâ‚ âˆˆâ‚— (toOrderedList tl ++ (Î» {m} {-{_ : {!!}}-} â†’ projâ‚ k âˆ· toOrderedList tr))) â†’
               kâ‚ âˆˆ node k tl tr bal
    lemma2 {tl = leaf l<u} here = here
    lemma2 {tl = leaf l<u} (succ x) = {!!}
    lemma2 {tl = node k tl tlâ‚ balâ‚} x = {!!}
   
    toOrderedList' : âˆ€ {l u h} â†’ (t : Tree l u h) â†’ âˆƒ! _â‰¡_ Î» (o : OrderedList l u) â†’ âˆ€ k â†’ (k âˆˆ t â†’ k âˆˆâ‚— o) Ã— (k âˆˆâ‚— o â†’ k âˆˆ t)
    toOrderedList' (leaf l<u) = [] , (Î» k â†’ (Î» ()) , (Î» ())) , (Î» x â†’ (lem _ l<u x))
    toOrderedList' (node k tl tr bal) = toOrderedList tl ++ (projâ‚ k âˆ· toOrderedList tr) , (Î» kâ‚ â†’ (Î» x â†’ lemma1 (node k tl tr bal) (toOrderedList tl ++ (projâ‚ k âˆ· toOrderedList tr)) refl kâ‚ x) , (Î» x â†’ {!!})) , (Î» x â†’ {!!}) where
      
   
   
   
    lemjl- : âˆ€ { kâƒ–â‚ kâƒ—â‚ hâ‚ kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ } â†’
             ( tâ‚ : Tree kâƒ–â‚ kâƒ—â‚ hâ‚ )
             ( tâ‚‚ : Tree kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ )
             ( _ : âˆ€ {kv} â†’ kv âˆˆÌŒ tâ‚ â†’ kv âˆˆÌŒ tâ‚‚ )
             ( _ : âˆ€ {kv} â†’ kv âˆˆÌŒ tâ‚‚ â†’ kv âˆˆÌŒ tâ‚ ) â†’
             ( lst : List KV ) â†’
             (toDiffList tâ‚) lst â‰¡ (toDiffList tâ‚‚) lst
    lemjl- (leaf l<u) (leaf l<uâ‚) xâ‚‚ xâ‚ƒ lst = P.refl
    lemjl- (leaf l<u) (node kâ‚ tâ‚‚ tâ‚ƒ bal) xâ‚‚ xâ‚ƒ lst = contradiction (xâ‚ƒ here) (Î» ())
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (leaf l<u) xâ‚‚ xâ‚ƒ lst = contradiction (xâ‚‚ here) (Î» ())
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ lst with compare (projâ‚ kâ‚) (projâ‚ kâ‚‚)
    lemjl- (node ( kâ‚ , vâ‚ ) tâ‚ tâ‚‚ _) (node ( kâ‚‚ , vâ‚‚ ) tâ‚ƒ tâ‚„ _) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | triâ‰ˆ kâ‚â‰®kâ‚‚ kâ‚â‰¡kâ‚‚ kâ‚‚â‰®kâ‚ rewrite kâ‚â‰¡kâ‚‚ | âˆˆÌƒâ†’v2â‰¡v1 (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here) with duh kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ (âˆˆÌƒâ†’v2â‰¡v1 (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here))
    lemjl- (node ( kâ‚ , vâ‚ ) tâ‚ tâ‚‚ _) (node ( kâ‚‚ , vâ‚‚ ) tâ‚ƒ tâ‚„ _) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | triâ‰ˆ kâ‚â‰®kâ‚‚ kâ‚â‰¡kâ‚‚ kâ‚‚â‰®kâ‚ | kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚' rewrite lemjl- tâ‚‚ tâ‚„ (t2â†’t4 kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚') (t2â†’t4 kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) lst = lemjl- tâ‚ tâ‚ƒ (t1â†’t3 kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚') (t1â†’t3 kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) ((kâ‚‚ , vâ‚) List.âˆ· toDiffList tâ‚„ lst)
    lemjl- (node kâ‚ tâ‚ (leaf l<u) bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri< kâ‚<kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚â‰®kâ‚ = contradiction {!!} {!!}
    lemjl- (node kâ‚ tâ‚ (node k tâ‚‚ tâ‚ƒ bal) balâ‚) (node kâ‚‚ (leaf l<u) tâ‚… balâ‚‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri< kâ‚<kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚â‰®kâ‚ = contradiction {!!} {!!}
    lemjl- (node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… _) _) (node kâ‚„' (node kâ‚‚' tâ‚' tâ‚ƒ' _) tâ‚…' _) âˆˆÌŒtâ†’âˆˆÌŒt' âˆˆÌŒt'â†’âˆˆÌŒt lst | tri< kâ‚‚<kâ‚„' _ _ with compare (projâ‚ kâ‚„) (projâ‚ kâ‚‚')
    lemjl- (node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… _) _) (node kâ‚„' (node kâ‚‚' tâ‚' tâ‚ƒ' _) tâ‚…' _) âˆˆÌŒtâ†’âˆˆÌŒt' âˆˆÌŒt'â†’âˆˆÌŒt lst | tri< kâ‚‚<kâ‚„' _ _ | tri< kâ‚„<kâ‚‚' _ _ = {!!}
    lemjl- (node kâ‚‚ tâ‚ (node (kâ‚„ , _) tâ‚ƒ tâ‚… _) _) (node kâ‚„' (node (kâ‚‚' , _) tâ‚' tâ‚ƒ' _) tâ‚…' _) âˆˆÌŒtâ†’âˆˆÌŒt' âˆˆÌŒt'â†’âˆˆÌŒt lst | tri< kâ‚‚<kâ‚„' _ _ | triâ‰ˆ _ kâ‚„â‰¡kâ‚‚' _ rewrite kâ‚„â‰¡kâ‚‚' = {!!}
    lemjl- (node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… _) _) (node kâ‚„' (node kâ‚‚' tâ‚' tâ‚ƒ' _) tâ‚…' _) âˆˆÌŒtâ†’âˆˆÌŒt' âˆˆÌŒt'â†’âˆˆÌŒt lst | tri< kâ‚‚<kâ‚„' _ _ | tri> _ _ kâ‚„â‰®kâ‚‚' = {!!}
   
    -- kv<kâ†’kvâˆˆt1 kâ‚<kâ‚‚ (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here)
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri> kâ‚â‰®kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚<kâ‚ = {!!}
   
  {-
    data OrderedList : Maybe Key â†’Maybe Key â†’ Set ( ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨<âŸ© ) where
      [] : OrderedList âŠ¥âº âŠ¤âº
      _âˆ·_ : (x : Keyâº) â†’ {x- x+ : Keyâº} â†’ {{_ : x- <âº x}} â†’ (xs : OrderedList x- x+) â†’ OrderedList x x+
   
    _++_ : âˆ€ {a- a+ b- b+} â†’ {{_ : a+ <âº b- }} â†’ OrderedList a- a+ â†’ OrderedList b- b+ â†’ OrderedList a- b+
    [] ++ u = {!u!}
    (x âˆ· l) ++ u = {!!}
   
    toOrderedList : âˆ€ {l u h} â†’ Tree l u h â†’ âˆƒ Î» k- â†’ âˆƒ Î» k+ â†’ OrderedList k- k+
    toOrderedList (leaf l<u) = _ , _ , []
    toOrderedList (node kâ‚ t tâ‚ bal) = toOrderedList tâ‚
  -}
   
  {-
    lemjl- : âˆ€ { kâƒ–â‚ kâƒ—â‚ hâ‚ kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ } â†’
             ( tâ‚ : Tree kâƒ–â‚ kâƒ—â‚ hâ‚ )
             ( tâ‚‚ : Tree kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ )
             ( _ : âˆ€ {kv} â†’ kv âˆˆÌŒ tâ‚ â†’ kv âˆˆÌŒ tâ‚‚ )
             ( _ : âˆ€ {kv} â†’ kv âˆˆÌŒ tâ‚‚ â†’ kv âˆˆÌŒ tâ‚ ) â†’
             ( lst : List KV ) â†’
             (toDiffList tâ‚) lst â‰¡ (toDiffList tâ‚‚) lst
    lemjl- (leaf l<u) (leaf l<uâ‚) xâ‚‚ xâ‚ƒ lst = P.refl
    lemjl- (leaf l<u) (node kâ‚ tâ‚‚ tâ‚ƒ bal) xâ‚‚ xâ‚ƒ lst = contradiction (xâ‚ƒ here) (Î» ())
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (leaf l<u) xâ‚‚ xâ‚ƒ lst = contradiction (xâ‚‚ here) (Î» ())
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ lst with compare (projâ‚ kâ‚) (projâ‚ kâ‚‚)
    lemjl- (node ( kâ‚ , vâ‚ ) tâ‚ tâ‚‚ _) (node ( kâ‚‚ , vâ‚‚ ) tâ‚ƒ tâ‚„ _) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | triâ‰ˆ kâ‚â‰®kâ‚‚ kâ‚â‰¡kâ‚‚ kâ‚‚â‰®kâ‚ rewrite kâ‚â‰¡kâ‚‚ | âˆˆÌƒâ†’v2â‰¡v1 (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here) with duh kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ (âˆˆÌƒâ†’v2â‰¡v1 (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here))
    lemjl- (node ( kâ‚ , vâ‚ ) tâ‚ tâ‚‚ _) (node ( kâ‚‚ , vâ‚‚ ) tâ‚ƒ tâ‚„ _) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | triâ‰ˆ kâ‚â‰®kâ‚‚ kâ‚â‰¡kâ‚‚ kâ‚‚â‰®kâ‚ | kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚' rewrite lemjl- tâ‚‚ tâ‚„ (t2â†’t4 kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚') (t2â†’t4 kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) lst = lemjl- tâ‚ tâ‚ƒ (t1â†’t3 kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚') (t1â†’t3 kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) ((kâ‚‚ , vâ‚) List.âˆ· toDiffList tâ‚„ lst)
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri< kâ‚<kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚â‰®kâ‚ = {!!} -- kv<kâ†’kvâˆˆt1 kâ‚<kâ‚‚ (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here)
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri> kâ‚â‰®kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚<kâ‚ = {!!}
  -}  
   
  {-
    lemjl- : âˆ€ { kâƒ–â‚ kâƒ—â‚ hâ‚ kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ } â†’
             ( tâ‚ : Tree kâƒ–â‚ kâƒ—â‚ hâ‚ )
             ( tâ‚‚ : Tree kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ )
             ( _ : âˆ€ {kv} â†’ kv âˆˆÌŒ tâ‚ â†’ kv âˆˆÌŒ tâ‚‚ )
             ( _ : âˆ€ {kv} â†’ kv âˆˆÌŒ tâ‚‚ â†’ kv âˆˆÌŒ tâ‚ ) â†’
             ( lst : List KV ) â†’
             (toDiffList tâ‚) lst â‰¡ (toDiffList tâ‚‚) lst
    lemjl- (leaf l<u) (leaf l<uâ‚) xâ‚‚ xâ‚ƒ lst = P.refl
    lemjl- (leaf l<u) (node kâ‚ tâ‚‚ tâ‚ƒ bal) xâ‚‚ xâ‚ƒ lst = contradiction (xâ‚ƒ here) (Î» ())
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (leaf l<u) xâ‚‚ xâ‚ƒ lst = contradiction (xâ‚‚ here) (Î» ())
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ lst with compare (projâ‚ kâ‚) (projâ‚ kâ‚‚)
    lemjl- (node ( kâ‚ , vâ‚ ) tâ‚ tâ‚‚ bal) (node ( kâ‚‚ , vâ‚‚ ) tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | triâ‰ˆ kâ‚â‰®kâ‚‚ kâ‚â‰¡kâ‚‚ kâ‚‚â‰®kâ‚ rewrite
           kâ‚â‰¡kâ‚‚ -- |
           -- âˆˆÌƒâ†’v1â‰¡v2 (kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ here) |
           -- | âˆˆÌƒâ†’v2â‰¡v1 (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here)
           -- lemjl- tâ‚‚ tâ‚„ (t2â†’t4 kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚) {!!} lst -- (t2â†’t4 kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) -- subst (âˆˆÌƒâ†’v1â‰¡v2 (kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ here)) kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚
           = {!!} -- lemjl- tâ‚ tâ‚ƒ {!!} {!!} ((kâ‚‚ , vâ‚‚) L.âˆ· toDiffList tâ‚„ lst)
    -- (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here) -- kâ‚‚ âˆ¼ vâ‚ âˆˆÌƒ node (kâ‚‚ , vâ‚‚) tâ‚ƒ tâ‚„ balâ‚
    -- (kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ here) -- kâ‚‚ âˆ¼ vâ‚‚ âˆˆÌƒ node (kâ‚‚ , vâ‚) tâ‚ tâ‚‚ bal
    -- kâ†’v' (kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ here) (kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ here)
   
  -- {-kâ†’v'-}  {! (lemjl- tâ‚‚ tâ‚„ (? kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚) (? kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) lst)!}
    -- subst {!!} (lemjl- tâ‚‚ tâ‚„ ({!!} kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚) ({!!} kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚) lst) {!!} where
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri< kâ‚<kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚â‰®kâ‚ = {!!}
    lemjl- (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) kvâˆˆÌŒtâ‚â†’kvâˆˆÌŒtâ‚‚ kvâˆˆÌŒtâ‚‚â†’kvâˆˆÌŒtâ‚ lst | tri> kâ‚â‰®kâ‚‚ kâ‚â‰¢kâ‚‚ kâ‚‚<kâ‚ = {!!}
  -}
    
    lemjl+ : âˆ€ { kâƒ–â‚ kâƒ—â‚ hâ‚ kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ } â†’
             ( tâ‚ : Tree kâƒ–â‚ kâƒ—â‚ hâ‚ )
             ( tâ‚‚ : Tree kâƒ–â‚‚ kâƒ—â‚‚ hâ‚‚ )
             ( _ : âˆ€ {kv} â†’ projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ tâ‚ â†’ projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ tâ‚‚ )
             ( _ : âˆ€ {kv} â†’ projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ tâ‚‚ â†’ projâ‚ kv âˆ¼ projâ‚‚ kv âˆˆÌƒ tâ‚ ) â†’
             (toDiffList tâ‚) L.[] â‰… (toDiffList tâ‚‚) L.[]
    lemjl+ (leaf l<u) (leaf l<uâ‚) xâ‚‚ xâ‚ƒ = H.refl
    lemjl+ (leaf l<u) (node kâ‚ tâ‚‚ tâ‚ƒ bal) xâ‚‚ xâ‚ƒ = contradiction (xâ‚ƒ here) (Î» ())
    lemjl+ (node kâ‚ tâ‚ tâ‚‚ bal) (leaf l<u) xâ‚‚ xâ‚ƒ = contradiction (xâ‚‚ here) (Î» ())
    lemjl+ (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ with compare (projâ‚ kâ‚) (projâ‚ kâ‚‚)
    lemjl+ (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ | tri< a Â¬b Â¬c = {!!}
    lemjl+ (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ | triâ‰ˆ Â¬a b Â¬c = {!!}
    lemjl+ (node kâ‚ tâ‚ tâ‚‚ bal) (node kâ‚‚ tâ‚ƒ tâ‚„ balâ‚) xâ‚‚ xâ‚ƒ | tri> Â¬a Â¬b c = {!!}
   
    joinË¡âº! : âˆ€ {l u hË¡ hÊ³ h} â†’
              (k : KV) â†’
              (tl+ : (âˆƒ Î» i â†’ Tree l [ projâ‚ k ] (i âŠ• hË¡))) â†’
              (tr : Tree [ projâ‚ k ] u hÊ³) â†’
              (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
              âˆƒ Î» i â†’ âˆƒ! _â‰¡_ Î» (t : Tree l u (i âŠ• (1 + h))) â†’
              (âˆ€ (k' : Key) (v' : Value k') â†’
              (  (k' âˆ¼ v' âˆˆÌƒ projâ‚‚ tl+ â†’ k' âˆ¼ v' âˆˆÌƒ t)
               Ã— (k' âˆ¼ v' âˆˆÌƒ tr â†’ k' âˆ¼ v' âˆˆÌƒ t)
               Ã— (k' âˆ¼ v' âˆˆÌƒ t â†’ (k' âˆ¼ v' âˆˆÌƒ projâ‚‚ tl+) âŠ (k' âˆ¼ v' âˆˆÌƒ tr) âŠ ((k' , v') â‰¡ k) )
               Ã— (projâ‚ k âˆ¼ projâ‚‚ k âˆˆÌƒ t)
               ))
    joinË¡âº! kâ‚† (1# , node kâ‚‚ tâ‚
                      (node kâ‚„ tâ‚ƒ tâ‚… bal)
                                  âˆ¼+) tâ‚‡ âˆ¼-  = 0# , node kâ‚„
                                                          (node kâ‚‚ tâ‚ tâ‚ƒ (maxâˆ¼ bal))
                                                          (node kâ‚† tâ‚… tâ‚‡ (âˆ¼max bal))
                                                          âˆ¼0 , (Î» k' v' â†’ proof , (Î» x â†’ right (right x)) , proof2 , right here) , (Î» x â†’ {!!})
               where
      proof : âˆ€ {k' kâ‚‚ tâ‚l tâ‚h kâ‚„ tâ‚ƒh kâ‚† tâ‚…h tâ‚‡u bal}
                {v' : Value k'}
                {tâ‚ : Tree tâ‚l [ projâ‚ kâ‚‚ ] tâ‚h}
                {tâ‚ƒ : Tree [ projâ‚ kâ‚‚ ] [ projâ‚ kâ‚„ ] tâ‚ƒh}
                {tâ‚… : Tree [ projâ‚ kâ‚„ ] [ projâ‚ kâ‚† ] tâ‚…h}
                {tâ‚‡ : Tree [ projâ‚ kâ‚† ] tâ‚‡u tâ‚h}  â†’
                k' âˆ¼ v' âˆˆÌƒ node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… bal) âˆ¼+ â†’
                k' âˆ¼ v' âˆˆÌƒ node kâ‚„ (node kâ‚‚ tâ‚ tâ‚ƒ (maxâˆ¼ bal)) (node kâ‚† tâ‚… tâ‚‡ (âˆ¼max bal)) âˆ¼0
      proof here = left here
      proof (left x) = left (left x)
      proof (right here) = here
      proof (right (left x)) = left (right x)
      proof (right (right x)) = right (left x)
   
      proof2 : âˆ€ {k' kâ‚‚ tâ‚l tâ‚h kâ‚„ tâ‚ƒh kâ‚† tâ‚…h tâ‚‡u bal}
                {v' : Value k'}
                {tâ‚ : Tree tâ‚l [ projâ‚ kâ‚‚ ] tâ‚h}
                {tâ‚ƒ : Tree [ projâ‚ kâ‚‚ ] [ projâ‚ kâ‚„ ] tâ‚ƒh}
                {tâ‚… : Tree [ projâ‚ kâ‚„ ] [ projâ‚ kâ‚† ] tâ‚…h}
                {tâ‚‡ : Tree [ projâ‚ kâ‚† ] tâ‚‡u tâ‚h}  â†’
               k' âˆ¼ v' âˆˆÌƒ node kâ‚„ (node kâ‚‚ tâ‚ tâ‚ƒ (maxâˆ¼ bal)) (node kâ‚† tâ‚… tâ‚‡ (âˆ¼max bal)) âˆ¼0 â†’
               k' âˆ¼ v' âˆˆÌƒ node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… bal) âˆ¼+ âŠ k' âˆ¼ v' âˆˆÌƒ tâ‚‡ âŠ ((k' , v') â‰¡ kâ‚†)
      proof2 here = injâ‚ (right here)
      proof2 (left here) = injâ‚ here
      proof2 (left (left x)) = injâ‚ (left x)
      proof2 (left (right x)) = injâ‚ (right (left x))
      proof2 (right here) = injâ‚‚ (injâ‚‚ P.refl)
      proof2 (right (left x)) = injâ‚ (right (right x))
      proof2 (right (right x)) = injâ‚‚ (injâ‚ x)
      
    joinË¡âº! kâ‚„ (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼-) tâ‚… âˆ¼-  = 0# , node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… âˆ¼0) âˆ¼0 , {!!}
    joinË¡âº! kâ‚„ (1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0) tâ‚… âˆ¼-  = 1# , node kâ‚‚ tâ‚ (node kâ‚„ tâ‚ƒ tâ‚… âˆ¼-) âˆ¼+ , {!!}
    joinË¡âº! kâ‚‚ (1# , tâ‚)               tâ‚ƒ âˆ¼0  = 1# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼- , {!!}
    joinË¡âº! kâ‚‚ (1# , tâ‚)               tâ‚ƒ âˆ¼+  = 0# , node kâ‚‚ tâ‚ tâ‚ƒ âˆ¼0 , {!!}
    joinË¡âº! kâ‚‚ (0# , tâ‚)               tâ‚ƒ bal = 0# , node kâ‚‚ tâ‚ tâ‚ƒ bal , {!!}
   
  ------------------------------------------------------------------------
  -- Types and functions with hidden indices
   
  data Tree : Set (ğ‘¼âŸ¨KeyâŸ© âŠ” ğ‘¼âŸ¨ValueâŸ© âŠ” ğ‘¼âŸ¨<âŸ©) where
    tree : let open Extended-key in
           âˆ€ {h} â†’ Indexed.Tree âŠ¥âº âŠ¤âº h â†’ Tree
   
  empty : Tree
  empty = tree (Indexed.empty _)
   
  singleton : (k : Key) â†’ Value k â†’ Tree
  singleton k v = tree (Indexed.singleton k v _)
   
  insert : (k : Key) â†’ Value k â†’ Tree â†’ Tree
  insert k v (tree t) = tree $ projâ‚‚ $ Indexed.insert k v t _
   
  insertWith : (k : Key) â†’ Value k â†’ (Value k â†’ Value k â†’ Value k) â†’
               Tree â†’ Tree
  insertWith k v f (tree t) = tree $ projâ‚‚ $ Indexed.insertWith k v f t _
   
  delete : Key â†’ Tree â†’ Tree
  delete k (tree t) = tree $ projâ‚‚ $ Indexed.delete k t
   
  lookup : (k : Key) â†’ Tree â†’ Maybe (Value k)
  lookup k (tree t) = Indexed.lookup k t
   
  map : ({k : Key} â†’ Value k â†’ Value k) â†’ Tree â†’ Tree
  map f (tree t) = tree $ Indexed.map f t
   
  infix 4 _âˆˆ?_
   
  _âˆˆ?_ : Key â†’ Tree â†’ Bool
  k âˆˆ? t = is-just (lookup k t)
   
  headTail : Tree â†’ Maybe (KV Ã— Tree)
  headTail (tree (Indexed.leaf _)) = nothing
  headTail (tree {h = suc _} t)    with Indexed.headTail t
  ... | (k , _ , _ , tâ€²) = just (k , tree (Indexed.castË¡ _ tâ€²))
   
  initLast : Tree â†’ Maybe (Tree Ã— KV)
  initLast (tree (Indexed.leaf _)) = nothing
  initLast (tree {h = suc _} t)    with Indexed.initLast t
  ... | (k , _ , _ , tâ€²) = just (tree (Indexed.castÊ³ tâ€² _) , k)
   
  -- The input does not need to be ordered.
   
  fromList : List KV â†’ Tree
  fromList = List.foldr (uncurry insert) empty
   
  -- Returns an ordered list.
   
  toList : Tree â†’ List KV
  toList (tree t) = DiffList.toList (Indexed.toDiffList t)
   
  -- Naive implementations of union.
   
  unionWith : (âˆ€ {k} â†’ Value k â†’ Value k â†’ Value k) â†’
              -- Left â†’ right â†’ result.
              Tree â†’ Tree â†’ Tree
  unionWith f tâ‚ tâ‚‚ =
    List.foldr (Î» { (k , v) â†’ insertWith k v f }) tâ‚‚ (toList tâ‚)
   
  -- Left-biased.
   
  union : Tree â†’ Tree â†’ Tree
  union = unionWith const
   
  unionsWith : (âˆ€ {k} â†’ Value k â†’ Value k â†’ Value k) â†’ List Tree â†’ Tree
  unionsWith f ts = List.foldr (unionWith f) empty ts
   
  -- Left-biased.
   
  unions : List Tree â†’ Tree
  unions = unionsWith const

-}


