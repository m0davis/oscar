open import Data.Empty
open import Data.Product
open import Level using (_⊔_)
open import Relation.Binary
open import Relation.Binary.PropositionalEquality as P using (_≡_)
open import Relation.Nullary

module Data.AVL.Properties
  {k v ℓ}
  {Key : Set k} (Value : Key → Set v)
  {_<_ : Rel Key ℓ}
  (isStrictTotalOrder : IsStrictTotalOrder P._≡_ _<_) where

open import Data.AVL Value isStrictTotalOrder using (KV; module Extended-key; module Height-invariants; module Indexed)
open Extended-key
open Height-invariants
open Indexed

open IsStrictTotalOrder isStrictTotalOrder

data _∈_ {lb ub} (key : Key) : ∀ {n} → Tree lb ub n → Set (k ⊔ v ⊔ ℓ) where
  here : ∀ {hˡ hʳ h v}
    {lk : Tree lb [ key ] hˡ}
    {ku : Tree [ key ]  ub hʳ}
    {bal : hˡ ∼ hʳ ⊔ h} →
    key ∈ node (key , v) lk ku bal
  left : ∀ {hˡ hʳ h k′} {v′ : Value k′}
    {lk′ : Tree lb [ k′ ] hˡ}
    {k′u : Tree [ k′ ] ub hʳ}
    {bal : hˡ ∼ hʳ ⊔ h} →
    key ∈ lk′ →
    key ∈ node (k′ , v′) lk′ k′u bal
  right : ∀ {hˡ hʳ h k′} {v′ : Value k′}
    {lk′ : Tree lb [ k′ ] hˡ}
    {k′u : Tree [ k′ ] ub hʳ}
    {bal : hˡ ∼ hʳ ⊔ h} →
    key ∈ k′u →
    key ∈ node (k′ , v′) lk′ k′u bal

lemJoinˡ⁺IsCorrect : ∀ { l r hˡ hʳ h }
    { k′ : Key }
    { v′ : Value k′ }
    ( tˡ⁺ : ∃ λ i → Tree l [ k′ ] ( i ⊕ hˡ ) )
    ( tʳ : Tree [ k′ ] r hʳ )
    ( bal : hˡ ∼ hʳ ⊔ h )
    { key : Key }
    ( k∈tˡ : key ∈ proj₂ tˡ⁺ ) →
    key ∈ proj₂ ( joinˡ⁺ ( k′ , v′ ) tˡ⁺ tʳ bal )
lemJoinˡ⁺IsCorrect ( 1# , node _ _ ( node _ _ _ _ ) ∼+ ) _ ∼- here = left here
lemJoinˡ⁺IsCorrect ( 1# , node _ _ ( node _ _ _ _ ) ∼+ ) _ ∼- ( left k∈tˡ ) = left ( left k∈tˡ )
lemJoinˡ⁺IsCorrect ( 1# , node _ _ ( node _ _ _ _ ) ∼+ ) _ ∼- ( right here ) = here
lemJoinˡ⁺IsCorrect ( 1# , node _ _ ( node _ _ _ _ ) ∼+ ) _ ∼- ( right ( left k∈tʳˡ ) ) = left ( right k∈tʳˡ )
lemJoinˡ⁺IsCorrect ( 1# , node _ _ ( node _ _ _ _ ) ∼+ ) _ ∼- ( right ( right k∈tʳʳ ) ) = right ( left k∈tʳʳ )
lemJoinˡ⁺IsCorrect ( 1# , node _ _ _ ∼- ) _ ∼- here = {!here!}
lemJoinˡ⁺IsCorrect ( 1# , node _ _ _ ∼- ) _ ∼- ( left k∈tˡˡ ) = {!left k∈tˡˡ!}
lemJoinˡ⁺IsCorrect ( 1# , node _ _ _ ∼- ) _ ∼- ( right k∈tˡʳ ) = {!right ( left ( k∈tˡʳ ) )!}
lemJoinˡ⁺IsCorrect ( 1# , node _ _ _ ∼0 ) _ ∼- here = {!here!}
lemJoinˡ⁺IsCorrect ( 1# , node _ _ _ ∼0 ) _ ∼- ( left k∈tˡˡ ) = {!left k∈tˡˡ!}
lemJoinˡ⁺IsCorrect ( 1# , node _ _ _ ∼0 ) _ ∼- ( right k∈tˡʳ ) = {!right ( left ( k∈tˡʳ ) )!}
lemJoinˡ⁺IsCorrect ( 1# , _ ) _ ∼0 k∈tˡ = {!left k∈tˡ!}
lemJoinˡ⁺IsCorrect ( 1# , _ ) _ ∼+ k∈tˡ = {!left k∈tˡ!}
lemJoinˡ⁺IsCorrect ( 0# , _ ) _ _ k∈tˡ = left k∈tˡ



l<⁺u : ∀ { l u h } → Tree l u h → l <⁺ u
l<⁺u ( leaf l<u ) = l<u
l<⁺u { l = l } ( node _ lk ku _ ) = trans⁺ l ( l<⁺u lk ) ( l<⁺u ku )


lemK∈Bounds : ∀ { l u h } { t : Tree l u h } { key : Key } → key ∈ t → l < key < u
lemK∈Bounds ( here {lk = lk} {ku = ku} ) = ( l<⁺u lk ) , ( l<⁺u ku )
lemK∈Bounds { l = l } { u = u } { key = key } ( left { k′ = k′ } { k′u = k′u } k∈tˡ ) = l<k , k<u where

  l<k<k′ : l < key < [ k′ ]
  l<k<k′ = lemK∈Bounds k∈tˡ

  l<k : l <⁺ [ key ]
  l<k = proj₁ l<k<k′

  k<k′ : [ key ] <⁺ [ k′ ]
  k<k′ = proj₂ l<k<k′

  k′<u : [ k′ ] <⁺ u
  k′<u = l<⁺u k′u

  k<u : [ key ] <⁺ u
  k<u = trans⁺ [ key ] { m = [ k′ ] } { u = u } k<k′ k′<u

lemK∈Bounds { l = l } { u = u } { key = key } ( right { k′ = k′ } { lk′ = lk′ } k∈tʳ ) = l<k , k<u where

  k′<k<u : [ k′ ] < key < u
  k′<k<u = lemK∈Bounds k∈tʳ

  k<u : [ key ] <⁺ u
  k<u = proj₂ k′<k<u

  k′<k : [ k′ ] <⁺ [ key ] 
  k′<k = proj₁ k′<k<u

  l<k′ : l <⁺ [ k′ ]
  l<k′ = l<⁺u lk′

  l<k : l <⁺ [ key ]
  l<k = trans⁺ l { m = [ k′ ] } { u = [ key ] } l<k′ k′<k

module ∈-simple where

  open import Relation.Binary.PropositionalEquality
  open import Function
  open import Relation.Nullary.Negation

  open import Data.Maybe

  𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ : ∀ { l u h } ( k : Key ) ( t : Tree l u h ) → ( ∃ λ v → lookup k t ≡ just v ) → k ∈ t
  𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ _ (leaf _) (_ , ())
  𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ k ( node ( kₜ , vₜ ) tₗ tᵤ _ ) lookup⟶ with compare k kₜ
  ... | tri< k<kₜ _ _              = left  ( 𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ k tₗ lookup⟶ )
  ... | tri> _ _ kₜ<k              = right ( 𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ k tᵤ lookup⟶ )
  ... | tri≈ _ k≡kₜ _ rewrite k≡kₜ = here

  𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup : ∀ { l u h } ( k : Key ) ( t : Tree l u h ) → k ∈ t → ∃ λ v → lookup k t ≡ just v
  𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup _ ( leaf _ ) ()
  𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k ( node ._ _ _ ._ ) here with compare k k
  ... | tri< _ k≢k _ = contradiction refl k≢k
  ... | tri≈ _ refl _ = , refl
  ... | tri> _ k≢k _ = contradiction refl k≢k
  𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k ( node ( k' , _ ) tₗ _ ._ ) ( left k∈tₗ ) with compare k k'
  ... | tri< _ _ _ = 𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k tₗ k∈tₗ
  ... | tri≈ k≮k' _ _ = contradiction k<k' k≮k'
    where k<k' = proj₂ (lemK∈Bounds k∈tₗ)
  ... | tri> k≮k' _ _ = contradiction k<k' k≮k'
    where k<k' = proj₂ (lemK∈Bounds k∈tₗ)
  𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k ( node ( k' , _ ) _ tᵣ ._ ) ( right k∈tᵣ ) with compare k k'
  ... | tri< _ _ k≯k' = contradiction {!k'<k!} k≯k'
  ... | tri≈ _ _ k≯k' = contradiction {!k'<k!} k≯k'
  ... | tri> _ _ _ = 𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k tᵣ k∈tᵣ

  open import Data.Nat.Base using (suc)









































{-

module ∈-with-ordering where

  data _∈_ {lb ub} (K : Key) : ∀ {n} → Tree lb ub n → Set (κ ⊔ υ ⊔ ℓ) where
    here : ∀ {hˡ hʳ} V 
      {l : Tree lb [ K  ] hˡ}
      {r : Tree [ K ]  ub hʳ}
      {b : ∃ λ h → hˡ ∼ hʳ ⊔ h} →
      K ∈ node (K , V) l r (proj₂ b)
    left : ∀ {hˡ hʳ K′} {V : Value K′}
      {l : Tree lb [ K′ ] hˡ}
      {r : Tree [ K′ ] ub hʳ}
      {b : ∃ λ h → hˡ ∼ hʳ ⊔ h} →
      K < K′ →
      K ∈ l →
      K ∈ node (K′ , V) l r (proj₂ b)
    right : ∀ {hˡ hʳ K′} {V : Value K′}
      {l : Tree lb [ K′ ] hˡ}
      {r : Tree [ K′ ] ub hʳ}
      {b : ∃ λ h → hˡ ∼ hʳ ⊔ h} →
      K′ < K →
      K ∈ r →
      K ∈ node (K′ , V) l r (proj₂ b)

  private
    _≮_ = λ x y → ¬ (x < y)
    _≯_ = λ x y → ¬ (y < x)

    _≢_ : (x y : Key) → _
    _≢_ = λ x y → ¬ (x ≡ y)

  lem : ∀ {lb ub hˡ hʳ h K′ n} {V : Value K′}
      {l : Tree lb [ K′ ] hˡ}
      {r : Tree [ K′ ] ub hʳ}
      {b : hˡ ∼ hʳ ⊔ h} →
      n ∈ node (K′ , V) l r b →
      (n ≯ K′ → n ≢ K′ → n ∈ l) × (n ≮ K′ → n ≢ K′ → n ∈ r)
  lem (here    V) = (λ _ eq → ⊥-elim (eq P.refl)) , (λ _ eq → ⊥-elim (eq P.refl))
  lem (left  x p) = (λ _ _ → p) , (λ ≮ _ → ⊥-elim (≮ x))
  lem (right x p) = (λ ≯ _ → ⊥-elim (≯ x)) , (λ _ _ → p)

  find : ∀ {h lb ub} n (m : Tree lb ub h) → Dec (n ∈ m)
  find n (leaf _) = no λ ()
  find n (node (k , v) l r _) with compare n k
  find n (node (k , v) l r _) | tri< a ¬b ¬c with find n l
  ... | yes p = yes (left a p)
  ... | no ¬p = no λ ¬∈l → ¬p (proj₁ (lem ¬∈l) ¬c ¬b)
  find n (node (k , v) l r _) | tri≈ ¬a b ¬c rewrite (P.sym b) = yes (here v)
  find n (node (k , v) l r _) | tri> ¬a ¬b c with find n r
  ... | yes p = yes (right c p)
  ... | no ¬p = no λ ¬∈r → ¬p (proj₂ (lem ¬∈r) ¬a ¬b)

  get : ∀ {h lb ub n} {m : Tree lb ub h} → n ∈ m → Value n
  get (here    V) = V
  get (left  _ p) = get p
  get (right _ p) = get p

  module lookup where

    open import Relation.Binary.PropositionalEquality
    open import Function
    open import Relation.Nullary.Negation

    open import Data.Maybe

    𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ : ∀ { l u h } ( k : Key ) ( t : Tree l u h ) → l < k < u → ( ∃ λ v → lookup k t ≡ just v ) → k ∈ t
    𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ _ (leaf _) _ (_ , ())
    𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ k ( node ( kₜ , vₜ ) tₗ tᵤ _ ) ( l<k , k<u ) lookup⟶ with compare k kₜ
    ... | tri< k<kₜ _ _              = left  k<kₜ ( 𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ k tₗ ( l<k  , k<kₜ ) lookup⟶ )
    ... | tri> _ _ kₜ<k              = right kₜ<k ( 𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ k tᵤ ( kₜ<k , k<u  ) lookup⟶ )
    ... | tri≈ _ k≡kₜ _ rewrite k≡kₜ = here vₜ

    𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup : ∀ { l u h } ( k : Key ) ( t : Tree l u h ) → l < k < u → k ∈ t → ∃ λ v → lookup k t ≡ just v
    𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup _ ( leaf _ ) _ ()
    𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k ( node ._ _ _ ._ ) _ ( here _ ) with compare k k
    ... | tri< _ k≢k _ = contradiction refl k≢k
    ... | tri≈ _ refl _ = , refl
    ... | tri> _ k≢k _ = contradiction refl k≢k
    𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k ( node ( k' , _ ) tₗ _ ._ ) ( l<k , _ ) ( left k<k' k∈tₗ ) with compare k k'
    ... | tri< _ _ _ = 𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k tₗ ( l<k , k<k' ) k∈tₗ
    ... | tri≈ k≮k' _ _ = contradiction k<k' k≮k'
    ... | tri> k≮k' _ _ = contradiction k<k' k≮k'
    𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k ( node ( k' , _ ) _ tᵣ ._ ) ( _ , k<u ) ( right k'<k k∈tᵣ ) with compare k k'
    ... | tri< _ _ k≯k' = contradiction k'<k k≯k'
    ... | tri≈ _ _ k≯k' = contradiction k'<k k≯k'
    ... | tri> _ _ _ = 𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup k tᵣ ( k'<k , k<u ) k∈tᵣ

  module insertWith where

    data _∈′_ {lb ub} (K : Key) : ∀ {n} → Tree lb ub n → Set (κ ⊔ υ ⊔ ℓ) where
      here : ∀ {hˡ hʳ} V
        {l : Tree lb [ K ] hˡ}
        {r : Tree [ K ] ub hʳ}
        {h : _}
        {b : hˡ ∼ hʳ ⊔ h} →
        K ∈′ node (K , V) l r b
      left : ∀ {hˡ hʳ K′} {V : Value K′}
        {l : Tree lb [ K′ ] hˡ}
        {r : Tree [ K′ ] ub hʳ}
        {h : _} →
        {b : hˡ ∼ hʳ ⊔ h} →
        K < K′ →
        K ∈′ l →
        K ∈′ node (K′ , V) l r b
      right : ∀ {hˡ hʳ K′} {V : Value K′}
        {l : Tree lb [ K′ ] hˡ}
        {r : Tree [ K′ ] ub hʳ}
        {h : _} →
        {b : hˡ ∼ hʳ ⊔ h} →
        K′ < K →
        K ∈′ r →
        K ∈′ node (K′ , V) l r b

    ∈→∈′ : ∀ {lb ub n} {x} {S : Tree lb ub n} → x ∈ S → x ∈′ S
    ∈→∈′ (here V) = here V
    ∈→∈′ (left x₁ x₂) = left x₁ (∈→∈′ x₂)
    ∈→∈′ (right x₁ x₂) = right x₁ (∈→∈′ x₂)

    ∈′→∈ : ∀ {lb ub n} {x} {S : Tree lb ub n} → x ∈′ S → x ∈ S
    ∈′→∈ (here V) = here V
    ∈′→∈ (left x₁ x₂) = left x₁ (∈′→∈ x₂)
    ∈′→∈ (right x₁ x₂) = right x₁ (∈′→∈ x₂)

    lemJoinˡ⁺IsCorrect : ∀ { l r hˡ hʳ h }
        ( k′ : Key )
        ( v′ : Value k′ )
        ( tˡ⁺ : ∃ λ i → Tree l [ k′ ] ( i ⊕ hˡ ) )
        ( tʳ : Tree [ k′ ] r hʳ )
        ( bal : hˡ ∼ hʳ ⊔ h )
        { kh : Key }
        ( k<k′ : kh < k′ )
        ( k∈tˡ : kh ∈ proj₂ tˡ⁺ ) →
        kh ∈ proj₂ ( joinˡ⁺ ( k′ , v′ ) tˡ⁺ tʳ bal )
    lemJoinˡ⁺IsCorrect k′ v′ ( 1# , node ( kˡ , vˡ ) tlˡ ( node ( kʳ , vʳ ) tlʳ tuʳ balʳ ) ∼+ ) t₁ʳ ∼- { kh = kh } k<k′ k∈tˡ with ∈→∈′ k∈tˡ
    lemJoinˡ⁺IsCorrect k′ v′ (1# , node (kˡ , vˡ) tlˡ (node (kʳ , vʳ) tlʳ tuʳ balʳ) ∼+) t₁ʳ ∼- k<k′ k∈tˡ | here .vˡ = left (lemTreeBounds tlʳ) (here vˡ)
    lemJoinˡ⁺IsCorrect k′ v′ (1# , node (kˡ , vˡ) tlˡ (node (kʳ , vʳ) tlʳ tuʳ balʳ) ∼+) t₁ʳ ∼- { kh = kh } k<k′ k∈tˡ | left k<kˡ k∈′tˡ = left {-(trans⁺ {!!} k<kˡ (lemTreeBounds tlʳ))-} {!!} (left k<kˡ (∈′→∈ k∈′tˡ))
    lemJoinˡ⁺IsCorrect k′ v′ (1# , node (kˡ , vˡ) tlˡ (node (kʳ , vʳ) tlʳ tuʳ balʳ) ∼+) t₁ʳ ∼- k<k′ k∈tˡ | right x k∈′tˡ = {!!}
  {-      
    lemJoinˡ⁺IsCorrect k′ v′ ( 1# , node ( kˡ , vˡ ) tlˡ ( node ( kʳ , vʳ ) tlʳ tuʳ balʳ ) ∼+ ) t₁ʳ ∼- { kh = kˡ1 } k<k′ k∈tˡ with ∈→∈′ k∈tˡ
    ... | here .vˡ = left (lemTreeBounds tlʳ) (here vˡ)
    ... | left k<kˡ k∈′tˡ  = left {-(trans⁺ {!!} k<kˡ (lemTreeBounds tlʳ))-} {!!} (left k<kˡ (∈′→∈ k∈′tˡ))
    ... | right _ _ = {!!}
  -}
    lemJoinˡ⁺IsCorrect k′ v′ ( 1# , node k₁ t₁ˡ t₁ʳ ∼- ) tʳ ∼- k<k′ k∈tˡ = {!!}
    lemJoinˡ⁺IsCorrect k′ v′ ( 1# , node k₁ t₁ˡ t₁ʳ ∼0 ) tʳ ∼- k<k′ k∈tˡ = {!!}
    lemJoinˡ⁺IsCorrect k′ v′ ( 1# , tˡ ) tʳ ∼0 k<k′ k∈tˡ = {!!}
    lemJoinˡ⁺IsCorrect k′ v′ ( 1# , tˡ ) tʳ ∼+ k<k′ k∈tˡ = {!!}
    lemJoinˡ⁺IsCorrect k′ v′ ( 0# , tˡ ) tʳ bal k<k′ k∈tˡ = {!!}

    𝒍𝒆𝒎𝒎𝒂∶insertWith⟶∈ : ∀ { l u h } ( k : Key ) ( v : Value k ) ( f : Value k → Value k → Value k ) ( t : Tree l u h ) ( l<k<u : l < k < u ) → k ∈ proj₂ (insertWith k v f t l<k<u)
    𝒍𝒆𝒎𝒎𝒂∶insertWith⟶∈ _ v _ (leaf _) _ = here v
    𝒍𝒆𝒎𝒎𝒂∶insertWith⟶∈ k v f (node (kₜ , vₜ) tₗ tᵣ bal) (l<k , k<u) with compare k kₜ
    ... | tri< k<kₜ _ _ = lemJoinˡ⁺IsCorrect kₜ vₜ (insertWith k v f tₗ (l<k , k<kₜ)) tᵣ bal k<kₜ (𝒍𝒆𝒎𝒎𝒂∶insertWith⟶∈ k v f tₗ (l<k , k<kₜ))
    ... | tri> _ _ kₜ<k = {!!}
    ... | tri≈ _ k≡kₜ _ = {!!}















  {-
  data Tree⋆ (l u : Key⁺) : ℕ → Set (k ⊔ v ⊔ ℓ) where
    leaf : (l<u : l <⁺ u) → Tree⋆ l u 0
    node : ∀ {hˡ hʳ h}
           (kv : KV)
           (lk : Tree⋆ l [ proj₁ kv ] hˡ)
           (ku : Tree⋆ [ proj₁ kv ] u hʳ)
           (bal : hˡ ∼ hʳ ⊔ h)
           (l<k<u : l < proj₁ kv < u)
           → Tree⋆ l u (suc h)

  {-
  YellowError-toTree : ∀ {l u h} → Tree⋆ l u h → Tree l u h
  YellowError-toTree (leaf l<u) = leaf l<u
  YellowError-toTree (node kv tl tu bal l<k<u) = node {!!} {!!} {!!} {!!}
  -}

  toTree : ∀ {l u h} → Tree⋆ l u h → Tree l u h
  toTree (leaf l<u) = leaf l<u
  toTree (node kv tl tu bal l<k<u) = node kv (toTree tl) (toTree tu) bal

  ok_joinˡ⁺ : ∀ { l u hˡ hʳ h } →
      ( kv : KV ) →
      ( tˡ⁺⋆ : ∃ λ i → Tree⋆ l [ proj₁ kv ] ( i ⊕ hˡ ) ) →
      ( tʳ⋆ : Tree⋆ [ proj₁ kv ] u hʳ ) →
      ( bal : hˡ ∼ hʳ ⊔ h ) →
      ( l<k<u : l < proj₁ kv < u ) →
      ∃ λ tʲ⋆ → toTree tʲ⋆ ≡ proj₂ ( joinˡ⁺ kv ( proj₁ tˡ⁺⋆ , toTree ( proj₂ tˡ⁺⋆ ) ) ( toTree tʳ⋆ ) bal )
  ok_joinˡ⁺ kv ( 1# , node kvˡ tˡˡ⋆ ( node kvˡʳ tˡʳˡ⋆ tˡʳʳ⋆ bal kˡ<kˡʳ<k ) ∼+ l<kˡ<k ) tʳ⋆ ∼- l<k<u = {!!} , {!!}
  ok_joinˡ⁺ kv ( 1# , node kvˡ tˡˡ⋆ tˡʳ⋆ ∼- l<kˡ<k ) tʳ⋆ ∼- l<k<u = {!!} , {!!}
  ok_joinˡ⁺ kv ( 1# , node kvˡ tˡˡ⋆ tˡʳ⋆ ∼0 l<kˡ<k ) tʳ⋆ ∼- ( l<k , k<u ) = {!!} , {!!}
  ok_joinˡ⁺ kv ( 1# , tˡ⋆ ) tʳ⋆  ∼0 l<k<u = {!!} , {!!}
  ok_joinˡ⁺ kv ( 1# , tˡ⋆ ) tʳ⋆  ∼+ l<k<u = {!!} , {!!} -- How do I fill this out?
  {- If I try this:
  ok_joinˡ⁺ kv ( 1# , tˡ⋆ ) tʳ⋆  ∼+ l<k<u = node kv  tˡ⋆ tʳ⋆ ∼0 l<k<u , P.refl

  I get the following error:
  suc (suc .hˡ) != 
  proj₁ (joinˡ⁺ kv (1# , toTree tˡ⋆) (toTree tʳ⋆) ∼+) ⊕ (1 + suc .hˡ)
  of type ℕ
  when checking that the expression 
  node kv tˡ⋆ tʳ⋆ ∼0 l<k<u 
  has type
  Tree⋆ .l .u (proj₁ (joinˡ⁺ kv (1# , toTree tˡ⋆) (toTree tʳ⋆) ∼+) ⊕ (1 + suc .hˡ))
  -}
  ok_joinˡ⁺ kv ( 0# , tˡ⋆ ) tʳ⋆ bal l<k<u = node kv tˡ⋆ tʳ⋆ bal l<k<u , P.refl
  -}













  {-


  -- 


  -}


  {-
  -}
  {-
  ∀ {l u hˡ hʳ h} →
       (k : KV) →
       (∃ λ i → Tree l [ proj₁ k ] (i ⊕ hˡ)) →
       Tree [ proj₁ k ] u hʳ →
       (bal : hˡ ∼ hʳ ⊔ h) →
       ∃ λ i → Tree l u (i ⊕ (1 + h))
  --      𝒍𝒆𝒎𝒎𝒂:

  𝒍𝒆𝒎𝒎𝒂:ChreeJoinˡ⁺ : ∀ {l u hˡ hʳ h}
       (kv : KV)
       (∃lt : ∃ λ i → Chree l [ proj₁ k ] (i ⊕ hˡ))
       {lti} {lt}
       (_ : lt ≡ proj₂ ∃lt)
       (rt : Chree [ proj₁ k ] u hʳ)
       (bal : hˡ ∼ hʳ ⊔ h)
       (_ : LT ≡ toTree lt)
       (out : ∃ λ i → Tree l u (i ⊕ (1 + h)))
       joinˡ⁺ kv ∃lt rt bal

       ∃ λ i → Tree l u (i ⊕ (1 + h))
       ∃ λ j → j ≡ joinˡ⁺ kv 
  -}

  {-


  𝒍𝒆𝒎𝒎𝒂∶lookup⇔∈ : ∀ {l u h} (x : Key) (S : Tree l u h) → l < x < u →
                              ((∃ λ v → lookup x S ≡ just v) → x ∈ S) ×
                              (x ∈ S → (∃ λ v → lookup x S ≡ just v))
  𝒍𝒆𝒎𝒎𝒂∶lookup⇔∈ x S l<x<u = 𝒍𝒆𝒎𝒎𝒂∶lookup⟶∈ x S l<x<u , 𝒍𝒆𝒎𝒎𝒂∶∈⟶lookup x S l<x<u

  open import Data.Maybe using (just)

  thmInsertIsCorrect : ∀ k v t → AVL.lookup k (AVL.insert k v t) ≡ just v
  thmInsertIsCorrect = {!!}
  -}

-}
