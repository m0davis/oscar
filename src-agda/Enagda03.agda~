open import Data.Empty
open import Data.Product
open import Level using (_âŠ”_)
open import Relation.Binary
open import Relation.Binary.PropositionalEquality as P using (_â‰¡_)
open import Relation.Nullary

module Data.AVL.Properties
  {k v â„“}
  {Key : Set k} (Value : Key â†’ Set v)
  {_<_ : Rel Key â„“}
  (isStrictTotalOrder : IsStrictTotalOrder P._â‰¡_ _<_) where

open import Data.AVL Value isStrictTotalOrder using (KV; module Extended-key; module Height-invariants; module Indexed)
open Extended-key
open Height-invariants
open Indexed

open IsStrictTotalOrder isStrictTotalOrder

data _âˆˆ_ {lb ub} (key : Key) : âˆ€ {n} â†’ Tree lb ub n â†’ Set (k âŠ” v âŠ” â„“) where
  here : âˆ€ {hË¡ hÊ³ h v}
    {lk : Tree lb [ key ] hË¡}
    {ku : Tree [ key ]  ub hÊ³}
    {bal : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
    key âˆˆ node (key , v) lk ku bal
  left : âˆ€ {hË¡ hÊ³ h kâ€²} {vâ€² : Value kâ€²}
    {lkâ€² : Tree lb [ kâ€² ] hË¡}
    {kâ€²u : Tree [ kâ€² ] ub hÊ³}
    {bal : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
    key âˆˆ lkâ€² â†’
    key âˆˆ node (kâ€² , vâ€²) lkâ€² kâ€²u bal
  right : âˆ€ {hË¡ hÊ³ h kâ€²} {vâ€² : Value kâ€²}
    {lkâ€² : Tree lb [ kâ€² ] hË¡}
    {kâ€²u : Tree [ kâ€² ] ub hÊ³}
    {bal : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
    key âˆˆ kâ€²u â†’
    key âˆˆ node (kâ€² , vâ€²) lkâ€² kâ€²u bal

lemJoinË¡âºIsCorrect : âˆ€ { l r hË¡ hÊ³ h }
    { kâ€² : Key }
    { vâ€² : Value kâ€² }
    ( tË¡âº : âˆƒ Î» i â†’ Tree l [ kâ€² ] ( i âŠ• hË¡ ) )
    ( tÊ³ : Tree [ kâ€² ] r hÊ³ )
    ( bal : hË¡ âˆ¼ hÊ³ âŠ” h )
    { key : Key }
    ( kâˆˆtË¡ : key âˆˆ projâ‚‚ tË¡âº ) â†’
    key âˆˆ projâ‚‚ ( joinË¡âº ( kâ€² , vâ€² ) tË¡âº tÊ³ bal )
lemJoinË¡âºIsCorrect ( 1# , node _ _ ( node _ _ _ _ ) âˆ¼+ ) _ âˆ¼- here = left here
lemJoinË¡âºIsCorrect ( 1# , node _ _ ( node _ _ _ _ ) âˆ¼+ ) _ âˆ¼- ( left kâˆˆtË¡ ) = left ( left kâˆˆtË¡ )
lemJoinË¡âºIsCorrect ( 1# , node _ _ ( node _ _ _ _ ) âˆ¼+ ) _ âˆ¼- ( right here ) = here
lemJoinË¡âºIsCorrect ( 1# , node _ _ ( node _ _ _ _ ) âˆ¼+ ) _ âˆ¼- ( right ( left kâˆˆtÊ³Ë¡ ) ) = left ( right kâˆˆtÊ³Ë¡ )
lemJoinË¡âºIsCorrect ( 1# , node _ _ ( node _ _ _ _ ) âˆ¼+ ) _ âˆ¼- ( right ( right kâˆˆtÊ³Ê³ ) ) = right ( left kâˆˆtÊ³Ê³ )
lemJoinË¡âºIsCorrect ( 1# , node _ _ _ âˆ¼- ) _ âˆ¼- here = {!here!}
lemJoinË¡âºIsCorrect ( 1# , node _ _ _ âˆ¼- ) _ âˆ¼- ( left kâˆˆtË¡Ë¡ ) = {!left kâˆˆtË¡Ë¡!}
lemJoinË¡âºIsCorrect ( 1# , node _ _ _ âˆ¼- ) _ âˆ¼- ( right kâˆˆtË¡Ê³ ) = {!right ( left ( kâˆˆtË¡Ê³ ) )!}
lemJoinË¡âºIsCorrect ( 1# , node _ _ _ âˆ¼0 ) _ âˆ¼- here = {!here!}
lemJoinË¡âºIsCorrect ( 1# , node _ _ _ âˆ¼0 ) _ âˆ¼- ( left kâˆˆtË¡Ë¡ ) = {!left kâˆˆtË¡Ë¡!}
lemJoinË¡âºIsCorrect ( 1# , node _ _ _ âˆ¼0 ) _ âˆ¼- ( right kâˆˆtË¡Ê³ ) = {!right ( left ( kâˆˆtË¡Ê³ ) )!}
lemJoinË¡âºIsCorrect ( 1# , _ ) _ âˆ¼0 kâˆˆtË¡ = {!left kâˆˆtË¡!}
lemJoinË¡âºIsCorrect ( 1# , _ ) _ âˆ¼+ kâˆˆtË¡ = {!left kâˆˆtË¡!}
lemJoinË¡âºIsCorrect ( 0# , _ ) _ _ kâˆˆtË¡ = left kâˆˆtË¡



l<âºu : âˆ€ { l u h } â†’ Tree l u h â†’ l <âº u
l<âºu ( leaf l<u ) = l<u
l<âºu { l = l } ( node _ lk ku _ ) = transâº l ( l<âºu lk ) ( l<âºu ku )


lemKâˆˆBounds : âˆ€ { l u h } { t : Tree l u h } { key : Key } â†’ key âˆˆ t â†’ l < key < u
lemKâˆˆBounds ( here {lk = lk} {ku = ku} ) = ( l<âºu lk ) , ( l<âºu ku )
lemKâˆˆBounds { l = l } { u = u } { key = key } ( left { kâ€² = kâ€² } { kâ€²u = kâ€²u } kâˆˆtË¡ ) = l<k , k<u where

  l<k<kâ€² : l < key < [ kâ€² ]
  l<k<kâ€² = lemKâˆˆBounds kâˆˆtË¡

  l<k : l <âº [ key ]
  l<k = projâ‚ l<k<kâ€²

  k<kâ€² : [ key ] <âº [ kâ€² ]
  k<kâ€² = projâ‚‚ l<k<kâ€²

  kâ€²<u : [ kâ€² ] <âº u
  kâ€²<u = l<âºu kâ€²u

  k<u : [ key ] <âº u
  k<u = transâº [ key ] { m = [ kâ€² ] } { u = u } k<kâ€² kâ€²<u

lemKâˆˆBounds { l = l } { u = u } { key = key } ( right { kâ€² = kâ€² } { lkâ€² = lkâ€² } kâˆˆtÊ³ ) = l<k , k<u where

  kâ€²<k<u : [ kâ€² ] < key < u
  kâ€²<k<u = lemKâˆˆBounds kâˆˆtÊ³

  k<u : [ key ] <âº u
  k<u = projâ‚‚ kâ€²<k<u

  kâ€²<k : [ kâ€² ] <âº [ key ] 
  kâ€²<k = projâ‚ kâ€²<k<u

  l<kâ€² : l <âº [ kâ€² ]
  l<kâ€² = l<âºu lkâ€²

  l<k : l <âº [ key ]
  l<k = transâº l { m = [ kâ€² ] } { u = [ key ] } l<kâ€² kâ€²<k

module âˆˆ-simple where

  open import Relation.Binary.PropositionalEquality
  open import Function
  open import Relation.Nullary.Negation

  open import Data.Maybe

  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ : âˆ€ { l u h } ( k : Key ) ( t : Tree l u h ) â†’ ( âˆƒ Î» v â†’ lookup k t â‰¡ just v ) â†’ k âˆˆ t
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ _ (leaf _) (_ , ())
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ k ( node ( kâ‚œ , vâ‚œ ) tâ‚— táµ¤ _ ) lookupâŸ¶ with compare k kâ‚œ
  ... | tri< k<kâ‚œ _ _              = left  ( ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ k tâ‚— lookupâŸ¶ )
  ... | tri> _ _ kâ‚œ<k              = right ( ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ k táµ¤ lookupâŸ¶ )
  ... | triâ‰ˆ _ kâ‰¡kâ‚œ _ rewrite kâ‰¡kâ‚œ = here

  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup : âˆ€ { l u h } ( k : Key ) ( t : Tree l u h ) â†’ k âˆˆ t â†’ âˆƒ Î» v â†’ lookup k t â‰¡ just v
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup _ ( leaf _ ) ()
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k ( node ._ _ _ ._ ) here with compare k k
  ... | tri< _ kâ‰¢k _ = contradiction refl kâ‰¢k
  ... | triâ‰ˆ _ refl _ = , refl
  ... | tri> _ kâ‰¢k _ = contradiction refl kâ‰¢k
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k ( node ( k' , _ ) tâ‚— _ ._ ) ( left kâˆˆtâ‚— ) with compare k k'
  ... | tri< _ _ _ = ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k tâ‚— kâˆˆtâ‚—
  ... | triâ‰ˆ kâ‰®k' _ _ = contradiction k<k' kâ‰®k'
    where k<k' = projâ‚‚ (lemKâˆˆBounds kâˆˆtâ‚—)
  ... | tri> kâ‰®k' _ _ = contradiction k<k' kâ‰®k'
    where k<k' = projâ‚‚ (lemKâˆˆBounds kâˆˆtâ‚—)
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k ( node ( k' , _ ) _ táµ£ ._ ) ( right kâˆˆtáµ£ ) with compare k k'
  ... | tri< _ _ kâ‰¯k' = contradiction {!k'<k!} kâ‰¯k'
  ... | triâ‰ˆ _ _ kâ‰¯k' = contradiction {!k'<k!} kâ‰¯k'
  ... | tri> _ _ _ = ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k táµ£ kâˆˆtáµ£

  open import Data.Nat.Base using (suc)









































{-

module âˆˆ-with-ordering where

  data _âˆˆ_ {lb ub} (K : Key) : âˆ€ {n} â†’ Tree lb ub n â†’ Set (Îº âŠ” Ï… âŠ” â„“) where
    here : âˆ€ {hË¡ hÊ³} V 
      {l : Tree lb [ K  ] hË¡}
      {r : Tree [ K ]  ub hÊ³}
      {b : âˆƒ Î» h â†’ hË¡ âˆ¼ hÊ³ âŠ” h} â†’
      K âˆˆ node (K , V) l r (projâ‚‚ b)
    left : âˆ€ {hË¡ hÊ³ Kâ€²} {V : Value Kâ€²}
      {l : Tree lb [ Kâ€² ] hË¡}
      {r : Tree [ Kâ€² ] ub hÊ³}
      {b : âˆƒ Î» h â†’ hË¡ âˆ¼ hÊ³ âŠ” h} â†’
      K < Kâ€² â†’
      K âˆˆ l â†’
      K âˆˆ node (Kâ€² , V) l r (projâ‚‚ b)
    right : âˆ€ {hË¡ hÊ³ Kâ€²} {V : Value Kâ€²}
      {l : Tree lb [ Kâ€² ] hË¡}
      {r : Tree [ Kâ€² ] ub hÊ³}
      {b : âˆƒ Î» h â†’ hË¡ âˆ¼ hÊ³ âŠ” h} â†’
      Kâ€² < K â†’
      K âˆˆ r â†’
      K âˆˆ node (Kâ€² , V) l r (projâ‚‚ b)

  private
    _â‰®_ = Î» x y â†’ Â¬ (x < y)
    _â‰¯_ = Î» x y â†’ Â¬ (y < x)

    _â‰¢_ : (x y : Key) â†’ _
    _â‰¢_ = Î» x y â†’ Â¬ (x â‰¡ y)

  lem : âˆ€ {lb ub hË¡ hÊ³ h Kâ€² n} {V : Value Kâ€²}
      {l : Tree lb [ Kâ€² ] hË¡}
      {r : Tree [ Kâ€² ] ub hÊ³}
      {b : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
      n âˆˆ node (Kâ€² , V) l r b â†’
      (n â‰¯ Kâ€² â†’ n â‰¢ Kâ€² â†’ n âˆˆ l) Ã— (n â‰® Kâ€² â†’ n â‰¢ Kâ€² â†’ n âˆˆ r)
  lem (here    V) = (Î» _ eq â†’ âŠ¥-elim (eq P.refl)) , (Î» _ eq â†’ âŠ¥-elim (eq P.refl))
  lem (left  x p) = (Î» _ _ â†’ p) , (Î» â‰® _ â†’ âŠ¥-elim (â‰® x))
  lem (right x p) = (Î» â‰¯ _ â†’ âŠ¥-elim (â‰¯ x)) , (Î» _ _ â†’ p)

  find : âˆ€ {h lb ub} n (m : Tree lb ub h) â†’ Dec (n âˆˆ m)
  find n (leaf _) = no Î» ()
  find n (node (k , v) l r _) with compare n k
  find n (node (k , v) l r _) | tri< a Â¬b Â¬c with find n l
  ... | yes p = yes (left a p)
  ... | no Â¬p = no Î» Â¬âˆˆl â†’ Â¬p (projâ‚ (lem Â¬âˆˆl) Â¬c Â¬b)
  find n (node (k , v) l r _) | triâ‰ˆ Â¬a b Â¬c rewrite (P.sym b) = yes (here v)
  find n (node (k , v) l r _) | tri> Â¬a Â¬b c with find n r
  ... | yes p = yes (right c p)
  ... | no Â¬p = no Î» Â¬âˆˆr â†’ Â¬p (projâ‚‚ (lem Â¬âˆˆr) Â¬a Â¬b)

  get : âˆ€ {h lb ub n} {m : Tree lb ub h} â†’ n âˆˆ m â†’ Value n
  get (here    V) = V
  get (left  _ p) = get p
  get (right _ p) = get p

  module lookup where

    open import Relation.Binary.PropositionalEquality
    open import Function
    open import Relation.Nullary.Negation

    open import Data.Maybe

    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ : âˆ€ { l u h } ( k : Key ) ( t : Tree l u h ) â†’ l < k < u â†’ ( âˆƒ Î» v â†’ lookup k t â‰¡ just v ) â†’ k âˆˆ t
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ _ (leaf _) _ (_ , ())
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ k ( node ( kâ‚œ , vâ‚œ ) tâ‚— táµ¤ _ ) ( l<k , k<u ) lookupâŸ¶ with compare k kâ‚œ
    ... | tri< k<kâ‚œ _ _              = left  k<kâ‚œ ( ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ k tâ‚— ( l<k  , k<kâ‚œ ) lookupâŸ¶ )
    ... | tri> _ _ kâ‚œ<k              = right kâ‚œ<k ( ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ k táµ¤ ( kâ‚œ<k , k<u  ) lookupâŸ¶ )
    ... | triâ‰ˆ _ kâ‰¡kâ‚œ _ rewrite kâ‰¡kâ‚œ = here vâ‚œ

    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup : âˆ€ { l u h } ( k : Key ) ( t : Tree l u h ) â†’ l < k < u â†’ k âˆˆ t â†’ âˆƒ Î» v â†’ lookup k t â‰¡ just v
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup _ ( leaf _ ) _ ()
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k ( node ._ _ _ ._ ) _ ( here _ ) with compare k k
    ... | tri< _ kâ‰¢k _ = contradiction refl kâ‰¢k
    ... | triâ‰ˆ _ refl _ = , refl
    ... | tri> _ kâ‰¢k _ = contradiction refl kâ‰¢k
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k ( node ( k' , _ ) tâ‚— _ ._ ) ( l<k , _ ) ( left k<k' kâˆˆtâ‚— ) with compare k k'
    ... | tri< _ _ _ = ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k tâ‚— ( l<k , k<k' ) kâˆˆtâ‚—
    ... | triâ‰ˆ kâ‰®k' _ _ = contradiction k<k' kâ‰®k'
    ... | tri> kâ‰®k' _ _ = contradiction k<k' kâ‰®k'
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k ( node ( k' , _ ) _ táµ£ ._ ) ( _ , k<u ) ( right k'<k kâˆˆtáµ£ ) with compare k k'
    ... | tri< _ _ kâ‰¯k' = contradiction k'<k kâ‰¯k'
    ... | triâ‰ˆ _ _ kâ‰¯k' = contradiction k'<k kâ‰¯k'
    ... | tri> _ _ _ = ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup k táµ£ ( k'<k , k<u ) kâˆˆtáµ£

  module insertWith where

    data _âˆˆâ€²_ {lb ub} (K : Key) : âˆ€ {n} â†’ Tree lb ub n â†’ Set (Îº âŠ” Ï… âŠ” â„“) where
      here : âˆ€ {hË¡ hÊ³} V
        {l : Tree lb [ K ] hË¡}
        {r : Tree [ K ] ub hÊ³}
        {h : _}
        {b : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
        K âˆˆâ€² node (K , V) l r b
      left : âˆ€ {hË¡ hÊ³ Kâ€²} {V : Value Kâ€²}
        {l : Tree lb [ Kâ€² ] hË¡}
        {r : Tree [ Kâ€² ] ub hÊ³}
        {h : _} â†’
        {b : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
        K < Kâ€² â†’
        K âˆˆâ€² l â†’
        K âˆˆâ€² node (Kâ€² , V) l r b
      right : âˆ€ {hË¡ hÊ³ Kâ€²} {V : Value Kâ€²}
        {l : Tree lb [ Kâ€² ] hË¡}
        {r : Tree [ Kâ€² ] ub hÊ³}
        {h : _} â†’
        {b : hË¡ âˆ¼ hÊ³ âŠ” h} â†’
        Kâ€² < K â†’
        K âˆˆâ€² r â†’
        K âˆˆâ€² node (Kâ€² , V) l r b

    âˆˆâ†’âˆˆâ€² : âˆ€ {lb ub n} {x} {S : Tree lb ub n} â†’ x âˆˆ S â†’ x âˆˆâ€² S
    âˆˆâ†’âˆˆâ€² (here V) = here V
    âˆˆâ†’âˆˆâ€² (left xâ‚ xâ‚‚) = left xâ‚ (âˆˆâ†’âˆˆâ€² xâ‚‚)
    âˆˆâ†’âˆˆâ€² (right xâ‚ xâ‚‚) = right xâ‚ (âˆˆâ†’âˆˆâ€² xâ‚‚)

    âˆˆâ€²â†’âˆˆ : âˆ€ {lb ub n} {x} {S : Tree lb ub n} â†’ x âˆˆâ€² S â†’ x âˆˆ S
    âˆˆâ€²â†’âˆˆ (here V) = here V
    âˆˆâ€²â†’âˆˆ (left xâ‚ xâ‚‚) = left xâ‚ (âˆˆâ€²â†’âˆˆ xâ‚‚)
    âˆˆâ€²â†’âˆˆ (right xâ‚ xâ‚‚) = right xâ‚ (âˆˆâ€²â†’âˆˆ xâ‚‚)

    lemJoinË¡âºIsCorrect : âˆ€ { l r hË¡ hÊ³ h }
        ( kâ€² : Key )
        ( vâ€² : Value kâ€² )
        ( tË¡âº : âˆƒ Î» i â†’ Tree l [ kâ€² ] ( i âŠ• hË¡ ) )
        ( tÊ³ : Tree [ kâ€² ] r hÊ³ )
        ( bal : hË¡ âˆ¼ hÊ³ âŠ” h )
        { kh : Key }
        ( k<kâ€² : kh < kâ€² )
        ( kâˆˆtË¡ : kh âˆˆ projâ‚‚ tË¡âº ) â†’
        kh âˆˆ projâ‚‚ ( joinË¡âº ( kâ€² , vâ€² ) tË¡âº tÊ³ bal )
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 1# , node ( kË¡ , vË¡ ) tlË¡ ( node ( kÊ³ , vÊ³ ) tlÊ³ tuÊ³ balÊ³ ) âˆ¼+ ) tâ‚Ê³ âˆ¼- { kh = kh } k<kâ€² kâˆˆtË¡ with âˆˆâ†’âˆˆâ€² kâˆˆtË¡
    lemJoinË¡âºIsCorrect kâ€² vâ€² (1# , node (kË¡ , vË¡) tlË¡ (node (kÊ³ , vÊ³) tlÊ³ tuÊ³ balÊ³) âˆ¼+) tâ‚Ê³ âˆ¼- k<kâ€² kâˆˆtË¡ | here .vË¡ = left (lemTreeBounds tlÊ³) (here vË¡)
    lemJoinË¡âºIsCorrect kâ€² vâ€² (1# , node (kË¡ , vË¡) tlË¡ (node (kÊ³ , vÊ³) tlÊ³ tuÊ³ balÊ³) âˆ¼+) tâ‚Ê³ âˆ¼- { kh = kh } k<kâ€² kâˆˆtË¡ | left k<kË¡ kâˆˆâ€²tË¡ = left {-(transâº {!!} k<kË¡ (lemTreeBounds tlÊ³))-} {!!} (left k<kË¡ (âˆˆâ€²â†’âˆˆ kâˆˆâ€²tË¡))
    lemJoinË¡âºIsCorrect kâ€² vâ€² (1# , node (kË¡ , vË¡) tlË¡ (node (kÊ³ , vÊ³) tlÊ³ tuÊ³ balÊ³) âˆ¼+) tâ‚Ê³ âˆ¼- k<kâ€² kâˆˆtË¡ | right x kâˆˆâ€²tË¡ = {!!}
  {-      
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 1# , node ( kË¡ , vË¡ ) tlË¡ ( node ( kÊ³ , vÊ³ ) tlÊ³ tuÊ³ balÊ³ ) âˆ¼+ ) tâ‚Ê³ âˆ¼- { kh = kË¡1 } k<kâ€² kâˆˆtË¡ with âˆˆâ†’âˆˆâ€² kâˆˆtË¡
    ... | here .vË¡ = left (lemTreeBounds tlÊ³) (here vË¡)
    ... | left k<kË¡ kâˆˆâ€²tË¡  = left {-(transâº {!!} k<kË¡ (lemTreeBounds tlÊ³))-} {!!} (left k<kË¡ (âˆˆâ€²â†’âˆˆ kâˆˆâ€²tË¡))
    ... | right _ _ = {!!}
  -}
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 1# , node kâ‚ tâ‚Ë¡ tâ‚Ê³ âˆ¼- ) tÊ³ âˆ¼- k<kâ€² kâˆˆtË¡ = {!!}
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 1# , node kâ‚ tâ‚Ë¡ tâ‚Ê³ âˆ¼0 ) tÊ³ âˆ¼- k<kâ€² kâˆˆtË¡ = {!!}
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 1# , tË¡ ) tÊ³ âˆ¼0 k<kâ€² kâˆˆtË¡ = {!!}
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 1# , tË¡ ) tÊ³ âˆ¼+ k<kâ€² kâˆˆtË¡ = {!!}
    lemJoinË¡âºIsCorrect kâ€² vâ€² ( 0# , tË¡ ) tÊ³ bal k<kâ€² kâˆˆtË¡ = {!!}

    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶insertWithâŸ¶âˆˆ : âˆ€ { l u h } ( k : Key ) ( v : Value k ) ( f : Value k â†’ Value k â†’ Value k ) ( t : Tree l u h ) ( l<k<u : l < k < u ) â†’ k âˆˆ projâ‚‚ (insertWith k v f t l<k<u)
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶insertWithâŸ¶âˆˆ _ v _ (leaf _) _ = here v
    ğ’ğ’†ğ’ğ’ğ’‚âˆ¶insertWithâŸ¶âˆˆ k v f (node (kâ‚œ , vâ‚œ) tâ‚— táµ£ bal) (l<k , k<u) with compare k kâ‚œ
    ... | tri< k<kâ‚œ _ _ = lemJoinË¡âºIsCorrect kâ‚œ vâ‚œ (insertWith k v f tâ‚— (l<k , k<kâ‚œ)) táµ£ bal k<kâ‚œ (ğ’ğ’†ğ’ğ’ğ’‚âˆ¶insertWithâŸ¶âˆˆ k v f tâ‚— (l<k , k<kâ‚œ))
    ... | tri> _ _ kâ‚œ<k = {!!}
    ... | triâ‰ˆ _ kâ‰¡kâ‚œ _ = {!!}















  {-
  data Treeâ‹† (l u : Keyâº) : â„• â†’ Set (k âŠ” v âŠ” â„“) where
    leaf : (l<u : l <âº u) â†’ Treeâ‹† l u 0
    node : âˆ€ {hË¡ hÊ³ h}
           (kv : KV)
           (lk : Treeâ‹† l [ projâ‚ kv ] hË¡)
           (ku : Treeâ‹† [ projâ‚ kv ] u hÊ³)
           (bal : hË¡ âˆ¼ hÊ³ âŠ” h)
           (l<k<u : l < projâ‚ kv < u)
           â†’ Treeâ‹† l u (suc h)

  {-
  YellowError-toTree : âˆ€ {l u h} â†’ Treeâ‹† l u h â†’ Tree l u h
  YellowError-toTree (leaf l<u) = leaf l<u
  YellowError-toTree (node kv tl tu bal l<k<u) = node {!!} {!!} {!!} {!!}
  -}

  toTree : âˆ€ {l u h} â†’ Treeâ‹† l u h â†’ Tree l u h
  toTree (leaf l<u) = leaf l<u
  toTree (node kv tl tu bal l<k<u) = node kv (toTree tl) (toTree tu) bal

  ok_joinË¡âº : âˆ€ { l u hË¡ hÊ³ h } â†’
      ( kv : KV ) â†’
      ( tË¡âºâ‹† : âˆƒ Î» i â†’ Treeâ‹† l [ projâ‚ kv ] ( i âŠ• hË¡ ) ) â†’
      ( tÊ³â‹† : Treeâ‹† [ projâ‚ kv ] u hÊ³ ) â†’
      ( bal : hË¡ âˆ¼ hÊ³ âŠ” h ) â†’
      ( l<k<u : l < projâ‚ kv < u ) â†’
      âˆƒ Î» tÊ²â‹† â†’ toTree tÊ²â‹† â‰¡ projâ‚‚ ( joinË¡âº kv ( projâ‚ tË¡âºâ‹† , toTree ( projâ‚‚ tË¡âºâ‹† ) ) ( toTree tÊ³â‹† ) bal )
  ok_joinË¡âº kv ( 1# , node kvË¡ tË¡Ë¡â‹† ( node kvË¡Ê³ tË¡Ê³Ë¡â‹† tË¡Ê³Ê³â‹† bal kË¡<kË¡Ê³<k ) âˆ¼+ l<kË¡<k ) tÊ³â‹† âˆ¼- l<k<u = {!!} , {!!}
  ok_joinË¡âº kv ( 1# , node kvË¡ tË¡Ë¡â‹† tË¡Ê³â‹† âˆ¼- l<kË¡<k ) tÊ³â‹† âˆ¼- l<k<u = {!!} , {!!}
  ok_joinË¡âº kv ( 1# , node kvË¡ tË¡Ë¡â‹† tË¡Ê³â‹† âˆ¼0 l<kË¡<k ) tÊ³â‹† âˆ¼- ( l<k , k<u ) = {!!} , {!!}
  ok_joinË¡âº kv ( 1# , tË¡â‹† ) tÊ³â‹†  âˆ¼0 l<k<u = {!!} , {!!}
  ok_joinË¡âº kv ( 1# , tË¡â‹† ) tÊ³â‹†  âˆ¼+ l<k<u = {!!} , {!!} -- How do I fill this out?
  {- If I try this:
  ok_joinË¡âº kv ( 1# , tË¡â‹† ) tÊ³â‹†  âˆ¼+ l<k<u = node kv  tË¡â‹† tÊ³â‹† âˆ¼0 l<k<u , P.refl

  I get the following error:
  suc (suc .hË¡) != 
  projâ‚ (joinË¡âº kv (1# , toTree tË¡â‹†) (toTree tÊ³â‹†) âˆ¼+) âŠ• (1 + suc .hË¡)
  of type â„•
  when checking that the expression 
  node kv tË¡â‹† tÊ³â‹† âˆ¼0 l<k<u 
  has type
  Treeâ‹† .l .u (projâ‚ (joinË¡âº kv (1# , toTree tË¡â‹†) (toTree tÊ³â‹†) âˆ¼+) âŠ• (1 + suc .hË¡))
  -}
  ok_joinË¡âº kv ( 0# , tË¡â‹† ) tÊ³â‹† bal l<k<u = node kv tË¡â‹† tÊ³â‹† bal l<k<u , P.refl
  -}













  {-


  -- 


  -}


  {-
  -}
  {-
  âˆ€ {l u hË¡ hÊ³ h} â†’
       (k : KV) â†’
       (âˆƒ Î» i â†’ Tree l [ projâ‚ k ] (i âŠ• hË¡)) â†’
       Tree [ projâ‚ k ] u hÊ³ â†’
       (bal : hË¡ âˆ¼ hÊ³ âŠ” h) â†’
       âˆƒ Î» i â†’ Tree l u (i âŠ• (1 + h))
  --      ğ’ğ’†ğ’ğ’ğ’‚:

  ğ’ğ’†ğ’ğ’ğ’‚:ChreeJoinË¡âº : âˆ€ {l u hË¡ hÊ³ h}
       (kv : KV)
       (âˆƒlt : âˆƒ Î» i â†’ Chree l [ projâ‚ k ] (i âŠ• hË¡))
       {lti} {lt}
       (_ : lt â‰¡ projâ‚‚ âˆƒlt)
       (rt : Chree [ projâ‚ k ] u hÊ³)
       (bal : hË¡ âˆ¼ hÊ³ âŠ” h)
       (_ : LT â‰¡ toTree lt)
       (out : âˆƒ Î» i â†’ Tree l u (i âŠ• (1 + h)))
       joinË¡âº kv âˆƒlt rt bal

       âˆƒ Î» i â†’ Tree l u (i âŠ• (1 + h))
       âˆƒ Î» j â†’ j â‰¡ joinË¡âº kv 
  -}

  {-


  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâ‡”âˆˆ : âˆ€ {l u h} (x : Key) (S : Tree l u h) â†’ l < x < u â†’
                              ((âˆƒ Î» v â†’ lookup x S â‰¡ just v) â†’ x âˆˆ S) Ã—
                              (x âˆˆ S â†’ (âˆƒ Î» v â†’ lookup x S â‰¡ just v))
  ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâ‡”âˆˆ x S l<x<u = ğ’ğ’†ğ’ğ’ğ’‚âˆ¶lookupâŸ¶âˆˆ x S l<x<u , ğ’ğ’†ğ’ğ’ğ’‚âˆ¶âˆˆâŸ¶lookup x S l<x<u

  open import Data.Maybe using (just)

  thmInsertIsCorrect : âˆ€ k v t â†’ AVL.lookup k (AVL.insert k v t) â‰¡ just v
  thmInsertIsCorrect = {!!}
  -}

-}
